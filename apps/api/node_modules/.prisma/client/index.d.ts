
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Symbol
 * 
 */
export type Symbol = $Result.DefaultSelection<Prisma.$SymbolPayload>
/**
 * Model Candle
 * 
 */
export type Candle = $Result.DefaultSelection<Prisma.$CandlePayload>
/**
 * Model IndicatorCache
 * 
 */
export type IndicatorCache = $Result.DefaultSelection<Prisma.$IndicatorCachePayload>
/**
 * Model Watchlist
 * 
 */
export type Watchlist = $Result.DefaultSelection<Prisma.$WatchlistPayload>
/**
 * Model WatchlistSymbol
 * 
 */
export type WatchlistSymbol = $Result.DefaultSelection<Prisma.$WatchlistSymbolPayload>
/**
 * Model SavedScan
 * 
 */
export type SavedScan = $Result.DefaultSelection<Prisma.$SavedScanPayload>
/**
 * Model SavedScanVersion
 * 
 */
export type SavedScanVersion = $Result.DefaultSelection<Prisma.$SavedScanVersionPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model Backtest
 * 
 */
export type Backtest = $Result.DefaultSelection<Prisma.$BacktestPayload>
/**
 * Model FinancialMetric
 * 
 */
export type FinancialMetric = $Result.DefaultSelection<Prisma.$FinancialMetricPayload>
/**
 * Model SystemStatus
 * 
 */
export type SystemStatus = $Result.DefaultSelection<Prisma.$SystemStatusPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  FREE: 'FREE',
  PRO: 'PRO',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  DELETED: 'DELETED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const Exchange: {
  NYSE: 'NYSE',
  NASDAQ: 'NASDAQ',
  AMEX: 'AMEX',
  OTC: 'OTC',
  LSE: 'LSE',
  TSX: 'TSX',
  OTHER: 'OTHER'
};

export type Exchange = (typeof Exchange)[keyof typeof Exchange]


export const Timeframe: {
  MIN_1: 'MIN_1',
  MIN_5: 'MIN_5',
  MIN_15: 'MIN_15',
  MIN_30: 'MIN_30',
  HOUR_1: 'HOUR_1',
  HOUR_4: 'HOUR_4',
  DAY_1: 'DAY_1',
  WEEK_1: 'WEEK_1',
  MONTH_1: 'MONTH_1'
};

export type Timeframe = (typeof Timeframe)[keyof typeof Timeframe]


export const IndicatorType: {
  SMA: 'SMA',
  EMA: 'EMA',
  RSI: 'RSI',
  MACD: 'MACD',
  BOLLINGER_BANDS: 'BOLLINGER_BANDS',
  ATR: 'ATR',
  STOCHASTIC: 'STOCHASTIC',
  ADX: 'ADX',
  OBV: 'OBV',
  VWAP: 'VWAP'
};

export type IndicatorType = (typeof IndicatorType)[keyof typeof IndicatorType]


export const AlertType: {
  PRICE_CROSS: 'PRICE_CROSS',
  INDICATOR_CROSS: 'INDICATOR_CROSS',
  SCAN_MATCH: 'SCAN_MATCH',
  PERCENT_CHANGE: 'PERCENT_CHANGE'
};

export type AlertType = (typeof AlertType)[keyof typeof AlertType]


export const AlertStatus: {
  ACTIVE: 'ACTIVE',
  TRIGGERED: 'TRIGGERED',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type AlertStatus = (typeof AlertStatus)[keyof typeof AlertStatus]


export const BacktestStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type BacktestStatus = (typeof BacktestStatus)[keyof typeof BacktestStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type Exchange = $Enums.Exchange

export const Exchange: typeof $Enums.Exchange

export type Timeframe = $Enums.Timeframe

export const Timeframe: typeof $Enums.Timeframe

export type IndicatorType = $Enums.IndicatorType

export const IndicatorType: typeof $Enums.IndicatorType

export type AlertType = $Enums.AlertType

export const AlertType: typeof $Enums.AlertType

export type AlertStatus = $Enums.AlertStatus

export const AlertStatus: typeof $Enums.AlertStatus

export type BacktestStatus = $Enums.BacktestStatus

export const BacktestStatus: typeof $Enums.BacktestStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.symbol`: Exposes CRUD operations for the **Symbol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Symbols
    * const symbols = await prisma.symbol.findMany()
    * ```
    */
  get symbol(): Prisma.SymbolDelegate<ExtArgs>;

  /**
   * `prisma.candle`: Exposes CRUD operations for the **Candle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Candles
    * const candles = await prisma.candle.findMany()
    * ```
    */
  get candle(): Prisma.CandleDelegate<ExtArgs>;

  /**
   * `prisma.indicatorCache`: Exposes CRUD operations for the **IndicatorCache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndicatorCaches
    * const indicatorCaches = await prisma.indicatorCache.findMany()
    * ```
    */
  get indicatorCache(): Prisma.IndicatorCacheDelegate<ExtArgs>;

  /**
   * `prisma.watchlist`: Exposes CRUD operations for the **Watchlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Watchlists
    * const watchlists = await prisma.watchlist.findMany()
    * ```
    */
  get watchlist(): Prisma.WatchlistDelegate<ExtArgs>;

  /**
   * `prisma.watchlistSymbol`: Exposes CRUD operations for the **WatchlistSymbol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchlistSymbols
    * const watchlistSymbols = await prisma.watchlistSymbol.findMany()
    * ```
    */
  get watchlistSymbol(): Prisma.WatchlistSymbolDelegate<ExtArgs>;

  /**
   * `prisma.savedScan`: Exposes CRUD operations for the **SavedScan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedScans
    * const savedScans = await prisma.savedScan.findMany()
    * ```
    */
  get savedScan(): Prisma.SavedScanDelegate<ExtArgs>;

  /**
   * `prisma.savedScanVersion`: Exposes CRUD operations for the **SavedScanVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedScanVersions
    * const savedScanVersions = await prisma.savedScanVersion.findMany()
    * ```
    */
  get savedScanVersion(): Prisma.SavedScanVersionDelegate<ExtArgs>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs>;

  /**
   * `prisma.backtest`: Exposes CRUD operations for the **Backtest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Backtests
    * const backtests = await prisma.backtest.findMany()
    * ```
    */
  get backtest(): Prisma.BacktestDelegate<ExtArgs>;

  /**
   * `prisma.financialMetric`: Exposes CRUD operations for the **FinancialMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialMetrics
    * const financialMetrics = await prisma.financialMetric.findMany()
    * ```
    */
  get financialMetric(): Prisma.FinancialMetricDelegate<ExtArgs>;

  /**
   * `prisma.systemStatus`: Exposes CRUD operations for the **SystemStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemStatuses
    * const systemStatuses = await prisma.systemStatus.findMany()
    * ```
    */
  get systemStatus(): Prisma.SystemStatusDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Symbol: 'Symbol',
    Candle: 'Candle',
    IndicatorCache: 'IndicatorCache',
    Watchlist: 'Watchlist',
    WatchlistSymbol: 'WatchlistSymbol',
    SavedScan: 'SavedScan',
    SavedScanVersion: 'SavedScanVersion',
    Alert: 'Alert',
    Backtest: 'Backtest',
    FinancialMetric: 'FinancialMetric',
    SystemStatus: 'SystemStatus'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "symbol" | "candle" | "indicatorCache" | "watchlist" | "watchlistSymbol" | "savedScan" | "savedScanVersion" | "alert" | "backtest" | "financialMetric" | "systemStatus"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Symbol: {
        payload: Prisma.$SymbolPayload<ExtArgs>
        fields: Prisma.SymbolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SymbolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SymbolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>
          }
          findFirst: {
            args: Prisma.SymbolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SymbolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>
          }
          findMany: {
            args: Prisma.SymbolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>[]
          }
          create: {
            args: Prisma.SymbolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>
          }
          createMany: {
            args: Prisma.SymbolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SymbolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>[]
          }
          delete: {
            args: Prisma.SymbolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>
          }
          update: {
            args: Prisma.SymbolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>
          }
          deleteMany: {
            args: Prisma.SymbolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SymbolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SymbolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>
          }
          aggregate: {
            args: Prisma.SymbolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSymbol>
          }
          groupBy: {
            args: Prisma.SymbolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SymbolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SymbolCountArgs<ExtArgs>
            result: $Utils.Optional<SymbolCountAggregateOutputType> | number
          }
        }
      }
      Candle: {
        payload: Prisma.$CandlePayload<ExtArgs>
        fields: Prisma.CandleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CandleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CandleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandlePayload>
          }
          findFirst: {
            args: Prisma.CandleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CandleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandlePayload>
          }
          findMany: {
            args: Prisma.CandleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandlePayload>[]
          }
          create: {
            args: Prisma.CandleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandlePayload>
          }
          createMany: {
            args: Prisma.CandleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CandleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandlePayload>[]
          }
          delete: {
            args: Prisma.CandleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandlePayload>
          }
          update: {
            args: Prisma.CandleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandlePayload>
          }
          deleteMany: {
            args: Prisma.CandleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CandleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CandleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandlePayload>
          }
          aggregate: {
            args: Prisma.CandleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCandle>
          }
          groupBy: {
            args: Prisma.CandleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CandleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CandleCountArgs<ExtArgs>
            result: $Utils.Optional<CandleCountAggregateOutputType> | number
          }
        }
      }
      IndicatorCache: {
        payload: Prisma.$IndicatorCachePayload<ExtArgs>
        fields: Prisma.IndicatorCacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicatorCacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicatorCacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCachePayload>
          }
          findFirst: {
            args: Prisma.IndicatorCacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicatorCacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCachePayload>
          }
          findMany: {
            args: Prisma.IndicatorCacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCachePayload>[]
          }
          create: {
            args: Prisma.IndicatorCacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCachePayload>
          }
          createMany: {
            args: Prisma.IndicatorCacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicatorCacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCachePayload>[]
          }
          delete: {
            args: Prisma.IndicatorCacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCachePayload>
          }
          update: {
            args: Prisma.IndicatorCacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCachePayload>
          }
          deleteMany: {
            args: Prisma.IndicatorCacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicatorCacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IndicatorCacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorCachePayload>
          }
          aggregate: {
            args: Prisma.IndicatorCacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicatorCache>
          }
          groupBy: {
            args: Prisma.IndicatorCacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicatorCacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicatorCacheCountArgs<ExtArgs>
            result: $Utils.Optional<IndicatorCacheCountAggregateOutputType> | number
          }
        }
      }
      Watchlist: {
        payload: Prisma.$WatchlistPayload<ExtArgs>
        fields: Prisma.WatchlistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WatchlistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchlistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistPayload>
          }
          findFirst: {
            args: Prisma.WatchlistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchlistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistPayload>
          }
          findMany: {
            args: Prisma.WatchlistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistPayload>[]
          }
          create: {
            args: Prisma.WatchlistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistPayload>
          }
          createMany: {
            args: Prisma.WatchlistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WatchlistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistPayload>[]
          }
          delete: {
            args: Prisma.WatchlistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistPayload>
          }
          update: {
            args: Prisma.WatchlistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistPayload>
          }
          deleteMany: {
            args: Prisma.WatchlistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WatchlistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WatchlistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistPayload>
          }
          aggregate: {
            args: Prisma.WatchlistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWatchlist>
          }
          groupBy: {
            args: Prisma.WatchlistGroupByArgs<ExtArgs>
            result: $Utils.Optional<WatchlistGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchlistCountArgs<ExtArgs>
            result: $Utils.Optional<WatchlistCountAggregateOutputType> | number
          }
        }
      }
      WatchlistSymbol: {
        payload: Prisma.$WatchlistSymbolPayload<ExtArgs>
        fields: Prisma.WatchlistSymbolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WatchlistSymbolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistSymbolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchlistSymbolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistSymbolPayload>
          }
          findFirst: {
            args: Prisma.WatchlistSymbolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistSymbolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchlistSymbolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistSymbolPayload>
          }
          findMany: {
            args: Prisma.WatchlistSymbolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistSymbolPayload>[]
          }
          create: {
            args: Prisma.WatchlistSymbolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistSymbolPayload>
          }
          createMany: {
            args: Prisma.WatchlistSymbolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WatchlistSymbolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistSymbolPayload>[]
          }
          delete: {
            args: Prisma.WatchlistSymbolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistSymbolPayload>
          }
          update: {
            args: Prisma.WatchlistSymbolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistSymbolPayload>
          }
          deleteMany: {
            args: Prisma.WatchlistSymbolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WatchlistSymbolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WatchlistSymbolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchlistSymbolPayload>
          }
          aggregate: {
            args: Prisma.WatchlistSymbolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWatchlistSymbol>
          }
          groupBy: {
            args: Prisma.WatchlistSymbolGroupByArgs<ExtArgs>
            result: $Utils.Optional<WatchlistSymbolGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchlistSymbolCountArgs<ExtArgs>
            result: $Utils.Optional<WatchlistSymbolCountAggregateOutputType> | number
          }
        }
      }
      SavedScan: {
        payload: Prisma.$SavedScanPayload<ExtArgs>
        fields: Prisma.SavedScanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedScanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedScanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanPayload>
          }
          findFirst: {
            args: Prisma.SavedScanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedScanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanPayload>
          }
          findMany: {
            args: Prisma.SavedScanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanPayload>[]
          }
          create: {
            args: Prisma.SavedScanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanPayload>
          }
          createMany: {
            args: Prisma.SavedScanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedScanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanPayload>[]
          }
          delete: {
            args: Prisma.SavedScanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanPayload>
          }
          update: {
            args: Prisma.SavedScanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanPayload>
          }
          deleteMany: {
            args: Prisma.SavedScanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedScanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SavedScanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanPayload>
          }
          aggregate: {
            args: Prisma.SavedScanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedScan>
          }
          groupBy: {
            args: Prisma.SavedScanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedScanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedScanCountArgs<ExtArgs>
            result: $Utils.Optional<SavedScanCountAggregateOutputType> | number
          }
        }
      }
      SavedScanVersion: {
        payload: Prisma.$SavedScanVersionPayload<ExtArgs>
        fields: Prisma.SavedScanVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedScanVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedScanVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanVersionPayload>
          }
          findFirst: {
            args: Prisma.SavedScanVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedScanVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanVersionPayload>
          }
          findMany: {
            args: Prisma.SavedScanVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanVersionPayload>[]
          }
          create: {
            args: Prisma.SavedScanVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanVersionPayload>
          }
          createMany: {
            args: Prisma.SavedScanVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedScanVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanVersionPayload>[]
          }
          delete: {
            args: Prisma.SavedScanVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanVersionPayload>
          }
          update: {
            args: Prisma.SavedScanVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanVersionPayload>
          }
          deleteMany: {
            args: Prisma.SavedScanVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedScanVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SavedScanVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedScanVersionPayload>
          }
          aggregate: {
            args: Prisma.SavedScanVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedScanVersion>
          }
          groupBy: {
            args: Prisma.SavedScanVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedScanVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedScanVersionCountArgs<ExtArgs>
            result: $Utils.Optional<SavedScanVersionCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      Backtest: {
        payload: Prisma.$BacktestPayload<ExtArgs>
        fields: Prisma.BacktestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BacktestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BacktestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BacktestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BacktestPayload>
          }
          findFirst: {
            args: Prisma.BacktestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BacktestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BacktestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BacktestPayload>
          }
          findMany: {
            args: Prisma.BacktestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BacktestPayload>[]
          }
          create: {
            args: Prisma.BacktestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BacktestPayload>
          }
          createMany: {
            args: Prisma.BacktestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BacktestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BacktestPayload>[]
          }
          delete: {
            args: Prisma.BacktestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BacktestPayload>
          }
          update: {
            args: Prisma.BacktestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BacktestPayload>
          }
          deleteMany: {
            args: Prisma.BacktestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BacktestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BacktestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BacktestPayload>
          }
          aggregate: {
            args: Prisma.BacktestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBacktest>
          }
          groupBy: {
            args: Prisma.BacktestGroupByArgs<ExtArgs>
            result: $Utils.Optional<BacktestGroupByOutputType>[]
          }
          count: {
            args: Prisma.BacktestCountArgs<ExtArgs>
            result: $Utils.Optional<BacktestCountAggregateOutputType> | number
          }
        }
      }
      FinancialMetric: {
        payload: Prisma.$FinancialMetricPayload<ExtArgs>
        fields: Prisma.FinancialMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialMetricPayload>
          }
          findFirst: {
            args: Prisma.FinancialMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialMetricPayload>
          }
          findMany: {
            args: Prisma.FinancialMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialMetricPayload>[]
          }
          create: {
            args: Prisma.FinancialMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialMetricPayload>
          }
          createMany: {
            args: Prisma.FinancialMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialMetricPayload>[]
          }
          delete: {
            args: Prisma.FinancialMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialMetricPayload>
          }
          update: {
            args: Prisma.FinancialMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialMetricPayload>
          }
          deleteMany: {
            args: Prisma.FinancialMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FinancialMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialMetricPayload>
          }
          aggregate: {
            args: Prisma.FinancialMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialMetric>
          }
          groupBy: {
            args: Prisma.FinancialMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialMetricCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialMetricCountAggregateOutputType> | number
          }
        }
      }
      SystemStatus: {
        payload: Prisma.$SystemStatusPayload<ExtArgs>
        fields: Prisma.SystemStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          findFirst: {
            args: Prisma.SystemStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          findMany: {
            args: Prisma.SystemStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>[]
          }
          create: {
            args: Prisma.SystemStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          createMany: {
            args: Prisma.SystemStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>[]
          }
          delete: {
            args: Prisma.SystemStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          update: {
            args: Prisma.SystemStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          deleteMany: {
            args: Prisma.SystemStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          aggregate: {
            args: Prisma.SystemStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemStatus>
          }
          groupBy: {
            args: Prisma.SystemStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemStatusCountArgs<ExtArgs>
            result: $Utils.Optional<SystemStatusCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    watchlists: number
    savedScans: number
    alerts: number
    backtests: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlists?: boolean | UserCountOutputTypeCountWatchlistsArgs
    savedScans?: boolean | UserCountOutputTypeCountSavedScansArgs
    alerts?: boolean | UserCountOutputTypeCountAlertsArgs
    backtests?: boolean | UserCountOutputTypeCountBacktestsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWatchlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedScansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedScanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBacktestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BacktestWhereInput
  }


  /**
   * Count Type SymbolCountOutputType
   */

  export type SymbolCountOutputType = {
    candles: number
    indicators: number
    watchlistSymbols: number
    financialMetrics: number
  }

  export type SymbolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candles?: boolean | SymbolCountOutputTypeCountCandlesArgs
    indicators?: boolean | SymbolCountOutputTypeCountIndicatorsArgs
    watchlistSymbols?: boolean | SymbolCountOutputTypeCountWatchlistSymbolsArgs
    financialMetrics?: boolean | SymbolCountOutputTypeCountFinancialMetricsArgs
  }

  // Custom InputTypes
  /**
   * SymbolCountOutputType without action
   */
  export type SymbolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymbolCountOutputType
     */
    select?: SymbolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SymbolCountOutputType without action
   */
  export type SymbolCountOutputTypeCountCandlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandleWhereInput
  }

  /**
   * SymbolCountOutputType without action
   */
  export type SymbolCountOutputTypeCountIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorCacheWhereInput
  }

  /**
   * SymbolCountOutputType without action
   */
  export type SymbolCountOutputTypeCountWatchlistSymbolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistSymbolWhereInput
  }

  /**
   * SymbolCountOutputType without action
   */
  export type SymbolCountOutputTypeCountFinancialMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialMetricWhereInput
  }


  /**
   * Count Type WatchlistCountOutputType
   */

  export type WatchlistCountOutputType = {
    symbols: number
  }

  export type WatchlistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    symbols?: boolean | WatchlistCountOutputTypeCountSymbolsArgs
  }

  // Custom InputTypes
  /**
   * WatchlistCountOutputType without action
   */
  export type WatchlistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistCountOutputType
     */
    select?: WatchlistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WatchlistCountOutputType without action
   */
  export type WatchlistCountOutputTypeCountSymbolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistSymbolWhereInput
  }


  /**
   * Count Type SavedScanCountOutputType
   */

  export type SavedScanCountOutputType = {
    backtests: number
    versions: number
  }

  export type SavedScanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    backtests?: boolean | SavedScanCountOutputTypeCountBacktestsArgs
    versions?: boolean | SavedScanCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * SavedScanCountOutputType without action
   */
  export type SavedScanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScanCountOutputType
     */
    select?: SavedScanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SavedScanCountOutputType without action
   */
  export type SavedScanCountOutputTypeCountBacktestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BacktestWhereInput
  }

  /**
   * SavedScanCountOutputType without action
   */
  export type SavedScanCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedScanVersionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    apiCallsToday: number | null
  }

  export type UserSumAggregateOutputType = {
    apiCallsToday: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    googleId: string | null
    picture: string | null
    apiCallsToday: number | null
    lastApiReset: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    googleId: string | null
    picture: string | null
    apiCallsToday: number | null
    lastApiReset: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    passwordHash: number
    role: number
    status: number
    googleId: number
    picture: number
    apiCallsToday: number
    lastApiReset: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    apiCallsToday?: true
  }

  export type UserSumAggregateInputType = {
    apiCallsToday?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    role?: true
    status?: true
    googleId?: true
    picture?: true
    apiCallsToday?: true
    lastApiReset?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    role?: true
    status?: true
    googleId?: true
    picture?: true
    apiCallsToday?: true
    lastApiReset?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    role?: true
    status?: true
    googleId?: true
    picture?: true
    apiCallsToday?: true
    lastApiReset?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    passwordHash: string | null
    role: $Enums.UserRole
    status: $Enums.UserStatus
    googleId: string | null
    picture: string | null
    apiCallsToday: number
    lastApiReset: Date
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    googleId?: boolean
    picture?: boolean
    apiCallsToday?: boolean
    lastApiReset?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    watchlists?: boolean | User$watchlistsArgs<ExtArgs>
    savedScans?: boolean | User$savedScansArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    backtests?: boolean | User$backtestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    googleId?: boolean
    picture?: boolean
    apiCallsToday?: boolean
    lastApiReset?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    role?: boolean
    status?: boolean
    googleId?: boolean
    picture?: boolean
    apiCallsToday?: boolean
    lastApiReset?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlists?: boolean | User$watchlistsArgs<ExtArgs>
    savedScans?: boolean | User$savedScansArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    backtests?: boolean | User$backtestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      watchlists: Prisma.$WatchlistPayload<ExtArgs>[]
      savedScans: Prisma.$SavedScanPayload<ExtArgs>[]
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      backtests: Prisma.$BacktestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      passwordHash: string | null
      role: $Enums.UserRole
      status: $Enums.UserStatus
      googleId: string | null
      picture: string | null
      apiCallsToday: number
      lastApiReset: Date
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    watchlists<T extends User$watchlistsArgs<ExtArgs> = {}>(args?: Subset<T, User$watchlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "findMany"> | Null>
    savedScans<T extends User$savedScansArgs<ExtArgs> = {}>(args?: Subset<T, User$savedScansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedScanPayload<ExtArgs>, T, "findMany"> | Null>
    alerts<T extends User$alertsArgs<ExtArgs> = {}>(args?: Subset<T, User$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany"> | Null>
    backtests<T extends User$backtestsArgs<ExtArgs> = {}>(args?: Subset<T, User$backtestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BacktestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly picture: FieldRef<"User", 'String'>
    readonly apiCallsToday: FieldRef<"User", 'Int'>
    readonly lastApiReset: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.watchlists
   */
  export type User$watchlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Watchlist
     */
    select?: WatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistInclude<ExtArgs> | null
    where?: WatchlistWhereInput
    orderBy?: WatchlistOrderByWithRelationInput | WatchlistOrderByWithRelationInput[]
    cursor?: WatchlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchlistScalarFieldEnum | WatchlistScalarFieldEnum[]
  }

  /**
   * User.savedScans
   */
  export type User$savedScansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScan
     */
    select?: SavedScanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanInclude<ExtArgs> | null
    where?: SavedScanWhereInput
    orderBy?: SavedScanOrderByWithRelationInput | SavedScanOrderByWithRelationInput[]
    cursor?: SavedScanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedScanScalarFieldEnum | SavedScanScalarFieldEnum[]
  }

  /**
   * User.alerts
   */
  export type User$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * User.backtests
   */
  export type User$backtestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backtest
     */
    select?: BacktestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BacktestInclude<ExtArgs> | null
    where?: BacktestWhereInput
    orderBy?: BacktestOrderByWithRelationInput | BacktestOrderByWithRelationInput[]
    cursor?: BacktestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BacktestScalarFieldEnum | BacktestScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Symbol
   */

  export type AggregateSymbol = {
    _count: SymbolCountAggregateOutputType | null
    _avg: SymbolAvgAggregateOutputType | null
    _sum: SymbolSumAggregateOutputType | null
    _min: SymbolMinAggregateOutputType | null
    _max: SymbolMaxAggregateOutputType | null
  }

  export type SymbolAvgAggregateOutputType = {
    marketCap: number | null
  }

  export type SymbolSumAggregateOutputType = {
    marketCap: bigint | null
  }

  export type SymbolMinAggregateOutputType = {
    id: string | null
    ticker: string | null
    name: string | null
    exchange: $Enums.Exchange | null
    currency: string | null
    sector: string | null
    industry: string | null
    marketCap: bigint | null
    description: string | null
    website: string | null
    isActive: boolean | null
    ipo: Date | null
    delistDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastSyncedAt: Date | null
  }

  export type SymbolMaxAggregateOutputType = {
    id: string | null
    ticker: string | null
    name: string | null
    exchange: $Enums.Exchange | null
    currency: string | null
    sector: string | null
    industry: string | null
    marketCap: bigint | null
    description: string | null
    website: string | null
    isActive: boolean | null
    ipo: Date | null
    delistDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastSyncedAt: Date | null
  }

  export type SymbolCountAggregateOutputType = {
    id: number
    ticker: number
    name: number
    exchange: number
    currency: number
    sector: number
    industry: number
    marketCap: number
    description: number
    website: number
    isActive: number
    ipo: number
    delistDate: number
    createdAt: number
    updatedAt: number
    lastSyncedAt: number
    _all: number
  }


  export type SymbolAvgAggregateInputType = {
    marketCap?: true
  }

  export type SymbolSumAggregateInputType = {
    marketCap?: true
  }

  export type SymbolMinAggregateInputType = {
    id?: true
    ticker?: true
    name?: true
    exchange?: true
    currency?: true
    sector?: true
    industry?: true
    marketCap?: true
    description?: true
    website?: true
    isActive?: true
    ipo?: true
    delistDate?: true
    createdAt?: true
    updatedAt?: true
    lastSyncedAt?: true
  }

  export type SymbolMaxAggregateInputType = {
    id?: true
    ticker?: true
    name?: true
    exchange?: true
    currency?: true
    sector?: true
    industry?: true
    marketCap?: true
    description?: true
    website?: true
    isActive?: true
    ipo?: true
    delistDate?: true
    createdAt?: true
    updatedAt?: true
    lastSyncedAt?: true
  }

  export type SymbolCountAggregateInputType = {
    id?: true
    ticker?: true
    name?: true
    exchange?: true
    currency?: true
    sector?: true
    industry?: true
    marketCap?: true
    description?: true
    website?: true
    isActive?: true
    ipo?: true
    delistDate?: true
    createdAt?: true
    updatedAt?: true
    lastSyncedAt?: true
    _all?: true
  }

  export type SymbolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Symbol to aggregate.
     */
    where?: SymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Symbols to fetch.
     */
    orderBy?: SymbolOrderByWithRelationInput | SymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Symbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Symbols
    **/
    _count?: true | SymbolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SymbolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SymbolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SymbolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SymbolMaxAggregateInputType
  }

  export type GetSymbolAggregateType<T extends SymbolAggregateArgs> = {
        [P in keyof T & keyof AggregateSymbol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSymbol[P]>
      : GetScalarType<T[P], AggregateSymbol[P]>
  }




  export type SymbolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SymbolWhereInput
    orderBy?: SymbolOrderByWithAggregationInput | SymbolOrderByWithAggregationInput[]
    by: SymbolScalarFieldEnum[] | SymbolScalarFieldEnum
    having?: SymbolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SymbolCountAggregateInputType | true
    _avg?: SymbolAvgAggregateInputType
    _sum?: SymbolSumAggregateInputType
    _min?: SymbolMinAggregateInputType
    _max?: SymbolMaxAggregateInputType
  }

  export type SymbolGroupByOutputType = {
    id: string
    ticker: string
    name: string
    exchange: $Enums.Exchange
    currency: string
    sector: string | null
    industry: string | null
    marketCap: bigint | null
    description: string | null
    website: string | null
    isActive: boolean
    ipo: Date | null
    delistDate: Date | null
    createdAt: Date
    updatedAt: Date
    lastSyncedAt: Date | null
    _count: SymbolCountAggregateOutputType | null
    _avg: SymbolAvgAggregateOutputType | null
    _sum: SymbolSumAggregateOutputType | null
    _min: SymbolMinAggregateOutputType | null
    _max: SymbolMaxAggregateOutputType | null
  }

  type GetSymbolGroupByPayload<T extends SymbolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SymbolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SymbolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SymbolGroupByOutputType[P]>
            : GetScalarType<T[P], SymbolGroupByOutputType[P]>
        }
      >
    >


  export type SymbolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticker?: boolean
    name?: boolean
    exchange?: boolean
    currency?: boolean
    sector?: boolean
    industry?: boolean
    marketCap?: boolean
    description?: boolean
    website?: boolean
    isActive?: boolean
    ipo?: boolean
    delistDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncedAt?: boolean
    candles?: boolean | Symbol$candlesArgs<ExtArgs>
    indicators?: boolean | Symbol$indicatorsArgs<ExtArgs>
    watchlistSymbols?: boolean | Symbol$watchlistSymbolsArgs<ExtArgs>
    financialMetrics?: boolean | Symbol$financialMetricsArgs<ExtArgs>
    _count?: boolean | SymbolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["symbol"]>

  export type SymbolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticker?: boolean
    name?: boolean
    exchange?: boolean
    currency?: boolean
    sector?: boolean
    industry?: boolean
    marketCap?: boolean
    description?: boolean
    website?: boolean
    isActive?: boolean
    ipo?: boolean
    delistDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncedAt?: boolean
  }, ExtArgs["result"]["symbol"]>

  export type SymbolSelectScalar = {
    id?: boolean
    ticker?: boolean
    name?: boolean
    exchange?: boolean
    currency?: boolean
    sector?: boolean
    industry?: boolean
    marketCap?: boolean
    description?: boolean
    website?: boolean
    isActive?: boolean
    ipo?: boolean
    delistDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncedAt?: boolean
  }

  export type SymbolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candles?: boolean | Symbol$candlesArgs<ExtArgs>
    indicators?: boolean | Symbol$indicatorsArgs<ExtArgs>
    watchlistSymbols?: boolean | Symbol$watchlistSymbolsArgs<ExtArgs>
    financialMetrics?: boolean | Symbol$financialMetricsArgs<ExtArgs>
    _count?: boolean | SymbolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SymbolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SymbolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Symbol"
    objects: {
      candles: Prisma.$CandlePayload<ExtArgs>[]
      indicators: Prisma.$IndicatorCachePayload<ExtArgs>[]
      watchlistSymbols: Prisma.$WatchlistSymbolPayload<ExtArgs>[]
      financialMetrics: Prisma.$FinancialMetricPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticker: string
      name: string
      exchange: $Enums.Exchange
      currency: string
      sector: string | null
      industry: string | null
      marketCap: bigint | null
      description: string | null
      website: string | null
      isActive: boolean
      ipo: Date | null
      delistDate: Date | null
      createdAt: Date
      updatedAt: Date
      lastSyncedAt: Date | null
    }, ExtArgs["result"]["symbol"]>
    composites: {}
  }

  type SymbolGetPayload<S extends boolean | null | undefined | SymbolDefaultArgs> = $Result.GetResult<Prisma.$SymbolPayload, S>

  type SymbolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SymbolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SymbolCountAggregateInputType | true
    }

  export interface SymbolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Symbol'], meta: { name: 'Symbol' } }
    /**
     * Find zero or one Symbol that matches the filter.
     * @param {SymbolFindUniqueArgs} args - Arguments to find a Symbol
     * @example
     * // Get one Symbol
     * const symbol = await prisma.symbol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SymbolFindUniqueArgs>(args: SelectSubset<T, SymbolFindUniqueArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Symbol that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SymbolFindUniqueOrThrowArgs} args - Arguments to find a Symbol
     * @example
     * // Get one Symbol
     * const symbol = await prisma.symbol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SymbolFindUniqueOrThrowArgs>(args: SelectSubset<T, SymbolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Symbol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolFindFirstArgs} args - Arguments to find a Symbol
     * @example
     * // Get one Symbol
     * const symbol = await prisma.symbol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SymbolFindFirstArgs>(args?: SelectSubset<T, SymbolFindFirstArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Symbol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolFindFirstOrThrowArgs} args - Arguments to find a Symbol
     * @example
     * // Get one Symbol
     * const symbol = await prisma.symbol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SymbolFindFirstOrThrowArgs>(args?: SelectSubset<T, SymbolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Symbols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Symbols
     * const symbols = await prisma.symbol.findMany()
     * 
     * // Get first 10 Symbols
     * const symbols = await prisma.symbol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const symbolWithIdOnly = await prisma.symbol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SymbolFindManyArgs>(args?: SelectSubset<T, SymbolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Symbol.
     * @param {SymbolCreateArgs} args - Arguments to create a Symbol.
     * @example
     * // Create one Symbol
     * const Symbol = await prisma.symbol.create({
     *   data: {
     *     // ... data to create a Symbol
     *   }
     * })
     * 
     */
    create<T extends SymbolCreateArgs>(args: SelectSubset<T, SymbolCreateArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Symbols.
     * @param {SymbolCreateManyArgs} args - Arguments to create many Symbols.
     * @example
     * // Create many Symbols
     * const symbol = await prisma.symbol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SymbolCreateManyArgs>(args?: SelectSubset<T, SymbolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Symbols and returns the data saved in the database.
     * @param {SymbolCreateManyAndReturnArgs} args - Arguments to create many Symbols.
     * @example
     * // Create many Symbols
     * const symbol = await prisma.symbol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Symbols and only return the `id`
     * const symbolWithIdOnly = await prisma.symbol.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SymbolCreateManyAndReturnArgs>(args?: SelectSubset<T, SymbolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Symbol.
     * @param {SymbolDeleteArgs} args - Arguments to delete one Symbol.
     * @example
     * // Delete one Symbol
     * const Symbol = await prisma.symbol.delete({
     *   where: {
     *     // ... filter to delete one Symbol
     *   }
     * })
     * 
     */
    delete<T extends SymbolDeleteArgs>(args: SelectSubset<T, SymbolDeleteArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Symbol.
     * @param {SymbolUpdateArgs} args - Arguments to update one Symbol.
     * @example
     * // Update one Symbol
     * const symbol = await prisma.symbol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SymbolUpdateArgs>(args: SelectSubset<T, SymbolUpdateArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Symbols.
     * @param {SymbolDeleteManyArgs} args - Arguments to filter Symbols to delete.
     * @example
     * // Delete a few Symbols
     * const { count } = await prisma.symbol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SymbolDeleteManyArgs>(args?: SelectSubset<T, SymbolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Symbols
     * const symbol = await prisma.symbol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SymbolUpdateManyArgs>(args: SelectSubset<T, SymbolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Symbol.
     * @param {SymbolUpsertArgs} args - Arguments to update or create a Symbol.
     * @example
     * // Update or create a Symbol
     * const symbol = await prisma.symbol.upsert({
     *   create: {
     *     // ... data to create a Symbol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Symbol we want to update
     *   }
     * })
     */
    upsert<T extends SymbolUpsertArgs>(args: SelectSubset<T, SymbolUpsertArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolCountArgs} args - Arguments to filter Symbols to count.
     * @example
     * // Count the number of Symbols
     * const count = await prisma.symbol.count({
     *   where: {
     *     // ... the filter for the Symbols we want to count
     *   }
     * })
    **/
    count<T extends SymbolCountArgs>(
      args?: Subset<T, SymbolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SymbolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Symbol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SymbolAggregateArgs>(args: Subset<T, SymbolAggregateArgs>): Prisma.PrismaPromise<GetSymbolAggregateType<T>>

    /**
     * Group by Symbol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SymbolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SymbolGroupByArgs['orderBy'] }
        : { orderBy?: SymbolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SymbolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSymbolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Symbol model
   */
  readonly fields: SymbolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Symbol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SymbolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    candles<T extends Symbol$candlesArgs<ExtArgs> = {}>(args?: Subset<T, Symbol$candlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandlePayload<ExtArgs>, T, "findMany"> | Null>
    indicators<T extends Symbol$indicatorsArgs<ExtArgs> = {}>(args?: Subset<T, Symbol$indicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorCachePayload<ExtArgs>, T, "findMany"> | Null>
    watchlistSymbols<T extends Symbol$watchlistSymbolsArgs<ExtArgs> = {}>(args?: Subset<T, Symbol$watchlistSymbolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistSymbolPayload<ExtArgs>, T, "findMany"> | Null>
    financialMetrics<T extends Symbol$financialMetricsArgs<ExtArgs> = {}>(args?: Subset<T, Symbol$financialMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialMetricPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Symbol model
   */ 
  interface SymbolFieldRefs {
    readonly id: FieldRef<"Symbol", 'String'>
    readonly ticker: FieldRef<"Symbol", 'String'>
    readonly name: FieldRef<"Symbol", 'String'>
    readonly exchange: FieldRef<"Symbol", 'Exchange'>
    readonly currency: FieldRef<"Symbol", 'String'>
    readonly sector: FieldRef<"Symbol", 'String'>
    readonly industry: FieldRef<"Symbol", 'String'>
    readonly marketCap: FieldRef<"Symbol", 'BigInt'>
    readonly description: FieldRef<"Symbol", 'String'>
    readonly website: FieldRef<"Symbol", 'String'>
    readonly isActive: FieldRef<"Symbol", 'Boolean'>
    readonly ipo: FieldRef<"Symbol", 'DateTime'>
    readonly delistDate: FieldRef<"Symbol", 'DateTime'>
    readonly createdAt: FieldRef<"Symbol", 'DateTime'>
    readonly updatedAt: FieldRef<"Symbol", 'DateTime'>
    readonly lastSyncedAt: FieldRef<"Symbol", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Symbol findUnique
   */
  export type SymbolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymbolInclude<ExtArgs> | null
    /**
     * Filter, which Symbol to fetch.
     */
    where: SymbolWhereUniqueInput
  }

  /**
   * Symbol findUniqueOrThrow
   */
  export type SymbolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymbolInclude<ExtArgs> | null
    /**
     * Filter, which Symbol to fetch.
     */
    where: SymbolWhereUniqueInput
  }

  /**
   * Symbol findFirst
   */
  export type SymbolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymbolInclude<ExtArgs> | null
    /**
     * Filter, which Symbol to fetch.
     */
    where?: SymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Symbols to fetch.
     */
    orderBy?: SymbolOrderByWithRelationInput | SymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Symbols.
     */
    cursor?: SymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Symbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Symbols.
     */
    distinct?: SymbolScalarFieldEnum | SymbolScalarFieldEnum[]
  }

  /**
   * Symbol findFirstOrThrow
   */
  export type SymbolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymbolInclude<ExtArgs> | null
    /**
     * Filter, which Symbol to fetch.
     */
    where?: SymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Symbols to fetch.
     */
    orderBy?: SymbolOrderByWithRelationInput | SymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Symbols.
     */
    cursor?: SymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Symbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Symbols.
     */
    distinct?: SymbolScalarFieldEnum | SymbolScalarFieldEnum[]
  }

  /**
   * Symbol findMany
   */
  export type SymbolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymbolInclude<ExtArgs> | null
    /**
     * Filter, which Symbols to fetch.
     */
    where?: SymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Symbols to fetch.
     */
    orderBy?: SymbolOrderByWithRelationInput | SymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Symbols.
     */
    cursor?: SymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Symbols.
     */
    skip?: number
    distinct?: SymbolScalarFieldEnum | SymbolScalarFieldEnum[]
  }

  /**
   * Symbol create
   */
  export type SymbolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymbolInclude<ExtArgs> | null
    /**
     * The data needed to create a Symbol.
     */
    data: XOR<SymbolCreateInput, SymbolUncheckedCreateInput>
  }

  /**
   * Symbol createMany
   */
  export type SymbolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Symbols.
     */
    data: SymbolCreateManyInput | SymbolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Symbol createManyAndReturn
   */
  export type SymbolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Symbols.
     */
    data: SymbolCreateManyInput | SymbolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Symbol update
   */
  export type SymbolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymbolInclude<ExtArgs> | null
    /**
     * The data needed to update a Symbol.
     */
    data: XOR<SymbolUpdateInput, SymbolUncheckedUpdateInput>
    /**
     * Choose, which Symbol to update.
     */
    where: SymbolWhereUniqueInput
  }

  /**
   * Symbol updateMany
   */
  export type SymbolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Symbols.
     */
    data: XOR<SymbolUpdateManyMutationInput, SymbolUncheckedUpdateManyInput>
    /**
     * Filter which Symbols to update
     */
    where?: SymbolWhereInput
  }

  /**
   * Symbol upsert
   */
  export type SymbolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymbolInclude<ExtArgs> | null
    /**
     * The filter to search for the Symbol to update in case it exists.
     */
    where: SymbolWhereUniqueInput
    /**
     * In case the Symbol found by the `where` argument doesn't exist, create a new Symbol with this data.
     */
    create: XOR<SymbolCreateInput, SymbolUncheckedCreateInput>
    /**
     * In case the Symbol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SymbolUpdateInput, SymbolUncheckedUpdateInput>
  }

  /**
   * Symbol delete
   */
  export type SymbolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymbolInclude<ExtArgs> | null
    /**
     * Filter which Symbol to delete.
     */
    where: SymbolWhereUniqueInput
  }

  /**
   * Symbol deleteMany
   */
  export type SymbolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Symbols to delete
     */
    where?: SymbolWhereInput
  }

  /**
   * Symbol.candles
   */
  export type Symbol$candlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candle
     */
    select?: CandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandleInclude<ExtArgs> | null
    where?: CandleWhereInput
    orderBy?: CandleOrderByWithRelationInput | CandleOrderByWithRelationInput[]
    cursor?: CandleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandleScalarFieldEnum | CandleScalarFieldEnum[]
  }

  /**
   * Symbol.indicators
   */
  export type Symbol$indicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCache
     */
    select?: IndicatorCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCacheInclude<ExtArgs> | null
    where?: IndicatorCacheWhereInput
    orderBy?: IndicatorCacheOrderByWithRelationInput | IndicatorCacheOrderByWithRelationInput[]
    cursor?: IndicatorCacheWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicatorCacheScalarFieldEnum | IndicatorCacheScalarFieldEnum[]
  }

  /**
   * Symbol.watchlistSymbols
   */
  export type Symbol$watchlistSymbolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistSymbol
     */
    select?: WatchlistSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistSymbolInclude<ExtArgs> | null
    where?: WatchlistSymbolWhereInput
    orderBy?: WatchlistSymbolOrderByWithRelationInput | WatchlistSymbolOrderByWithRelationInput[]
    cursor?: WatchlistSymbolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchlistSymbolScalarFieldEnum | WatchlistSymbolScalarFieldEnum[]
  }

  /**
   * Symbol.financialMetrics
   */
  export type Symbol$financialMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialMetric
     */
    select?: FinancialMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialMetricInclude<ExtArgs> | null
    where?: FinancialMetricWhereInput
    orderBy?: FinancialMetricOrderByWithRelationInput | FinancialMetricOrderByWithRelationInput[]
    cursor?: FinancialMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialMetricScalarFieldEnum | FinancialMetricScalarFieldEnum[]
  }

  /**
   * Symbol without action
   */
  export type SymbolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymbolInclude<ExtArgs> | null
  }


  /**
   * Model Candle
   */

  export type AggregateCandle = {
    _count: CandleCountAggregateOutputType | null
    _avg: CandleAvgAggregateOutputType | null
    _sum: CandleSumAggregateOutputType | null
    _min: CandleMinAggregateOutputType | null
    _max: CandleMaxAggregateOutputType | null
  }

  export type CandleAvgAggregateOutputType = {
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    volume: number | null
  }

  export type CandleSumAggregateOutputType = {
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    volume: bigint | null
  }

  export type CandleMinAggregateOutputType = {
    id: string | null
    symbolId: string | null
    timeframe: $Enums.Timeframe | null
    timestamp: Date | null
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    volume: bigint | null
    createdAt: Date | null
  }

  export type CandleMaxAggregateOutputType = {
    id: string | null
    symbolId: string | null
    timeframe: $Enums.Timeframe | null
    timestamp: Date | null
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    volume: bigint | null
    createdAt: Date | null
  }

  export type CandleCountAggregateOutputType = {
    id: number
    symbolId: number
    timeframe: number
    timestamp: number
    open: number
    high: number
    low: number
    close: number
    volume: number
    createdAt: number
    _all: number
  }


  export type CandleAvgAggregateInputType = {
    open?: true
    high?: true
    low?: true
    close?: true
    volume?: true
  }

  export type CandleSumAggregateInputType = {
    open?: true
    high?: true
    low?: true
    close?: true
    volume?: true
  }

  export type CandleMinAggregateInputType = {
    id?: true
    symbolId?: true
    timeframe?: true
    timestamp?: true
    open?: true
    high?: true
    low?: true
    close?: true
    volume?: true
    createdAt?: true
  }

  export type CandleMaxAggregateInputType = {
    id?: true
    symbolId?: true
    timeframe?: true
    timestamp?: true
    open?: true
    high?: true
    low?: true
    close?: true
    volume?: true
    createdAt?: true
  }

  export type CandleCountAggregateInputType = {
    id?: true
    symbolId?: true
    timeframe?: true
    timestamp?: true
    open?: true
    high?: true
    low?: true
    close?: true
    volume?: true
    createdAt?: true
    _all?: true
  }

  export type CandleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Candle to aggregate.
     */
    where?: CandleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candles to fetch.
     */
    orderBy?: CandleOrderByWithRelationInput | CandleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CandleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Candles
    **/
    _count?: true | CandleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CandleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CandleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CandleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CandleMaxAggregateInputType
  }

  export type GetCandleAggregateType<T extends CandleAggregateArgs> = {
        [P in keyof T & keyof AggregateCandle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCandle[P]>
      : GetScalarType<T[P], AggregateCandle[P]>
  }




  export type CandleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandleWhereInput
    orderBy?: CandleOrderByWithAggregationInput | CandleOrderByWithAggregationInput[]
    by: CandleScalarFieldEnum[] | CandleScalarFieldEnum
    having?: CandleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CandleCountAggregateInputType | true
    _avg?: CandleAvgAggregateInputType
    _sum?: CandleSumAggregateInputType
    _min?: CandleMinAggregateInputType
    _max?: CandleMaxAggregateInputType
  }

  export type CandleGroupByOutputType = {
    id: string
    symbolId: string
    timeframe: $Enums.Timeframe
    timestamp: Date
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: bigint
    createdAt: Date
    _count: CandleCountAggregateOutputType | null
    _avg: CandleAvgAggregateOutputType | null
    _sum: CandleSumAggregateOutputType | null
    _min: CandleMinAggregateOutputType | null
    _max: CandleMaxAggregateOutputType | null
  }

  type GetCandleGroupByPayload<T extends CandleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CandleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CandleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CandleGroupByOutputType[P]>
            : GetScalarType<T[P], CandleGroupByOutputType[P]>
        }
      >
    >


  export type CandleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbolId?: boolean
    timeframe?: boolean
    timestamp?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    volume?: boolean
    createdAt?: boolean
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candle"]>

  export type CandleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbolId?: boolean
    timeframe?: boolean
    timestamp?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    volume?: boolean
    createdAt?: boolean
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candle"]>

  export type CandleSelectScalar = {
    id?: boolean
    symbolId?: boolean
    timeframe?: boolean
    timestamp?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    volume?: boolean
    createdAt?: boolean
  }

  export type CandleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }
  export type CandleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }

  export type $CandlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Candle"
    objects: {
      symbol: Prisma.$SymbolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      symbolId: string
      timeframe: $Enums.Timeframe
      timestamp: Date
      open: Prisma.Decimal
      high: Prisma.Decimal
      low: Prisma.Decimal
      close: Prisma.Decimal
      volume: bigint
      createdAt: Date
    }, ExtArgs["result"]["candle"]>
    composites: {}
  }

  type CandleGetPayload<S extends boolean | null | undefined | CandleDefaultArgs> = $Result.GetResult<Prisma.$CandlePayload, S>

  type CandleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CandleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CandleCountAggregateInputType | true
    }

  export interface CandleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Candle'], meta: { name: 'Candle' } }
    /**
     * Find zero or one Candle that matches the filter.
     * @param {CandleFindUniqueArgs} args - Arguments to find a Candle
     * @example
     * // Get one Candle
     * const candle = await prisma.candle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CandleFindUniqueArgs>(args: SelectSubset<T, CandleFindUniqueArgs<ExtArgs>>): Prisma__CandleClient<$Result.GetResult<Prisma.$CandlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Candle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CandleFindUniqueOrThrowArgs} args - Arguments to find a Candle
     * @example
     * // Get one Candle
     * const candle = await prisma.candle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CandleFindUniqueOrThrowArgs>(args: SelectSubset<T, CandleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CandleClient<$Result.GetResult<Prisma.$CandlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Candle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandleFindFirstArgs} args - Arguments to find a Candle
     * @example
     * // Get one Candle
     * const candle = await prisma.candle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CandleFindFirstArgs>(args?: SelectSubset<T, CandleFindFirstArgs<ExtArgs>>): Prisma__CandleClient<$Result.GetResult<Prisma.$CandlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Candle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandleFindFirstOrThrowArgs} args - Arguments to find a Candle
     * @example
     * // Get one Candle
     * const candle = await prisma.candle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CandleFindFirstOrThrowArgs>(args?: SelectSubset<T, CandleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CandleClient<$Result.GetResult<Prisma.$CandlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Candles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Candles
     * const candles = await prisma.candle.findMany()
     * 
     * // Get first 10 Candles
     * const candles = await prisma.candle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const candleWithIdOnly = await prisma.candle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CandleFindManyArgs>(args?: SelectSubset<T, CandleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Candle.
     * @param {CandleCreateArgs} args - Arguments to create a Candle.
     * @example
     * // Create one Candle
     * const Candle = await prisma.candle.create({
     *   data: {
     *     // ... data to create a Candle
     *   }
     * })
     * 
     */
    create<T extends CandleCreateArgs>(args: SelectSubset<T, CandleCreateArgs<ExtArgs>>): Prisma__CandleClient<$Result.GetResult<Prisma.$CandlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Candles.
     * @param {CandleCreateManyArgs} args - Arguments to create many Candles.
     * @example
     * // Create many Candles
     * const candle = await prisma.candle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CandleCreateManyArgs>(args?: SelectSubset<T, CandleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Candles and returns the data saved in the database.
     * @param {CandleCreateManyAndReturnArgs} args - Arguments to create many Candles.
     * @example
     * // Create many Candles
     * const candle = await prisma.candle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Candles and only return the `id`
     * const candleWithIdOnly = await prisma.candle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CandleCreateManyAndReturnArgs>(args?: SelectSubset<T, CandleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Candle.
     * @param {CandleDeleteArgs} args - Arguments to delete one Candle.
     * @example
     * // Delete one Candle
     * const Candle = await prisma.candle.delete({
     *   where: {
     *     // ... filter to delete one Candle
     *   }
     * })
     * 
     */
    delete<T extends CandleDeleteArgs>(args: SelectSubset<T, CandleDeleteArgs<ExtArgs>>): Prisma__CandleClient<$Result.GetResult<Prisma.$CandlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Candle.
     * @param {CandleUpdateArgs} args - Arguments to update one Candle.
     * @example
     * // Update one Candle
     * const candle = await prisma.candle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CandleUpdateArgs>(args: SelectSubset<T, CandleUpdateArgs<ExtArgs>>): Prisma__CandleClient<$Result.GetResult<Prisma.$CandlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Candles.
     * @param {CandleDeleteManyArgs} args - Arguments to filter Candles to delete.
     * @example
     * // Delete a few Candles
     * const { count } = await prisma.candle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CandleDeleteManyArgs>(args?: SelectSubset<T, CandleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Candles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Candles
     * const candle = await prisma.candle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CandleUpdateManyArgs>(args: SelectSubset<T, CandleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Candle.
     * @param {CandleUpsertArgs} args - Arguments to update or create a Candle.
     * @example
     * // Update or create a Candle
     * const candle = await prisma.candle.upsert({
     *   create: {
     *     // ... data to create a Candle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Candle we want to update
     *   }
     * })
     */
    upsert<T extends CandleUpsertArgs>(args: SelectSubset<T, CandleUpsertArgs<ExtArgs>>): Prisma__CandleClient<$Result.GetResult<Prisma.$CandlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Candles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandleCountArgs} args - Arguments to filter Candles to count.
     * @example
     * // Count the number of Candles
     * const count = await prisma.candle.count({
     *   where: {
     *     // ... the filter for the Candles we want to count
     *   }
     * })
    **/
    count<T extends CandleCountArgs>(
      args?: Subset<T, CandleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CandleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Candle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CandleAggregateArgs>(args: Subset<T, CandleAggregateArgs>): Prisma.PrismaPromise<GetCandleAggregateType<T>>

    /**
     * Group by Candle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CandleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CandleGroupByArgs['orderBy'] }
        : { orderBy?: CandleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CandleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCandleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Candle model
   */
  readonly fields: CandleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Candle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CandleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    symbol<T extends SymbolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SymbolDefaultArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Candle model
   */ 
  interface CandleFieldRefs {
    readonly id: FieldRef<"Candle", 'String'>
    readonly symbolId: FieldRef<"Candle", 'String'>
    readonly timeframe: FieldRef<"Candle", 'Timeframe'>
    readonly timestamp: FieldRef<"Candle", 'DateTime'>
    readonly open: FieldRef<"Candle", 'Decimal'>
    readonly high: FieldRef<"Candle", 'Decimal'>
    readonly low: FieldRef<"Candle", 'Decimal'>
    readonly close: FieldRef<"Candle", 'Decimal'>
    readonly volume: FieldRef<"Candle", 'BigInt'>
    readonly createdAt: FieldRef<"Candle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Candle findUnique
   */
  export type CandleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candle
     */
    select?: CandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandleInclude<ExtArgs> | null
    /**
     * Filter, which Candle to fetch.
     */
    where: CandleWhereUniqueInput
  }

  /**
   * Candle findUniqueOrThrow
   */
  export type CandleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candle
     */
    select?: CandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandleInclude<ExtArgs> | null
    /**
     * Filter, which Candle to fetch.
     */
    where: CandleWhereUniqueInput
  }

  /**
   * Candle findFirst
   */
  export type CandleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candle
     */
    select?: CandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandleInclude<ExtArgs> | null
    /**
     * Filter, which Candle to fetch.
     */
    where?: CandleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candles to fetch.
     */
    orderBy?: CandleOrderByWithRelationInput | CandleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Candles.
     */
    cursor?: CandleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Candles.
     */
    distinct?: CandleScalarFieldEnum | CandleScalarFieldEnum[]
  }

  /**
   * Candle findFirstOrThrow
   */
  export type CandleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candle
     */
    select?: CandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandleInclude<ExtArgs> | null
    /**
     * Filter, which Candle to fetch.
     */
    where?: CandleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candles to fetch.
     */
    orderBy?: CandleOrderByWithRelationInput | CandleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Candles.
     */
    cursor?: CandleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Candles.
     */
    distinct?: CandleScalarFieldEnum | CandleScalarFieldEnum[]
  }

  /**
   * Candle findMany
   */
  export type CandleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candle
     */
    select?: CandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandleInclude<ExtArgs> | null
    /**
     * Filter, which Candles to fetch.
     */
    where?: CandleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candles to fetch.
     */
    orderBy?: CandleOrderByWithRelationInput | CandleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Candles.
     */
    cursor?: CandleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candles.
     */
    skip?: number
    distinct?: CandleScalarFieldEnum | CandleScalarFieldEnum[]
  }

  /**
   * Candle create
   */
  export type CandleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candle
     */
    select?: CandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandleInclude<ExtArgs> | null
    /**
     * The data needed to create a Candle.
     */
    data: XOR<CandleCreateInput, CandleUncheckedCreateInput>
  }

  /**
   * Candle createMany
   */
  export type CandleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Candles.
     */
    data: CandleCreateManyInput | CandleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Candle createManyAndReturn
   */
  export type CandleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candle
     */
    select?: CandleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Candles.
     */
    data: CandleCreateManyInput | CandleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Candle update
   */
  export type CandleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candle
     */
    select?: CandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandleInclude<ExtArgs> | null
    /**
     * The data needed to update a Candle.
     */
    data: XOR<CandleUpdateInput, CandleUncheckedUpdateInput>
    /**
     * Choose, which Candle to update.
     */
    where: CandleWhereUniqueInput
  }

  /**
   * Candle updateMany
   */
  export type CandleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Candles.
     */
    data: XOR<CandleUpdateManyMutationInput, CandleUncheckedUpdateManyInput>
    /**
     * Filter which Candles to update
     */
    where?: CandleWhereInput
  }

  /**
   * Candle upsert
   */
  export type CandleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candle
     */
    select?: CandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandleInclude<ExtArgs> | null
    /**
     * The filter to search for the Candle to update in case it exists.
     */
    where: CandleWhereUniqueInput
    /**
     * In case the Candle found by the `where` argument doesn't exist, create a new Candle with this data.
     */
    create: XOR<CandleCreateInput, CandleUncheckedCreateInput>
    /**
     * In case the Candle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CandleUpdateInput, CandleUncheckedUpdateInput>
  }

  /**
   * Candle delete
   */
  export type CandleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candle
     */
    select?: CandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandleInclude<ExtArgs> | null
    /**
     * Filter which Candle to delete.
     */
    where: CandleWhereUniqueInput
  }

  /**
   * Candle deleteMany
   */
  export type CandleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Candles to delete
     */
    where?: CandleWhereInput
  }

  /**
   * Candle without action
   */
  export type CandleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candle
     */
    select?: CandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandleInclude<ExtArgs> | null
  }


  /**
   * Model IndicatorCache
   */

  export type AggregateIndicatorCache = {
    _count: IndicatorCacheCountAggregateOutputType | null
    _avg: IndicatorCacheAvgAggregateOutputType | null
    _sum: IndicatorCacheSumAggregateOutputType | null
    _min: IndicatorCacheMinAggregateOutputType | null
    _max: IndicatorCacheMaxAggregateOutputType | null
  }

  export type IndicatorCacheAvgAggregateOutputType = {
    period: number | null
  }

  export type IndicatorCacheSumAggregateOutputType = {
    period: number | null
  }

  export type IndicatorCacheMinAggregateOutputType = {
    id: string | null
    symbolId: string | null
    indicator: $Enums.IndicatorType | null
    timeframe: $Enums.Timeframe | null
    period: number | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type IndicatorCacheMaxAggregateOutputType = {
    id: string | null
    symbolId: string | null
    indicator: $Enums.IndicatorType | null
    timeframe: $Enums.Timeframe | null
    period: number | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type IndicatorCacheCountAggregateOutputType = {
    id: number
    symbolId: number
    indicator: number
    timeframe: number
    period: number
    timestamp: number
    value: number
    createdAt: number
    _all: number
  }


  export type IndicatorCacheAvgAggregateInputType = {
    period?: true
  }

  export type IndicatorCacheSumAggregateInputType = {
    period?: true
  }

  export type IndicatorCacheMinAggregateInputType = {
    id?: true
    symbolId?: true
    indicator?: true
    timeframe?: true
    period?: true
    timestamp?: true
    createdAt?: true
  }

  export type IndicatorCacheMaxAggregateInputType = {
    id?: true
    symbolId?: true
    indicator?: true
    timeframe?: true
    period?: true
    timestamp?: true
    createdAt?: true
  }

  export type IndicatorCacheCountAggregateInputType = {
    id?: true
    symbolId?: true
    indicator?: true
    timeframe?: true
    period?: true
    timestamp?: true
    value?: true
    createdAt?: true
    _all?: true
  }

  export type IndicatorCacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicatorCache to aggregate.
     */
    where?: IndicatorCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorCaches to fetch.
     */
    orderBy?: IndicatorCacheOrderByWithRelationInput | IndicatorCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicatorCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IndicatorCaches
    **/
    _count?: true | IndicatorCacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndicatorCacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndicatorCacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicatorCacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicatorCacheMaxAggregateInputType
  }

  export type GetIndicatorCacheAggregateType<T extends IndicatorCacheAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicatorCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicatorCache[P]>
      : GetScalarType<T[P], AggregateIndicatorCache[P]>
  }




  export type IndicatorCacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorCacheWhereInput
    orderBy?: IndicatorCacheOrderByWithAggregationInput | IndicatorCacheOrderByWithAggregationInput[]
    by: IndicatorCacheScalarFieldEnum[] | IndicatorCacheScalarFieldEnum
    having?: IndicatorCacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicatorCacheCountAggregateInputType | true
    _avg?: IndicatorCacheAvgAggregateInputType
    _sum?: IndicatorCacheSumAggregateInputType
    _min?: IndicatorCacheMinAggregateInputType
    _max?: IndicatorCacheMaxAggregateInputType
  }

  export type IndicatorCacheGroupByOutputType = {
    id: string
    symbolId: string
    indicator: $Enums.IndicatorType
    timeframe: $Enums.Timeframe
    period: number
    timestamp: Date
    value: JsonValue
    createdAt: Date
    _count: IndicatorCacheCountAggregateOutputType | null
    _avg: IndicatorCacheAvgAggregateOutputType | null
    _sum: IndicatorCacheSumAggregateOutputType | null
    _min: IndicatorCacheMinAggregateOutputType | null
    _max: IndicatorCacheMaxAggregateOutputType | null
  }

  type GetIndicatorCacheGroupByPayload<T extends IndicatorCacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicatorCacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicatorCacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicatorCacheGroupByOutputType[P]>
            : GetScalarType<T[P], IndicatorCacheGroupByOutputType[P]>
        }
      >
    >


  export type IndicatorCacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbolId?: boolean
    indicator?: boolean
    timeframe?: boolean
    period?: boolean
    timestamp?: boolean
    value?: boolean
    createdAt?: boolean
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicatorCache"]>

  export type IndicatorCacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbolId?: boolean
    indicator?: boolean
    timeframe?: boolean
    period?: boolean
    timestamp?: boolean
    value?: boolean
    createdAt?: boolean
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicatorCache"]>

  export type IndicatorCacheSelectScalar = {
    id?: boolean
    symbolId?: boolean
    indicator?: boolean
    timeframe?: boolean
    period?: boolean
    timestamp?: boolean
    value?: boolean
    createdAt?: boolean
  }

  export type IndicatorCacheInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }
  export type IndicatorCacheIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }

  export type $IndicatorCachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IndicatorCache"
    objects: {
      symbol: Prisma.$SymbolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      symbolId: string
      indicator: $Enums.IndicatorType
      timeframe: $Enums.Timeframe
      period: number
      timestamp: Date
      value: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["indicatorCache"]>
    composites: {}
  }

  type IndicatorCacheGetPayload<S extends boolean | null | undefined | IndicatorCacheDefaultArgs> = $Result.GetResult<Prisma.$IndicatorCachePayload, S>

  type IndicatorCacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IndicatorCacheFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IndicatorCacheCountAggregateInputType | true
    }

  export interface IndicatorCacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IndicatorCache'], meta: { name: 'IndicatorCache' } }
    /**
     * Find zero or one IndicatorCache that matches the filter.
     * @param {IndicatorCacheFindUniqueArgs} args - Arguments to find a IndicatorCache
     * @example
     * // Get one IndicatorCache
     * const indicatorCache = await prisma.indicatorCache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicatorCacheFindUniqueArgs>(args: SelectSubset<T, IndicatorCacheFindUniqueArgs<ExtArgs>>): Prisma__IndicatorCacheClient<$Result.GetResult<Prisma.$IndicatorCachePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IndicatorCache that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IndicatorCacheFindUniqueOrThrowArgs} args - Arguments to find a IndicatorCache
     * @example
     * // Get one IndicatorCache
     * const indicatorCache = await prisma.indicatorCache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicatorCacheFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicatorCacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicatorCacheClient<$Result.GetResult<Prisma.$IndicatorCachePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IndicatorCache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCacheFindFirstArgs} args - Arguments to find a IndicatorCache
     * @example
     * // Get one IndicatorCache
     * const indicatorCache = await prisma.indicatorCache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicatorCacheFindFirstArgs>(args?: SelectSubset<T, IndicatorCacheFindFirstArgs<ExtArgs>>): Prisma__IndicatorCacheClient<$Result.GetResult<Prisma.$IndicatorCachePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IndicatorCache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCacheFindFirstOrThrowArgs} args - Arguments to find a IndicatorCache
     * @example
     * // Get one IndicatorCache
     * const indicatorCache = await prisma.indicatorCache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicatorCacheFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicatorCacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicatorCacheClient<$Result.GetResult<Prisma.$IndicatorCachePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IndicatorCaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndicatorCaches
     * const indicatorCaches = await prisma.indicatorCache.findMany()
     * 
     * // Get first 10 IndicatorCaches
     * const indicatorCaches = await prisma.indicatorCache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicatorCacheWithIdOnly = await prisma.indicatorCache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicatorCacheFindManyArgs>(args?: SelectSubset<T, IndicatorCacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorCachePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IndicatorCache.
     * @param {IndicatorCacheCreateArgs} args - Arguments to create a IndicatorCache.
     * @example
     * // Create one IndicatorCache
     * const IndicatorCache = await prisma.indicatorCache.create({
     *   data: {
     *     // ... data to create a IndicatorCache
     *   }
     * })
     * 
     */
    create<T extends IndicatorCacheCreateArgs>(args: SelectSubset<T, IndicatorCacheCreateArgs<ExtArgs>>): Prisma__IndicatorCacheClient<$Result.GetResult<Prisma.$IndicatorCachePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IndicatorCaches.
     * @param {IndicatorCacheCreateManyArgs} args - Arguments to create many IndicatorCaches.
     * @example
     * // Create many IndicatorCaches
     * const indicatorCache = await prisma.indicatorCache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicatorCacheCreateManyArgs>(args?: SelectSubset<T, IndicatorCacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IndicatorCaches and returns the data saved in the database.
     * @param {IndicatorCacheCreateManyAndReturnArgs} args - Arguments to create many IndicatorCaches.
     * @example
     * // Create many IndicatorCaches
     * const indicatorCache = await prisma.indicatorCache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IndicatorCaches and only return the `id`
     * const indicatorCacheWithIdOnly = await prisma.indicatorCache.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicatorCacheCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicatorCacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorCachePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IndicatorCache.
     * @param {IndicatorCacheDeleteArgs} args - Arguments to delete one IndicatorCache.
     * @example
     * // Delete one IndicatorCache
     * const IndicatorCache = await prisma.indicatorCache.delete({
     *   where: {
     *     // ... filter to delete one IndicatorCache
     *   }
     * })
     * 
     */
    delete<T extends IndicatorCacheDeleteArgs>(args: SelectSubset<T, IndicatorCacheDeleteArgs<ExtArgs>>): Prisma__IndicatorCacheClient<$Result.GetResult<Prisma.$IndicatorCachePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IndicatorCache.
     * @param {IndicatorCacheUpdateArgs} args - Arguments to update one IndicatorCache.
     * @example
     * // Update one IndicatorCache
     * const indicatorCache = await prisma.indicatorCache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicatorCacheUpdateArgs>(args: SelectSubset<T, IndicatorCacheUpdateArgs<ExtArgs>>): Prisma__IndicatorCacheClient<$Result.GetResult<Prisma.$IndicatorCachePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IndicatorCaches.
     * @param {IndicatorCacheDeleteManyArgs} args - Arguments to filter IndicatorCaches to delete.
     * @example
     * // Delete a few IndicatorCaches
     * const { count } = await prisma.indicatorCache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicatorCacheDeleteManyArgs>(args?: SelectSubset<T, IndicatorCacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndicatorCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndicatorCaches
     * const indicatorCache = await prisma.indicatorCache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicatorCacheUpdateManyArgs>(args: SelectSubset<T, IndicatorCacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IndicatorCache.
     * @param {IndicatorCacheUpsertArgs} args - Arguments to update or create a IndicatorCache.
     * @example
     * // Update or create a IndicatorCache
     * const indicatorCache = await prisma.indicatorCache.upsert({
     *   create: {
     *     // ... data to create a IndicatorCache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndicatorCache we want to update
     *   }
     * })
     */
    upsert<T extends IndicatorCacheUpsertArgs>(args: SelectSubset<T, IndicatorCacheUpsertArgs<ExtArgs>>): Prisma__IndicatorCacheClient<$Result.GetResult<Prisma.$IndicatorCachePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IndicatorCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCacheCountArgs} args - Arguments to filter IndicatorCaches to count.
     * @example
     * // Count the number of IndicatorCaches
     * const count = await prisma.indicatorCache.count({
     *   where: {
     *     // ... the filter for the IndicatorCaches we want to count
     *   }
     * })
    **/
    count<T extends IndicatorCacheCountArgs>(
      args?: Subset<T, IndicatorCacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicatorCacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndicatorCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicatorCacheAggregateArgs>(args: Subset<T, IndicatorCacheAggregateArgs>): Prisma.PrismaPromise<GetIndicatorCacheAggregateType<T>>

    /**
     * Group by IndicatorCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicatorCacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicatorCacheGroupByArgs['orderBy'] }
        : { orderBy?: IndicatorCacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicatorCacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicatorCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IndicatorCache model
   */
  readonly fields: IndicatorCacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndicatorCache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicatorCacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    symbol<T extends SymbolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SymbolDefaultArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IndicatorCache model
   */ 
  interface IndicatorCacheFieldRefs {
    readonly id: FieldRef<"IndicatorCache", 'String'>
    readonly symbolId: FieldRef<"IndicatorCache", 'String'>
    readonly indicator: FieldRef<"IndicatorCache", 'IndicatorType'>
    readonly timeframe: FieldRef<"IndicatorCache", 'Timeframe'>
    readonly period: FieldRef<"IndicatorCache", 'Int'>
    readonly timestamp: FieldRef<"IndicatorCache", 'DateTime'>
    readonly value: FieldRef<"IndicatorCache", 'Json'>
    readonly createdAt: FieldRef<"IndicatorCache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IndicatorCache findUnique
   */
  export type IndicatorCacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCache
     */
    select?: IndicatorCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCacheInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCache to fetch.
     */
    where: IndicatorCacheWhereUniqueInput
  }

  /**
   * IndicatorCache findUniqueOrThrow
   */
  export type IndicatorCacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCache
     */
    select?: IndicatorCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCacheInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCache to fetch.
     */
    where: IndicatorCacheWhereUniqueInput
  }

  /**
   * IndicatorCache findFirst
   */
  export type IndicatorCacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCache
     */
    select?: IndicatorCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCacheInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCache to fetch.
     */
    where?: IndicatorCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorCaches to fetch.
     */
    orderBy?: IndicatorCacheOrderByWithRelationInput | IndicatorCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicatorCaches.
     */
    cursor?: IndicatorCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicatorCaches.
     */
    distinct?: IndicatorCacheScalarFieldEnum | IndicatorCacheScalarFieldEnum[]
  }

  /**
   * IndicatorCache findFirstOrThrow
   */
  export type IndicatorCacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCache
     */
    select?: IndicatorCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCacheInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCache to fetch.
     */
    where?: IndicatorCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorCaches to fetch.
     */
    orderBy?: IndicatorCacheOrderByWithRelationInput | IndicatorCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicatorCaches.
     */
    cursor?: IndicatorCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicatorCaches.
     */
    distinct?: IndicatorCacheScalarFieldEnum | IndicatorCacheScalarFieldEnum[]
  }

  /**
   * IndicatorCache findMany
   */
  export type IndicatorCacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCache
     */
    select?: IndicatorCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCacheInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorCaches to fetch.
     */
    where?: IndicatorCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorCaches to fetch.
     */
    orderBy?: IndicatorCacheOrderByWithRelationInput | IndicatorCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IndicatorCaches.
     */
    cursor?: IndicatorCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorCaches.
     */
    skip?: number
    distinct?: IndicatorCacheScalarFieldEnum | IndicatorCacheScalarFieldEnum[]
  }

  /**
   * IndicatorCache create
   */
  export type IndicatorCacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCache
     */
    select?: IndicatorCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCacheInclude<ExtArgs> | null
    /**
     * The data needed to create a IndicatorCache.
     */
    data: XOR<IndicatorCacheCreateInput, IndicatorCacheUncheckedCreateInput>
  }

  /**
   * IndicatorCache createMany
   */
  export type IndicatorCacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IndicatorCaches.
     */
    data: IndicatorCacheCreateManyInput | IndicatorCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndicatorCache createManyAndReturn
   */
  export type IndicatorCacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCache
     */
    select?: IndicatorCacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IndicatorCaches.
     */
    data: IndicatorCacheCreateManyInput | IndicatorCacheCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCacheIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IndicatorCache update
   */
  export type IndicatorCacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCache
     */
    select?: IndicatorCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCacheInclude<ExtArgs> | null
    /**
     * The data needed to update a IndicatorCache.
     */
    data: XOR<IndicatorCacheUpdateInput, IndicatorCacheUncheckedUpdateInput>
    /**
     * Choose, which IndicatorCache to update.
     */
    where: IndicatorCacheWhereUniqueInput
  }

  /**
   * IndicatorCache updateMany
   */
  export type IndicatorCacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IndicatorCaches.
     */
    data: XOR<IndicatorCacheUpdateManyMutationInput, IndicatorCacheUncheckedUpdateManyInput>
    /**
     * Filter which IndicatorCaches to update
     */
    where?: IndicatorCacheWhereInput
  }

  /**
   * IndicatorCache upsert
   */
  export type IndicatorCacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCache
     */
    select?: IndicatorCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCacheInclude<ExtArgs> | null
    /**
     * The filter to search for the IndicatorCache to update in case it exists.
     */
    where: IndicatorCacheWhereUniqueInput
    /**
     * In case the IndicatorCache found by the `where` argument doesn't exist, create a new IndicatorCache with this data.
     */
    create: XOR<IndicatorCacheCreateInput, IndicatorCacheUncheckedCreateInput>
    /**
     * In case the IndicatorCache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicatorCacheUpdateInput, IndicatorCacheUncheckedUpdateInput>
  }

  /**
   * IndicatorCache delete
   */
  export type IndicatorCacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCache
     */
    select?: IndicatorCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCacheInclude<ExtArgs> | null
    /**
     * Filter which IndicatorCache to delete.
     */
    where: IndicatorCacheWhereUniqueInput
  }

  /**
   * IndicatorCache deleteMany
   */
  export type IndicatorCacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicatorCaches to delete
     */
    where?: IndicatorCacheWhereInput
  }

  /**
   * IndicatorCache without action
   */
  export type IndicatorCacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCache
     */
    select?: IndicatorCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorCacheInclude<ExtArgs> | null
  }


  /**
   * Model Watchlist
   */

  export type AggregateWatchlist = {
    _count: WatchlistCountAggregateOutputType | null
    _avg: WatchlistAvgAggregateOutputType | null
    _sum: WatchlistSumAggregateOutputType | null
    _min: WatchlistMinAggregateOutputType | null
    _max: WatchlistMaxAggregateOutputType | null
  }

  export type WatchlistAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type WatchlistSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type WatchlistMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    isPublic: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WatchlistMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    isPublic: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WatchlistCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    isPublic: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WatchlistAvgAggregateInputType = {
    sortOrder?: true
  }

  export type WatchlistSumAggregateInputType = {
    sortOrder?: true
  }

  export type WatchlistMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    isPublic?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WatchlistMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    isPublic?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WatchlistCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    isPublic?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WatchlistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Watchlist to aggregate.
     */
    where?: WatchlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Watchlists to fetch.
     */
    orderBy?: WatchlistOrderByWithRelationInput | WatchlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Watchlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Watchlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Watchlists
    **/
    _count?: true | WatchlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchlistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchlistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchlistMaxAggregateInputType
  }

  export type GetWatchlistAggregateType<T extends WatchlistAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchlist[P]>
      : GetScalarType<T[P], AggregateWatchlist[P]>
  }




  export type WatchlistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistWhereInput
    orderBy?: WatchlistOrderByWithAggregationInput | WatchlistOrderByWithAggregationInput[]
    by: WatchlistScalarFieldEnum[] | WatchlistScalarFieldEnum
    having?: WatchlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchlistCountAggregateInputType | true
    _avg?: WatchlistAvgAggregateInputType
    _sum?: WatchlistSumAggregateInputType
    _min?: WatchlistMinAggregateInputType
    _max?: WatchlistMaxAggregateInputType
  }

  export type WatchlistGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    isPublic: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: WatchlistCountAggregateOutputType | null
    _avg: WatchlistAvgAggregateOutputType | null
    _sum: WatchlistSumAggregateOutputType | null
    _min: WatchlistMinAggregateOutputType | null
    _max: WatchlistMaxAggregateOutputType | null
  }

  type GetWatchlistGroupByPayload<T extends WatchlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WatchlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchlistGroupByOutputType[P]>
            : GetScalarType<T[P], WatchlistGroupByOutputType[P]>
        }
      >
    >


  export type WatchlistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    isPublic?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    symbols?: boolean | Watchlist$symbolsArgs<ExtArgs>
    _count?: boolean | WatchlistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlist"]>

  export type WatchlistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    isPublic?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlist"]>

  export type WatchlistSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    isPublic?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WatchlistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    symbols?: boolean | Watchlist$symbolsArgs<ExtArgs>
    _count?: boolean | WatchlistCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WatchlistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WatchlistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Watchlist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      symbols: Prisma.$WatchlistSymbolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      isPublic: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["watchlist"]>
    composites: {}
  }

  type WatchlistGetPayload<S extends boolean | null | undefined | WatchlistDefaultArgs> = $Result.GetResult<Prisma.$WatchlistPayload, S>

  type WatchlistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WatchlistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WatchlistCountAggregateInputType | true
    }

  export interface WatchlistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Watchlist'], meta: { name: 'Watchlist' } }
    /**
     * Find zero or one Watchlist that matches the filter.
     * @param {WatchlistFindUniqueArgs} args - Arguments to find a Watchlist
     * @example
     * // Get one Watchlist
     * const watchlist = await prisma.watchlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WatchlistFindUniqueArgs>(args: SelectSubset<T, WatchlistFindUniqueArgs<ExtArgs>>): Prisma__WatchlistClient<$Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Watchlist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WatchlistFindUniqueOrThrowArgs} args - Arguments to find a Watchlist
     * @example
     * // Get one Watchlist
     * const watchlist = await prisma.watchlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WatchlistFindUniqueOrThrowArgs>(args: SelectSubset<T, WatchlistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WatchlistClient<$Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Watchlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistFindFirstArgs} args - Arguments to find a Watchlist
     * @example
     * // Get one Watchlist
     * const watchlist = await prisma.watchlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WatchlistFindFirstArgs>(args?: SelectSubset<T, WatchlistFindFirstArgs<ExtArgs>>): Prisma__WatchlistClient<$Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Watchlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistFindFirstOrThrowArgs} args - Arguments to find a Watchlist
     * @example
     * // Get one Watchlist
     * const watchlist = await prisma.watchlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WatchlistFindFirstOrThrowArgs>(args?: SelectSubset<T, WatchlistFindFirstOrThrowArgs<ExtArgs>>): Prisma__WatchlistClient<$Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Watchlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Watchlists
     * const watchlists = await prisma.watchlist.findMany()
     * 
     * // Get first 10 Watchlists
     * const watchlists = await prisma.watchlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchlistWithIdOnly = await prisma.watchlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WatchlistFindManyArgs>(args?: SelectSubset<T, WatchlistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Watchlist.
     * @param {WatchlistCreateArgs} args - Arguments to create a Watchlist.
     * @example
     * // Create one Watchlist
     * const Watchlist = await prisma.watchlist.create({
     *   data: {
     *     // ... data to create a Watchlist
     *   }
     * })
     * 
     */
    create<T extends WatchlistCreateArgs>(args: SelectSubset<T, WatchlistCreateArgs<ExtArgs>>): Prisma__WatchlistClient<$Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Watchlists.
     * @param {WatchlistCreateManyArgs} args - Arguments to create many Watchlists.
     * @example
     * // Create many Watchlists
     * const watchlist = await prisma.watchlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WatchlistCreateManyArgs>(args?: SelectSubset<T, WatchlistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Watchlists and returns the data saved in the database.
     * @param {WatchlistCreateManyAndReturnArgs} args - Arguments to create many Watchlists.
     * @example
     * // Create many Watchlists
     * const watchlist = await prisma.watchlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Watchlists and only return the `id`
     * const watchlistWithIdOnly = await prisma.watchlist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WatchlistCreateManyAndReturnArgs>(args?: SelectSubset<T, WatchlistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Watchlist.
     * @param {WatchlistDeleteArgs} args - Arguments to delete one Watchlist.
     * @example
     * // Delete one Watchlist
     * const Watchlist = await prisma.watchlist.delete({
     *   where: {
     *     // ... filter to delete one Watchlist
     *   }
     * })
     * 
     */
    delete<T extends WatchlistDeleteArgs>(args: SelectSubset<T, WatchlistDeleteArgs<ExtArgs>>): Prisma__WatchlistClient<$Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Watchlist.
     * @param {WatchlistUpdateArgs} args - Arguments to update one Watchlist.
     * @example
     * // Update one Watchlist
     * const watchlist = await prisma.watchlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WatchlistUpdateArgs>(args: SelectSubset<T, WatchlistUpdateArgs<ExtArgs>>): Prisma__WatchlistClient<$Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Watchlists.
     * @param {WatchlistDeleteManyArgs} args - Arguments to filter Watchlists to delete.
     * @example
     * // Delete a few Watchlists
     * const { count } = await prisma.watchlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WatchlistDeleteManyArgs>(args?: SelectSubset<T, WatchlistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Watchlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Watchlists
     * const watchlist = await prisma.watchlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WatchlistUpdateManyArgs>(args: SelectSubset<T, WatchlistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Watchlist.
     * @param {WatchlistUpsertArgs} args - Arguments to update or create a Watchlist.
     * @example
     * // Update or create a Watchlist
     * const watchlist = await prisma.watchlist.upsert({
     *   create: {
     *     // ... data to create a Watchlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Watchlist we want to update
     *   }
     * })
     */
    upsert<T extends WatchlistUpsertArgs>(args: SelectSubset<T, WatchlistUpsertArgs<ExtArgs>>): Prisma__WatchlistClient<$Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Watchlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistCountArgs} args - Arguments to filter Watchlists to count.
     * @example
     * // Count the number of Watchlists
     * const count = await prisma.watchlist.count({
     *   where: {
     *     // ... the filter for the Watchlists we want to count
     *   }
     * })
    **/
    count<T extends WatchlistCountArgs>(
      args?: Subset<T, WatchlistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Watchlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchlistAggregateArgs>(args: Subset<T, WatchlistAggregateArgs>): Prisma.PrismaPromise<GetWatchlistAggregateType<T>>

    /**
     * Group by Watchlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchlistGroupByArgs['orderBy'] }
        : { orderBy?: WatchlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Watchlist model
   */
  readonly fields: WatchlistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Watchlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WatchlistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    symbols<T extends Watchlist$symbolsArgs<ExtArgs> = {}>(args?: Subset<T, Watchlist$symbolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistSymbolPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Watchlist model
   */ 
  interface WatchlistFieldRefs {
    readonly id: FieldRef<"Watchlist", 'String'>
    readonly userId: FieldRef<"Watchlist", 'String'>
    readonly name: FieldRef<"Watchlist", 'String'>
    readonly description: FieldRef<"Watchlist", 'String'>
    readonly isPublic: FieldRef<"Watchlist", 'Boolean'>
    readonly sortOrder: FieldRef<"Watchlist", 'Int'>
    readonly createdAt: FieldRef<"Watchlist", 'DateTime'>
    readonly updatedAt: FieldRef<"Watchlist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Watchlist findUnique
   */
  export type WatchlistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Watchlist
     */
    select?: WatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistInclude<ExtArgs> | null
    /**
     * Filter, which Watchlist to fetch.
     */
    where: WatchlistWhereUniqueInput
  }

  /**
   * Watchlist findUniqueOrThrow
   */
  export type WatchlistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Watchlist
     */
    select?: WatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistInclude<ExtArgs> | null
    /**
     * Filter, which Watchlist to fetch.
     */
    where: WatchlistWhereUniqueInput
  }

  /**
   * Watchlist findFirst
   */
  export type WatchlistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Watchlist
     */
    select?: WatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistInclude<ExtArgs> | null
    /**
     * Filter, which Watchlist to fetch.
     */
    where?: WatchlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Watchlists to fetch.
     */
    orderBy?: WatchlistOrderByWithRelationInput | WatchlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Watchlists.
     */
    cursor?: WatchlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Watchlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Watchlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Watchlists.
     */
    distinct?: WatchlistScalarFieldEnum | WatchlistScalarFieldEnum[]
  }

  /**
   * Watchlist findFirstOrThrow
   */
  export type WatchlistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Watchlist
     */
    select?: WatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistInclude<ExtArgs> | null
    /**
     * Filter, which Watchlist to fetch.
     */
    where?: WatchlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Watchlists to fetch.
     */
    orderBy?: WatchlistOrderByWithRelationInput | WatchlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Watchlists.
     */
    cursor?: WatchlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Watchlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Watchlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Watchlists.
     */
    distinct?: WatchlistScalarFieldEnum | WatchlistScalarFieldEnum[]
  }

  /**
   * Watchlist findMany
   */
  export type WatchlistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Watchlist
     */
    select?: WatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistInclude<ExtArgs> | null
    /**
     * Filter, which Watchlists to fetch.
     */
    where?: WatchlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Watchlists to fetch.
     */
    orderBy?: WatchlistOrderByWithRelationInput | WatchlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Watchlists.
     */
    cursor?: WatchlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Watchlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Watchlists.
     */
    skip?: number
    distinct?: WatchlistScalarFieldEnum | WatchlistScalarFieldEnum[]
  }

  /**
   * Watchlist create
   */
  export type WatchlistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Watchlist
     */
    select?: WatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistInclude<ExtArgs> | null
    /**
     * The data needed to create a Watchlist.
     */
    data: XOR<WatchlistCreateInput, WatchlistUncheckedCreateInput>
  }

  /**
   * Watchlist createMany
   */
  export type WatchlistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Watchlists.
     */
    data: WatchlistCreateManyInput | WatchlistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Watchlist createManyAndReturn
   */
  export type WatchlistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Watchlist
     */
    select?: WatchlistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Watchlists.
     */
    data: WatchlistCreateManyInput | WatchlistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Watchlist update
   */
  export type WatchlistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Watchlist
     */
    select?: WatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistInclude<ExtArgs> | null
    /**
     * The data needed to update a Watchlist.
     */
    data: XOR<WatchlistUpdateInput, WatchlistUncheckedUpdateInput>
    /**
     * Choose, which Watchlist to update.
     */
    where: WatchlistWhereUniqueInput
  }

  /**
   * Watchlist updateMany
   */
  export type WatchlistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Watchlists.
     */
    data: XOR<WatchlistUpdateManyMutationInput, WatchlistUncheckedUpdateManyInput>
    /**
     * Filter which Watchlists to update
     */
    where?: WatchlistWhereInput
  }

  /**
   * Watchlist upsert
   */
  export type WatchlistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Watchlist
     */
    select?: WatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistInclude<ExtArgs> | null
    /**
     * The filter to search for the Watchlist to update in case it exists.
     */
    where: WatchlistWhereUniqueInput
    /**
     * In case the Watchlist found by the `where` argument doesn't exist, create a new Watchlist with this data.
     */
    create: XOR<WatchlistCreateInput, WatchlistUncheckedCreateInput>
    /**
     * In case the Watchlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchlistUpdateInput, WatchlistUncheckedUpdateInput>
  }

  /**
   * Watchlist delete
   */
  export type WatchlistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Watchlist
     */
    select?: WatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistInclude<ExtArgs> | null
    /**
     * Filter which Watchlist to delete.
     */
    where: WatchlistWhereUniqueInput
  }

  /**
   * Watchlist deleteMany
   */
  export type WatchlistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Watchlists to delete
     */
    where?: WatchlistWhereInput
  }

  /**
   * Watchlist.symbols
   */
  export type Watchlist$symbolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistSymbol
     */
    select?: WatchlistSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistSymbolInclude<ExtArgs> | null
    where?: WatchlistSymbolWhereInput
    orderBy?: WatchlistSymbolOrderByWithRelationInput | WatchlistSymbolOrderByWithRelationInput[]
    cursor?: WatchlistSymbolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchlistSymbolScalarFieldEnum | WatchlistSymbolScalarFieldEnum[]
  }

  /**
   * Watchlist without action
   */
  export type WatchlistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Watchlist
     */
    select?: WatchlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistInclude<ExtArgs> | null
  }


  /**
   * Model WatchlistSymbol
   */

  export type AggregateWatchlistSymbol = {
    _count: WatchlistSymbolCountAggregateOutputType | null
    _min: WatchlistSymbolMinAggregateOutputType | null
    _max: WatchlistSymbolMaxAggregateOutputType | null
  }

  export type WatchlistSymbolMinAggregateOutputType = {
    id: string | null
    watchlistId: string | null
    symbolId: string | null
    notes: string | null
    addedAt: Date | null
  }

  export type WatchlistSymbolMaxAggregateOutputType = {
    id: string | null
    watchlistId: string | null
    symbolId: string | null
    notes: string | null
    addedAt: Date | null
  }

  export type WatchlistSymbolCountAggregateOutputType = {
    id: number
    watchlistId: number
    symbolId: number
    notes: number
    addedAt: number
    _all: number
  }


  export type WatchlistSymbolMinAggregateInputType = {
    id?: true
    watchlistId?: true
    symbolId?: true
    notes?: true
    addedAt?: true
  }

  export type WatchlistSymbolMaxAggregateInputType = {
    id?: true
    watchlistId?: true
    symbolId?: true
    notes?: true
    addedAt?: true
  }

  export type WatchlistSymbolCountAggregateInputType = {
    id?: true
    watchlistId?: true
    symbolId?: true
    notes?: true
    addedAt?: true
    _all?: true
  }

  export type WatchlistSymbolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistSymbol to aggregate.
     */
    where?: WatchlistSymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistSymbols to fetch.
     */
    orderBy?: WatchlistSymbolOrderByWithRelationInput | WatchlistSymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchlistSymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistSymbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistSymbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchlistSymbols
    **/
    _count?: true | WatchlistSymbolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchlistSymbolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchlistSymbolMaxAggregateInputType
  }

  export type GetWatchlistSymbolAggregateType<T extends WatchlistSymbolAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchlistSymbol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchlistSymbol[P]>
      : GetScalarType<T[P], AggregateWatchlistSymbol[P]>
  }




  export type WatchlistSymbolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchlistSymbolWhereInput
    orderBy?: WatchlistSymbolOrderByWithAggregationInput | WatchlistSymbolOrderByWithAggregationInput[]
    by: WatchlistSymbolScalarFieldEnum[] | WatchlistSymbolScalarFieldEnum
    having?: WatchlistSymbolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchlistSymbolCountAggregateInputType | true
    _min?: WatchlistSymbolMinAggregateInputType
    _max?: WatchlistSymbolMaxAggregateInputType
  }

  export type WatchlistSymbolGroupByOutputType = {
    id: string
    watchlistId: string
    symbolId: string
    notes: string | null
    addedAt: Date
    _count: WatchlistSymbolCountAggregateOutputType | null
    _min: WatchlistSymbolMinAggregateOutputType | null
    _max: WatchlistSymbolMaxAggregateOutputType | null
  }

  type GetWatchlistSymbolGroupByPayload<T extends WatchlistSymbolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WatchlistSymbolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchlistSymbolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchlistSymbolGroupByOutputType[P]>
            : GetScalarType<T[P], WatchlistSymbolGroupByOutputType[P]>
        }
      >
    >


  export type WatchlistSymbolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    watchlistId?: boolean
    symbolId?: boolean
    notes?: boolean
    addedAt?: boolean
    watchlist?: boolean | WatchlistDefaultArgs<ExtArgs>
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistSymbol"]>

  export type WatchlistSymbolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    watchlistId?: boolean
    symbolId?: boolean
    notes?: boolean
    addedAt?: boolean
    watchlist?: boolean | WatchlistDefaultArgs<ExtArgs>
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchlistSymbol"]>

  export type WatchlistSymbolSelectScalar = {
    id?: boolean
    watchlistId?: boolean
    symbolId?: boolean
    notes?: boolean
    addedAt?: boolean
  }

  export type WatchlistSymbolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlist?: boolean | WatchlistDefaultArgs<ExtArgs>
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }
  export type WatchlistSymbolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    watchlist?: boolean | WatchlistDefaultArgs<ExtArgs>
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }

  export type $WatchlistSymbolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WatchlistSymbol"
    objects: {
      watchlist: Prisma.$WatchlistPayload<ExtArgs>
      symbol: Prisma.$SymbolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      watchlistId: string
      symbolId: string
      notes: string | null
      addedAt: Date
    }, ExtArgs["result"]["watchlistSymbol"]>
    composites: {}
  }

  type WatchlistSymbolGetPayload<S extends boolean | null | undefined | WatchlistSymbolDefaultArgs> = $Result.GetResult<Prisma.$WatchlistSymbolPayload, S>

  type WatchlistSymbolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WatchlistSymbolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WatchlistSymbolCountAggregateInputType | true
    }

  export interface WatchlistSymbolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchlistSymbol'], meta: { name: 'WatchlistSymbol' } }
    /**
     * Find zero or one WatchlistSymbol that matches the filter.
     * @param {WatchlistSymbolFindUniqueArgs} args - Arguments to find a WatchlistSymbol
     * @example
     * // Get one WatchlistSymbol
     * const watchlistSymbol = await prisma.watchlistSymbol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WatchlistSymbolFindUniqueArgs>(args: SelectSubset<T, WatchlistSymbolFindUniqueArgs<ExtArgs>>): Prisma__WatchlistSymbolClient<$Result.GetResult<Prisma.$WatchlistSymbolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WatchlistSymbol that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WatchlistSymbolFindUniqueOrThrowArgs} args - Arguments to find a WatchlistSymbol
     * @example
     * // Get one WatchlistSymbol
     * const watchlistSymbol = await prisma.watchlistSymbol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WatchlistSymbolFindUniqueOrThrowArgs>(args: SelectSubset<T, WatchlistSymbolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WatchlistSymbolClient<$Result.GetResult<Prisma.$WatchlistSymbolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WatchlistSymbol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistSymbolFindFirstArgs} args - Arguments to find a WatchlistSymbol
     * @example
     * // Get one WatchlistSymbol
     * const watchlistSymbol = await prisma.watchlistSymbol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WatchlistSymbolFindFirstArgs>(args?: SelectSubset<T, WatchlistSymbolFindFirstArgs<ExtArgs>>): Prisma__WatchlistSymbolClient<$Result.GetResult<Prisma.$WatchlistSymbolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WatchlistSymbol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistSymbolFindFirstOrThrowArgs} args - Arguments to find a WatchlistSymbol
     * @example
     * // Get one WatchlistSymbol
     * const watchlistSymbol = await prisma.watchlistSymbol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WatchlistSymbolFindFirstOrThrowArgs>(args?: SelectSubset<T, WatchlistSymbolFindFirstOrThrowArgs<ExtArgs>>): Prisma__WatchlistSymbolClient<$Result.GetResult<Prisma.$WatchlistSymbolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WatchlistSymbols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistSymbolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchlistSymbols
     * const watchlistSymbols = await prisma.watchlistSymbol.findMany()
     * 
     * // Get first 10 WatchlistSymbols
     * const watchlistSymbols = await prisma.watchlistSymbol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchlistSymbolWithIdOnly = await prisma.watchlistSymbol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WatchlistSymbolFindManyArgs>(args?: SelectSubset<T, WatchlistSymbolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistSymbolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WatchlistSymbol.
     * @param {WatchlistSymbolCreateArgs} args - Arguments to create a WatchlistSymbol.
     * @example
     * // Create one WatchlistSymbol
     * const WatchlistSymbol = await prisma.watchlistSymbol.create({
     *   data: {
     *     // ... data to create a WatchlistSymbol
     *   }
     * })
     * 
     */
    create<T extends WatchlistSymbolCreateArgs>(args: SelectSubset<T, WatchlistSymbolCreateArgs<ExtArgs>>): Prisma__WatchlistSymbolClient<$Result.GetResult<Prisma.$WatchlistSymbolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WatchlistSymbols.
     * @param {WatchlistSymbolCreateManyArgs} args - Arguments to create many WatchlistSymbols.
     * @example
     * // Create many WatchlistSymbols
     * const watchlistSymbol = await prisma.watchlistSymbol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WatchlistSymbolCreateManyArgs>(args?: SelectSubset<T, WatchlistSymbolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WatchlistSymbols and returns the data saved in the database.
     * @param {WatchlistSymbolCreateManyAndReturnArgs} args - Arguments to create many WatchlistSymbols.
     * @example
     * // Create many WatchlistSymbols
     * const watchlistSymbol = await prisma.watchlistSymbol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WatchlistSymbols and only return the `id`
     * const watchlistSymbolWithIdOnly = await prisma.watchlistSymbol.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WatchlistSymbolCreateManyAndReturnArgs>(args?: SelectSubset<T, WatchlistSymbolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchlistSymbolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WatchlistSymbol.
     * @param {WatchlistSymbolDeleteArgs} args - Arguments to delete one WatchlistSymbol.
     * @example
     * // Delete one WatchlistSymbol
     * const WatchlistSymbol = await prisma.watchlistSymbol.delete({
     *   where: {
     *     // ... filter to delete one WatchlistSymbol
     *   }
     * })
     * 
     */
    delete<T extends WatchlistSymbolDeleteArgs>(args: SelectSubset<T, WatchlistSymbolDeleteArgs<ExtArgs>>): Prisma__WatchlistSymbolClient<$Result.GetResult<Prisma.$WatchlistSymbolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WatchlistSymbol.
     * @param {WatchlistSymbolUpdateArgs} args - Arguments to update one WatchlistSymbol.
     * @example
     * // Update one WatchlistSymbol
     * const watchlistSymbol = await prisma.watchlistSymbol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WatchlistSymbolUpdateArgs>(args: SelectSubset<T, WatchlistSymbolUpdateArgs<ExtArgs>>): Prisma__WatchlistSymbolClient<$Result.GetResult<Prisma.$WatchlistSymbolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WatchlistSymbols.
     * @param {WatchlistSymbolDeleteManyArgs} args - Arguments to filter WatchlistSymbols to delete.
     * @example
     * // Delete a few WatchlistSymbols
     * const { count } = await prisma.watchlistSymbol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WatchlistSymbolDeleteManyArgs>(args?: SelectSubset<T, WatchlistSymbolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchlistSymbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistSymbolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchlistSymbols
     * const watchlistSymbol = await prisma.watchlistSymbol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WatchlistSymbolUpdateManyArgs>(args: SelectSubset<T, WatchlistSymbolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WatchlistSymbol.
     * @param {WatchlistSymbolUpsertArgs} args - Arguments to update or create a WatchlistSymbol.
     * @example
     * // Update or create a WatchlistSymbol
     * const watchlistSymbol = await prisma.watchlistSymbol.upsert({
     *   create: {
     *     // ... data to create a WatchlistSymbol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchlistSymbol we want to update
     *   }
     * })
     */
    upsert<T extends WatchlistSymbolUpsertArgs>(args: SelectSubset<T, WatchlistSymbolUpsertArgs<ExtArgs>>): Prisma__WatchlistSymbolClient<$Result.GetResult<Prisma.$WatchlistSymbolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WatchlistSymbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistSymbolCountArgs} args - Arguments to filter WatchlistSymbols to count.
     * @example
     * // Count the number of WatchlistSymbols
     * const count = await prisma.watchlistSymbol.count({
     *   where: {
     *     // ... the filter for the WatchlistSymbols we want to count
     *   }
     * })
    **/
    count<T extends WatchlistSymbolCountArgs>(
      args?: Subset<T, WatchlistSymbolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchlistSymbolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchlistSymbol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistSymbolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchlistSymbolAggregateArgs>(args: Subset<T, WatchlistSymbolAggregateArgs>): Prisma.PrismaPromise<GetWatchlistSymbolAggregateType<T>>

    /**
     * Group by WatchlistSymbol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchlistSymbolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchlistSymbolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchlistSymbolGroupByArgs['orderBy'] }
        : { orderBy?: WatchlistSymbolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchlistSymbolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchlistSymbolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WatchlistSymbol model
   */
  readonly fields: WatchlistSymbolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchlistSymbol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WatchlistSymbolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    watchlist<T extends WatchlistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WatchlistDefaultArgs<ExtArgs>>): Prisma__WatchlistClient<$Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    symbol<T extends SymbolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SymbolDefaultArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WatchlistSymbol model
   */ 
  interface WatchlistSymbolFieldRefs {
    readonly id: FieldRef<"WatchlistSymbol", 'String'>
    readonly watchlistId: FieldRef<"WatchlistSymbol", 'String'>
    readonly symbolId: FieldRef<"WatchlistSymbol", 'String'>
    readonly notes: FieldRef<"WatchlistSymbol", 'String'>
    readonly addedAt: FieldRef<"WatchlistSymbol", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WatchlistSymbol findUnique
   */
  export type WatchlistSymbolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistSymbol
     */
    select?: WatchlistSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistSymbolInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistSymbol to fetch.
     */
    where: WatchlistSymbolWhereUniqueInput
  }

  /**
   * WatchlistSymbol findUniqueOrThrow
   */
  export type WatchlistSymbolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistSymbol
     */
    select?: WatchlistSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistSymbolInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistSymbol to fetch.
     */
    where: WatchlistSymbolWhereUniqueInput
  }

  /**
   * WatchlistSymbol findFirst
   */
  export type WatchlistSymbolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistSymbol
     */
    select?: WatchlistSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistSymbolInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistSymbol to fetch.
     */
    where?: WatchlistSymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistSymbols to fetch.
     */
    orderBy?: WatchlistSymbolOrderByWithRelationInput | WatchlistSymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistSymbols.
     */
    cursor?: WatchlistSymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistSymbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistSymbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistSymbols.
     */
    distinct?: WatchlistSymbolScalarFieldEnum | WatchlistSymbolScalarFieldEnum[]
  }

  /**
   * WatchlistSymbol findFirstOrThrow
   */
  export type WatchlistSymbolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistSymbol
     */
    select?: WatchlistSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistSymbolInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistSymbol to fetch.
     */
    where?: WatchlistSymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistSymbols to fetch.
     */
    orderBy?: WatchlistSymbolOrderByWithRelationInput | WatchlistSymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchlistSymbols.
     */
    cursor?: WatchlistSymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistSymbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistSymbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchlistSymbols.
     */
    distinct?: WatchlistSymbolScalarFieldEnum | WatchlistSymbolScalarFieldEnum[]
  }

  /**
   * WatchlistSymbol findMany
   */
  export type WatchlistSymbolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistSymbol
     */
    select?: WatchlistSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistSymbolInclude<ExtArgs> | null
    /**
     * Filter, which WatchlistSymbols to fetch.
     */
    where?: WatchlistSymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchlistSymbols to fetch.
     */
    orderBy?: WatchlistSymbolOrderByWithRelationInput | WatchlistSymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchlistSymbols.
     */
    cursor?: WatchlistSymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchlistSymbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchlistSymbols.
     */
    skip?: number
    distinct?: WatchlistSymbolScalarFieldEnum | WatchlistSymbolScalarFieldEnum[]
  }

  /**
   * WatchlistSymbol create
   */
  export type WatchlistSymbolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistSymbol
     */
    select?: WatchlistSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistSymbolInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchlistSymbol.
     */
    data: XOR<WatchlistSymbolCreateInput, WatchlistSymbolUncheckedCreateInput>
  }

  /**
   * WatchlistSymbol createMany
   */
  export type WatchlistSymbolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchlistSymbols.
     */
    data: WatchlistSymbolCreateManyInput | WatchlistSymbolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WatchlistSymbol createManyAndReturn
   */
  export type WatchlistSymbolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistSymbol
     */
    select?: WatchlistSymbolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WatchlistSymbols.
     */
    data: WatchlistSymbolCreateManyInput | WatchlistSymbolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistSymbolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchlistSymbol update
   */
  export type WatchlistSymbolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistSymbol
     */
    select?: WatchlistSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistSymbolInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchlistSymbol.
     */
    data: XOR<WatchlistSymbolUpdateInput, WatchlistSymbolUncheckedUpdateInput>
    /**
     * Choose, which WatchlistSymbol to update.
     */
    where: WatchlistSymbolWhereUniqueInput
  }

  /**
   * WatchlistSymbol updateMany
   */
  export type WatchlistSymbolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchlistSymbols.
     */
    data: XOR<WatchlistSymbolUpdateManyMutationInput, WatchlistSymbolUncheckedUpdateManyInput>
    /**
     * Filter which WatchlistSymbols to update
     */
    where?: WatchlistSymbolWhereInput
  }

  /**
   * WatchlistSymbol upsert
   */
  export type WatchlistSymbolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistSymbol
     */
    select?: WatchlistSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistSymbolInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchlistSymbol to update in case it exists.
     */
    where: WatchlistSymbolWhereUniqueInput
    /**
     * In case the WatchlistSymbol found by the `where` argument doesn't exist, create a new WatchlistSymbol with this data.
     */
    create: XOR<WatchlistSymbolCreateInput, WatchlistSymbolUncheckedCreateInput>
    /**
     * In case the WatchlistSymbol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchlistSymbolUpdateInput, WatchlistSymbolUncheckedUpdateInput>
  }

  /**
   * WatchlistSymbol delete
   */
  export type WatchlistSymbolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistSymbol
     */
    select?: WatchlistSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistSymbolInclude<ExtArgs> | null
    /**
     * Filter which WatchlistSymbol to delete.
     */
    where: WatchlistSymbolWhereUniqueInput
  }

  /**
   * WatchlistSymbol deleteMany
   */
  export type WatchlistSymbolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchlistSymbols to delete
     */
    where?: WatchlistSymbolWhereInput
  }

  /**
   * WatchlistSymbol without action
   */
  export type WatchlistSymbolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchlistSymbol
     */
    select?: WatchlistSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchlistSymbolInclude<ExtArgs> | null
  }


  /**
   * Model SavedScan
   */

  export type AggregateSavedScan = {
    _count: SavedScanCountAggregateOutputType | null
    _min: SavedScanMinAggregateOutputType | null
    _max: SavedScanMaxAggregateOutputType | null
  }

  export type SavedScanMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastRunAt: Date | null
  }

  export type SavedScanMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastRunAt: Date | null
  }

  export type SavedScanCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    definition: number
    symbolUniverse: number
    isPublic: number
    createdAt: number
    updatedAt: number
    lastRunAt: number
    _all: number
  }


  export type SavedScanMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    lastRunAt?: true
  }

  export type SavedScanMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    lastRunAt?: true
  }

  export type SavedScanCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    definition?: true
    symbolUniverse?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    lastRunAt?: true
    _all?: true
  }

  export type SavedScanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedScan to aggregate.
     */
    where?: SavedScanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedScans to fetch.
     */
    orderBy?: SavedScanOrderByWithRelationInput | SavedScanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedScanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedScans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedScans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedScans
    **/
    _count?: true | SavedScanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedScanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedScanMaxAggregateInputType
  }

  export type GetSavedScanAggregateType<T extends SavedScanAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedScan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedScan[P]>
      : GetScalarType<T[P], AggregateSavedScan[P]>
  }




  export type SavedScanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedScanWhereInput
    orderBy?: SavedScanOrderByWithAggregationInput | SavedScanOrderByWithAggregationInput[]
    by: SavedScanScalarFieldEnum[] | SavedScanScalarFieldEnum
    having?: SavedScanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedScanCountAggregateInputType | true
    _min?: SavedScanMinAggregateInputType
    _max?: SavedScanMaxAggregateInputType
  }

  export type SavedScanGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    definition: JsonValue
    symbolUniverse: string[]
    isPublic: boolean
    createdAt: Date
    updatedAt: Date
    lastRunAt: Date | null
    _count: SavedScanCountAggregateOutputType | null
    _min: SavedScanMinAggregateOutputType | null
    _max: SavedScanMaxAggregateOutputType | null
  }

  type GetSavedScanGroupByPayload<T extends SavedScanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedScanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedScanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedScanGroupByOutputType[P]>
            : GetScalarType<T[P], SavedScanGroupByOutputType[P]>
        }
      >
    >


  export type SavedScanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    definition?: boolean
    symbolUniverse?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastRunAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    backtests?: boolean | SavedScan$backtestsArgs<ExtArgs>
    versions?: boolean | SavedScan$versionsArgs<ExtArgs>
    _count?: boolean | SavedScanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedScan"]>

  export type SavedScanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    definition?: boolean
    symbolUniverse?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastRunAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedScan"]>

  export type SavedScanSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    definition?: boolean
    symbolUniverse?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastRunAt?: boolean
  }

  export type SavedScanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    backtests?: boolean | SavedScan$backtestsArgs<ExtArgs>
    versions?: boolean | SavedScan$versionsArgs<ExtArgs>
    _count?: boolean | SavedScanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SavedScanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SavedScanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedScan"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      backtests: Prisma.$BacktestPayload<ExtArgs>[]
      versions: Prisma.$SavedScanVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      definition: Prisma.JsonValue
      symbolUniverse: string[]
      isPublic: boolean
      createdAt: Date
      updatedAt: Date
      lastRunAt: Date | null
    }, ExtArgs["result"]["savedScan"]>
    composites: {}
  }

  type SavedScanGetPayload<S extends boolean | null | undefined | SavedScanDefaultArgs> = $Result.GetResult<Prisma.$SavedScanPayload, S>

  type SavedScanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SavedScanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SavedScanCountAggregateInputType | true
    }

  export interface SavedScanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedScan'], meta: { name: 'SavedScan' } }
    /**
     * Find zero or one SavedScan that matches the filter.
     * @param {SavedScanFindUniqueArgs} args - Arguments to find a SavedScan
     * @example
     * // Get one SavedScan
     * const savedScan = await prisma.savedScan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedScanFindUniqueArgs>(args: SelectSubset<T, SavedScanFindUniqueArgs<ExtArgs>>): Prisma__SavedScanClient<$Result.GetResult<Prisma.$SavedScanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SavedScan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SavedScanFindUniqueOrThrowArgs} args - Arguments to find a SavedScan
     * @example
     * // Get one SavedScan
     * const savedScan = await prisma.savedScan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedScanFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedScanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedScanClient<$Result.GetResult<Prisma.$SavedScanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SavedScan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanFindFirstArgs} args - Arguments to find a SavedScan
     * @example
     * // Get one SavedScan
     * const savedScan = await prisma.savedScan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedScanFindFirstArgs>(args?: SelectSubset<T, SavedScanFindFirstArgs<ExtArgs>>): Prisma__SavedScanClient<$Result.GetResult<Prisma.$SavedScanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SavedScan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanFindFirstOrThrowArgs} args - Arguments to find a SavedScan
     * @example
     * // Get one SavedScan
     * const savedScan = await prisma.savedScan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedScanFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedScanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedScanClient<$Result.GetResult<Prisma.$SavedScanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SavedScans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedScans
     * const savedScans = await prisma.savedScan.findMany()
     * 
     * // Get first 10 SavedScans
     * const savedScans = await prisma.savedScan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedScanWithIdOnly = await prisma.savedScan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedScanFindManyArgs>(args?: SelectSubset<T, SavedScanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedScanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SavedScan.
     * @param {SavedScanCreateArgs} args - Arguments to create a SavedScan.
     * @example
     * // Create one SavedScan
     * const SavedScan = await prisma.savedScan.create({
     *   data: {
     *     // ... data to create a SavedScan
     *   }
     * })
     * 
     */
    create<T extends SavedScanCreateArgs>(args: SelectSubset<T, SavedScanCreateArgs<ExtArgs>>): Prisma__SavedScanClient<$Result.GetResult<Prisma.$SavedScanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SavedScans.
     * @param {SavedScanCreateManyArgs} args - Arguments to create many SavedScans.
     * @example
     * // Create many SavedScans
     * const savedScan = await prisma.savedScan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedScanCreateManyArgs>(args?: SelectSubset<T, SavedScanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedScans and returns the data saved in the database.
     * @param {SavedScanCreateManyAndReturnArgs} args - Arguments to create many SavedScans.
     * @example
     * // Create many SavedScans
     * const savedScan = await prisma.savedScan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedScans and only return the `id`
     * const savedScanWithIdOnly = await prisma.savedScan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedScanCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedScanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedScanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SavedScan.
     * @param {SavedScanDeleteArgs} args - Arguments to delete one SavedScan.
     * @example
     * // Delete one SavedScan
     * const SavedScan = await prisma.savedScan.delete({
     *   where: {
     *     // ... filter to delete one SavedScan
     *   }
     * })
     * 
     */
    delete<T extends SavedScanDeleteArgs>(args: SelectSubset<T, SavedScanDeleteArgs<ExtArgs>>): Prisma__SavedScanClient<$Result.GetResult<Prisma.$SavedScanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SavedScan.
     * @param {SavedScanUpdateArgs} args - Arguments to update one SavedScan.
     * @example
     * // Update one SavedScan
     * const savedScan = await prisma.savedScan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedScanUpdateArgs>(args: SelectSubset<T, SavedScanUpdateArgs<ExtArgs>>): Prisma__SavedScanClient<$Result.GetResult<Prisma.$SavedScanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SavedScans.
     * @param {SavedScanDeleteManyArgs} args - Arguments to filter SavedScans to delete.
     * @example
     * // Delete a few SavedScans
     * const { count } = await prisma.savedScan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedScanDeleteManyArgs>(args?: SelectSubset<T, SavedScanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedScans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedScans
     * const savedScan = await prisma.savedScan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedScanUpdateManyArgs>(args: SelectSubset<T, SavedScanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SavedScan.
     * @param {SavedScanUpsertArgs} args - Arguments to update or create a SavedScan.
     * @example
     * // Update or create a SavedScan
     * const savedScan = await prisma.savedScan.upsert({
     *   create: {
     *     // ... data to create a SavedScan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedScan we want to update
     *   }
     * })
     */
    upsert<T extends SavedScanUpsertArgs>(args: SelectSubset<T, SavedScanUpsertArgs<ExtArgs>>): Prisma__SavedScanClient<$Result.GetResult<Prisma.$SavedScanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SavedScans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanCountArgs} args - Arguments to filter SavedScans to count.
     * @example
     * // Count the number of SavedScans
     * const count = await prisma.savedScan.count({
     *   where: {
     *     // ... the filter for the SavedScans we want to count
     *   }
     * })
    **/
    count<T extends SavedScanCountArgs>(
      args?: Subset<T, SavedScanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedScanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedScan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedScanAggregateArgs>(args: Subset<T, SavedScanAggregateArgs>): Prisma.PrismaPromise<GetSavedScanAggregateType<T>>

    /**
     * Group by SavedScan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedScanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedScanGroupByArgs['orderBy'] }
        : { orderBy?: SavedScanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedScanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedScanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedScan model
   */
  readonly fields: SavedScanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedScan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedScanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    backtests<T extends SavedScan$backtestsArgs<ExtArgs> = {}>(args?: Subset<T, SavedScan$backtestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BacktestPayload<ExtArgs>, T, "findMany"> | Null>
    versions<T extends SavedScan$versionsArgs<ExtArgs> = {}>(args?: Subset<T, SavedScan$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedScanVersionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedScan model
   */ 
  interface SavedScanFieldRefs {
    readonly id: FieldRef<"SavedScan", 'String'>
    readonly userId: FieldRef<"SavedScan", 'String'>
    readonly name: FieldRef<"SavedScan", 'String'>
    readonly description: FieldRef<"SavedScan", 'String'>
    readonly definition: FieldRef<"SavedScan", 'Json'>
    readonly symbolUniverse: FieldRef<"SavedScan", 'String[]'>
    readonly isPublic: FieldRef<"SavedScan", 'Boolean'>
    readonly createdAt: FieldRef<"SavedScan", 'DateTime'>
    readonly updatedAt: FieldRef<"SavedScan", 'DateTime'>
    readonly lastRunAt: FieldRef<"SavedScan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedScan findUnique
   */
  export type SavedScanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScan
     */
    select?: SavedScanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanInclude<ExtArgs> | null
    /**
     * Filter, which SavedScan to fetch.
     */
    where: SavedScanWhereUniqueInput
  }

  /**
   * SavedScan findUniqueOrThrow
   */
  export type SavedScanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScan
     */
    select?: SavedScanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanInclude<ExtArgs> | null
    /**
     * Filter, which SavedScan to fetch.
     */
    where: SavedScanWhereUniqueInput
  }

  /**
   * SavedScan findFirst
   */
  export type SavedScanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScan
     */
    select?: SavedScanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanInclude<ExtArgs> | null
    /**
     * Filter, which SavedScan to fetch.
     */
    where?: SavedScanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedScans to fetch.
     */
    orderBy?: SavedScanOrderByWithRelationInput | SavedScanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedScans.
     */
    cursor?: SavedScanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedScans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedScans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedScans.
     */
    distinct?: SavedScanScalarFieldEnum | SavedScanScalarFieldEnum[]
  }

  /**
   * SavedScan findFirstOrThrow
   */
  export type SavedScanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScan
     */
    select?: SavedScanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanInclude<ExtArgs> | null
    /**
     * Filter, which SavedScan to fetch.
     */
    where?: SavedScanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedScans to fetch.
     */
    orderBy?: SavedScanOrderByWithRelationInput | SavedScanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedScans.
     */
    cursor?: SavedScanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedScans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedScans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedScans.
     */
    distinct?: SavedScanScalarFieldEnum | SavedScanScalarFieldEnum[]
  }

  /**
   * SavedScan findMany
   */
  export type SavedScanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScan
     */
    select?: SavedScanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanInclude<ExtArgs> | null
    /**
     * Filter, which SavedScans to fetch.
     */
    where?: SavedScanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedScans to fetch.
     */
    orderBy?: SavedScanOrderByWithRelationInput | SavedScanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedScans.
     */
    cursor?: SavedScanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedScans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedScans.
     */
    skip?: number
    distinct?: SavedScanScalarFieldEnum | SavedScanScalarFieldEnum[]
  }

  /**
   * SavedScan create
   */
  export type SavedScanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScan
     */
    select?: SavedScanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedScan.
     */
    data: XOR<SavedScanCreateInput, SavedScanUncheckedCreateInput>
  }

  /**
   * SavedScan createMany
   */
  export type SavedScanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedScans.
     */
    data: SavedScanCreateManyInput | SavedScanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedScan createManyAndReturn
   */
  export type SavedScanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScan
     */
    select?: SavedScanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SavedScans.
     */
    data: SavedScanCreateManyInput | SavedScanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedScan update
   */
  export type SavedScanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScan
     */
    select?: SavedScanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedScan.
     */
    data: XOR<SavedScanUpdateInput, SavedScanUncheckedUpdateInput>
    /**
     * Choose, which SavedScan to update.
     */
    where: SavedScanWhereUniqueInput
  }

  /**
   * SavedScan updateMany
   */
  export type SavedScanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedScans.
     */
    data: XOR<SavedScanUpdateManyMutationInput, SavedScanUncheckedUpdateManyInput>
    /**
     * Filter which SavedScans to update
     */
    where?: SavedScanWhereInput
  }

  /**
   * SavedScan upsert
   */
  export type SavedScanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScan
     */
    select?: SavedScanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedScan to update in case it exists.
     */
    where: SavedScanWhereUniqueInput
    /**
     * In case the SavedScan found by the `where` argument doesn't exist, create a new SavedScan with this data.
     */
    create: XOR<SavedScanCreateInput, SavedScanUncheckedCreateInput>
    /**
     * In case the SavedScan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedScanUpdateInput, SavedScanUncheckedUpdateInput>
  }

  /**
   * SavedScan delete
   */
  export type SavedScanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScan
     */
    select?: SavedScanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanInclude<ExtArgs> | null
    /**
     * Filter which SavedScan to delete.
     */
    where: SavedScanWhereUniqueInput
  }

  /**
   * SavedScan deleteMany
   */
  export type SavedScanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedScans to delete
     */
    where?: SavedScanWhereInput
  }

  /**
   * SavedScan.backtests
   */
  export type SavedScan$backtestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backtest
     */
    select?: BacktestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BacktestInclude<ExtArgs> | null
    where?: BacktestWhereInput
    orderBy?: BacktestOrderByWithRelationInput | BacktestOrderByWithRelationInput[]
    cursor?: BacktestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BacktestScalarFieldEnum | BacktestScalarFieldEnum[]
  }

  /**
   * SavedScan.versions
   */
  export type SavedScan$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScanVersion
     */
    select?: SavedScanVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanVersionInclude<ExtArgs> | null
    where?: SavedScanVersionWhereInput
    orderBy?: SavedScanVersionOrderByWithRelationInput | SavedScanVersionOrderByWithRelationInput[]
    cursor?: SavedScanVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedScanVersionScalarFieldEnum | SavedScanVersionScalarFieldEnum[]
  }

  /**
   * SavedScan without action
   */
  export type SavedScanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScan
     */
    select?: SavedScanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanInclude<ExtArgs> | null
  }


  /**
   * Model SavedScanVersion
   */

  export type AggregateSavedScanVersion = {
    _count: SavedScanVersionCountAggregateOutputType | null
    _avg: SavedScanVersionAvgAggregateOutputType | null
    _sum: SavedScanVersionSumAggregateOutputType | null
    _min: SavedScanVersionMinAggregateOutputType | null
    _max: SavedScanVersionMaxAggregateOutputType | null
  }

  export type SavedScanVersionAvgAggregateOutputType = {
    versionNumber: number | null
  }

  export type SavedScanVersionSumAggregateOutputType = {
    versionNumber: number | null
  }

  export type SavedScanVersionMinAggregateOutputType = {
    id: string | null
    savedScanId: string | null
    versionNumber: number | null
    createdAt: Date | null
    createdById: string | null
    comment: string | null
  }

  export type SavedScanVersionMaxAggregateOutputType = {
    id: string | null
    savedScanId: string | null
    versionNumber: number | null
    createdAt: Date | null
    createdById: string | null
    comment: string | null
  }

  export type SavedScanVersionCountAggregateOutputType = {
    id: number
    savedScanId: number
    versionNumber: number
    definition: number
    createdAt: number
    createdById: number
    comment: number
    _all: number
  }


  export type SavedScanVersionAvgAggregateInputType = {
    versionNumber?: true
  }

  export type SavedScanVersionSumAggregateInputType = {
    versionNumber?: true
  }

  export type SavedScanVersionMinAggregateInputType = {
    id?: true
    savedScanId?: true
    versionNumber?: true
    createdAt?: true
    createdById?: true
    comment?: true
  }

  export type SavedScanVersionMaxAggregateInputType = {
    id?: true
    savedScanId?: true
    versionNumber?: true
    createdAt?: true
    createdById?: true
    comment?: true
  }

  export type SavedScanVersionCountAggregateInputType = {
    id?: true
    savedScanId?: true
    versionNumber?: true
    definition?: true
    createdAt?: true
    createdById?: true
    comment?: true
    _all?: true
  }

  export type SavedScanVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedScanVersion to aggregate.
     */
    where?: SavedScanVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedScanVersions to fetch.
     */
    orderBy?: SavedScanVersionOrderByWithRelationInput | SavedScanVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedScanVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedScanVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedScanVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedScanVersions
    **/
    _count?: true | SavedScanVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SavedScanVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SavedScanVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedScanVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedScanVersionMaxAggregateInputType
  }

  export type GetSavedScanVersionAggregateType<T extends SavedScanVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedScanVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedScanVersion[P]>
      : GetScalarType<T[P], AggregateSavedScanVersion[P]>
  }




  export type SavedScanVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedScanVersionWhereInput
    orderBy?: SavedScanVersionOrderByWithAggregationInput | SavedScanVersionOrderByWithAggregationInput[]
    by: SavedScanVersionScalarFieldEnum[] | SavedScanVersionScalarFieldEnum
    having?: SavedScanVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedScanVersionCountAggregateInputType | true
    _avg?: SavedScanVersionAvgAggregateInputType
    _sum?: SavedScanVersionSumAggregateInputType
    _min?: SavedScanVersionMinAggregateInputType
    _max?: SavedScanVersionMaxAggregateInputType
  }

  export type SavedScanVersionGroupByOutputType = {
    id: string
    savedScanId: string
    versionNumber: number
    definition: JsonValue
    createdAt: Date
    createdById: string | null
    comment: string | null
    _count: SavedScanVersionCountAggregateOutputType | null
    _avg: SavedScanVersionAvgAggregateOutputType | null
    _sum: SavedScanVersionSumAggregateOutputType | null
    _min: SavedScanVersionMinAggregateOutputType | null
    _max: SavedScanVersionMaxAggregateOutputType | null
  }

  type GetSavedScanVersionGroupByPayload<T extends SavedScanVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedScanVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedScanVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedScanVersionGroupByOutputType[P]>
            : GetScalarType<T[P], SavedScanVersionGroupByOutputType[P]>
        }
      >
    >


  export type SavedScanVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    savedScanId?: boolean
    versionNumber?: boolean
    definition?: boolean
    createdAt?: boolean
    createdById?: boolean
    comment?: boolean
    savedScan?: boolean | SavedScanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedScanVersion"]>

  export type SavedScanVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    savedScanId?: boolean
    versionNumber?: boolean
    definition?: boolean
    createdAt?: boolean
    createdById?: boolean
    comment?: boolean
    savedScan?: boolean | SavedScanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedScanVersion"]>

  export type SavedScanVersionSelectScalar = {
    id?: boolean
    savedScanId?: boolean
    versionNumber?: boolean
    definition?: boolean
    createdAt?: boolean
    createdById?: boolean
    comment?: boolean
  }

  export type SavedScanVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    savedScan?: boolean | SavedScanDefaultArgs<ExtArgs>
  }
  export type SavedScanVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    savedScan?: boolean | SavedScanDefaultArgs<ExtArgs>
  }

  export type $SavedScanVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedScanVersion"
    objects: {
      savedScan: Prisma.$SavedScanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      savedScanId: string
      versionNumber: number
      definition: Prisma.JsonValue
      createdAt: Date
      createdById: string | null
      comment: string | null
    }, ExtArgs["result"]["savedScanVersion"]>
    composites: {}
  }

  type SavedScanVersionGetPayload<S extends boolean | null | undefined | SavedScanVersionDefaultArgs> = $Result.GetResult<Prisma.$SavedScanVersionPayload, S>

  type SavedScanVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SavedScanVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SavedScanVersionCountAggregateInputType | true
    }

  export interface SavedScanVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedScanVersion'], meta: { name: 'SavedScanVersion' } }
    /**
     * Find zero or one SavedScanVersion that matches the filter.
     * @param {SavedScanVersionFindUniqueArgs} args - Arguments to find a SavedScanVersion
     * @example
     * // Get one SavedScanVersion
     * const savedScanVersion = await prisma.savedScanVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedScanVersionFindUniqueArgs>(args: SelectSubset<T, SavedScanVersionFindUniqueArgs<ExtArgs>>): Prisma__SavedScanVersionClient<$Result.GetResult<Prisma.$SavedScanVersionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SavedScanVersion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SavedScanVersionFindUniqueOrThrowArgs} args - Arguments to find a SavedScanVersion
     * @example
     * // Get one SavedScanVersion
     * const savedScanVersion = await prisma.savedScanVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedScanVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedScanVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedScanVersionClient<$Result.GetResult<Prisma.$SavedScanVersionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SavedScanVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanVersionFindFirstArgs} args - Arguments to find a SavedScanVersion
     * @example
     * // Get one SavedScanVersion
     * const savedScanVersion = await prisma.savedScanVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedScanVersionFindFirstArgs>(args?: SelectSubset<T, SavedScanVersionFindFirstArgs<ExtArgs>>): Prisma__SavedScanVersionClient<$Result.GetResult<Prisma.$SavedScanVersionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SavedScanVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanVersionFindFirstOrThrowArgs} args - Arguments to find a SavedScanVersion
     * @example
     * // Get one SavedScanVersion
     * const savedScanVersion = await prisma.savedScanVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedScanVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedScanVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedScanVersionClient<$Result.GetResult<Prisma.$SavedScanVersionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SavedScanVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedScanVersions
     * const savedScanVersions = await prisma.savedScanVersion.findMany()
     * 
     * // Get first 10 SavedScanVersions
     * const savedScanVersions = await prisma.savedScanVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedScanVersionWithIdOnly = await prisma.savedScanVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedScanVersionFindManyArgs>(args?: SelectSubset<T, SavedScanVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedScanVersionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SavedScanVersion.
     * @param {SavedScanVersionCreateArgs} args - Arguments to create a SavedScanVersion.
     * @example
     * // Create one SavedScanVersion
     * const SavedScanVersion = await prisma.savedScanVersion.create({
     *   data: {
     *     // ... data to create a SavedScanVersion
     *   }
     * })
     * 
     */
    create<T extends SavedScanVersionCreateArgs>(args: SelectSubset<T, SavedScanVersionCreateArgs<ExtArgs>>): Prisma__SavedScanVersionClient<$Result.GetResult<Prisma.$SavedScanVersionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SavedScanVersions.
     * @param {SavedScanVersionCreateManyArgs} args - Arguments to create many SavedScanVersions.
     * @example
     * // Create many SavedScanVersions
     * const savedScanVersion = await prisma.savedScanVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedScanVersionCreateManyArgs>(args?: SelectSubset<T, SavedScanVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedScanVersions and returns the data saved in the database.
     * @param {SavedScanVersionCreateManyAndReturnArgs} args - Arguments to create many SavedScanVersions.
     * @example
     * // Create many SavedScanVersions
     * const savedScanVersion = await prisma.savedScanVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedScanVersions and only return the `id`
     * const savedScanVersionWithIdOnly = await prisma.savedScanVersion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedScanVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedScanVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedScanVersionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SavedScanVersion.
     * @param {SavedScanVersionDeleteArgs} args - Arguments to delete one SavedScanVersion.
     * @example
     * // Delete one SavedScanVersion
     * const SavedScanVersion = await prisma.savedScanVersion.delete({
     *   where: {
     *     // ... filter to delete one SavedScanVersion
     *   }
     * })
     * 
     */
    delete<T extends SavedScanVersionDeleteArgs>(args: SelectSubset<T, SavedScanVersionDeleteArgs<ExtArgs>>): Prisma__SavedScanVersionClient<$Result.GetResult<Prisma.$SavedScanVersionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SavedScanVersion.
     * @param {SavedScanVersionUpdateArgs} args - Arguments to update one SavedScanVersion.
     * @example
     * // Update one SavedScanVersion
     * const savedScanVersion = await prisma.savedScanVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedScanVersionUpdateArgs>(args: SelectSubset<T, SavedScanVersionUpdateArgs<ExtArgs>>): Prisma__SavedScanVersionClient<$Result.GetResult<Prisma.$SavedScanVersionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SavedScanVersions.
     * @param {SavedScanVersionDeleteManyArgs} args - Arguments to filter SavedScanVersions to delete.
     * @example
     * // Delete a few SavedScanVersions
     * const { count } = await prisma.savedScanVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedScanVersionDeleteManyArgs>(args?: SelectSubset<T, SavedScanVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedScanVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedScanVersions
     * const savedScanVersion = await prisma.savedScanVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedScanVersionUpdateManyArgs>(args: SelectSubset<T, SavedScanVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SavedScanVersion.
     * @param {SavedScanVersionUpsertArgs} args - Arguments to update or create a SavedScanVersion.
     * @example
     * // Update or create a SavedScanVersion
     * const savedScanVersion = await prisma.savedScanVersion.upsert({
     *   create: {
     *     // ... data to create a SavedScanVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedScanVersion we want to update
     *   }
     * })
     */
    upsert<T extends SavedScanVersionUpsertArgs>(args: SelectSubset<T, SavedScanVersionUpsertArgs<ExtArgs>>): Prisma__SavedScanVersionClient<$Result.GetResult<Prisma.$SavedScanVersionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SavedScanVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanVersionCountArgs} args - Arguments to filter SavedScanVersions to count.
     * @example
     * // Count the number of SavedScanVersions
     * const count = await prisma.savedScanVersion.count({
     *   where: {
     *     // ... the filter for the SavedScanVersions we want to count
     *   }
     * })
    **/
    count<T extends SavedScanVersionCountArgs>(
      args?: Subset<T, SavedScanVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedScanVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedScanVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedScanVersionAggregateArgs>(args: Subset<T, SavedScanVersionAggregateArgs>): Prisma.PrismaPromise<GetSavedScanVersionAggregateType<T>>

    /**
     * Group by SavedScanVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedScanVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedScanVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedScanVersionGroupByArgs['orderBy'] }
        : { orderBy?: SavedScanVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedScanVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedScanVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedScanVersion model
   */
  readonly fields: SavedScanVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedScanVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedScanVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    savedScan<T extends SavedScanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SavedScanDefaultArgs<ExtArgs>>): Prisma__SavedScanClient<$Result.GetResult<Prisma.$SavedScanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedScanVersion model
   */ 
  interface SavedScanVersionFieldRefs {
    readonly id: FieldRef<"SavedScanVersion", 'String'>
    readonly savedScanId: FieldRef<"SavedScanVersion", 'String'>
    readonly versionNumber: FieldRef<"SavedScanVersion", 'Int'>
    readonly definition: FieldRef<"SavedScanVersion", 'Json'>
    readonly createdAt: FieldRef<"SavedScanVersion", 'DateTime'>
    readonly createdById: FieldRef<"SavedScanVersion", 'String'>
    readonly comment: FieldRef<"SavedScanVersion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SavedScanVersion findUnique
   */
  export type SavedScanVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScanVersion
     */
    select?: SavedScanVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanVersionInclude<ExtArgs> | null
    /**
     * Filter, which SavedScanVersion to fetch.
     */
    where: SavedScanVersionWhereUniqueInput
  }

  /**
   * SavedScanVersion findUniqueOrThrow
   */
  export type SavedScanVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScanVersion
     */
    select?: SavedScanVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanVersionInclude<ExtArgs> | null
    /**
     * Filter, which SavedScanVersion to fetch.
     */
    where: SavedScanVersionWhereUniqueInput
  }

  /**
   * SavedScanVersion findFirst
   */
  export type SavedScanVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScanVersion
     */
    select?: SavedScanVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanVersionInclude<ExtArgs> | null
    /**
     * Filter, which SavedScanVersion to fetch.
     */
    where?: SavedScanVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedScanVersions to fetch.
     */
    orderBy?: SavedScanVersionOrderByWithRelationInput | SavedScanVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedScanVersions.
     */
    cursor?: SavedScanVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedScanVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedScanVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedScanVersions.
     */
    distinct?: SavedScanVersionScalarFieldEnum | SavedScanVersionScalarFieldEnum[]
  }

  /**
   * SavedScanVersion findFirstOrThrow
   */
  export type SavedScanVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScanVersion
     */
    select?: SavedScanVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanVersionInclude<ExtArgs> | null
    /**
     * Filter, which SavedScanVersion to fetch.
     */
    where?: SavedScanVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedScanVersions to fetch.
     */
    orderBy?: SavedScanVersionOrderByWithRelationInput | SavedScanVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedScanVersions.
     */
    cursor?: SavedScanVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedScanVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedScanVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedScanVersions.
     */
    distinct?: SavedScanVersionScalarFieldEnum | SavedScanVersionScalarFieldEnum[]
  }

  /**
   * SavedScanVersion findMany
   */
  export type SavedScanVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScanVersion
     */
    select?: SavedScanVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanVersionInclude<ExtArgs> | null
    /**
     * Filter, which SavedScanVersions to fetch.
     */
    where?: SavedScanVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedScanVersions to fetch.
     */
    orderBy?: SavedScanVersionOrderByWithRelationInput | SavedScanVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedScanVersions.
     */
    cursor?: SavedScanVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedScanVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedScanVersions.
     */
    skip?: number
    distinct?: SavedScanVersionScalarFieldEnum | SavedScanVersionScalarFieldEnum[]
  }

  /**
   * SavedScanVersion create
   */
  export type SavedScanVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScanVersion
     */
    select?: SavedScanVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedScanVersion.
     */
    data: XOR<SavedScanVersionCreateInput, SavedScanVersionUncheckedCreateInput>
  }

  /**
   * SavedScanVersion createMany
   */
  export type SavedScanVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedScanVersions.
     */
    data: SavedScanVersionCreateManyInput | SavedScanVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedScanVersion createManyAndReturn
   */
  export type SavedScanVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScanVersion
     */
    select?: SavedScanVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SavedScanVersions.
     */
    data: SavedScanVersionCreateManyInput | SavedScanVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedScanVersion update
   */
  export type SavedScanVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScanVersion
     */
    select?: SavedScanVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedScanVersion.
     */
    data: XOR<SavedScanVersionUpdateInput, SavedScanVersionUncheckedUpdateInput>
    /**
     * Choose, which SavedScanVersion to update.
     */
    where: SavedScanVersionWhereUniqueInput
  }

  /**
   * SavedScanVersion updateMany
   */
  export type SavedScanVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedScanVersions.
     */
    data: XOR<SavedScanVersionUpdateManyMutationInput, SavedScanVersionUncheckedUpdateManyInput>
    /**
     * Filter which SavedScanVersions to update
     */
    where?: SavedScanVersionWhereInput
  }

  /**
   * SavedScanVersion upsert
   */
  export type SavedScanVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScanVersion
     */
    select?: SavedScanVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedScanVersion to update in case it exists.
     */
    where: SavedScanVersionWhereUniqueInput
    /**
     * In case the SavedScanVersion found by the `where` argument doesn't exist, create a new SavedScanVersion with this data.
     */
    create: XOR<SavedScanVersionCreateInput, SavedScanVersionUncheckedCreateInput>
    /**
     * In case the SavedScanVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedScanVersionUpdateInput, SavedScanVersionUncheckedUpdateInput>
  }

  /**
   * SavedScanVersion delete
   */
  export type SavedScanVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScanVersion
     */
    select?: SavedScanVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanVersionInclude<ExtArgs> | null
    /**
     * Filter which SavedScanVersion to delete.
     */
    where: SavedScanVersionWhereUniqueInput
  }

  /**
   * SavedScanVersion deleteMany
   */
  export type SavedScanVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedScanVersions to delete
     */
    where?: SavedScanVersionWhereInput
  }

  /**
   * SavedScanVersion without action
   */
  export type SavedScanVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScanVersion
     */
    select?: SavedScanVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanVersionInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    alertType: $Enums.AlertType | null
    ticker: string | null
    status: $Enums.AlertStatus | null
    emailNotify: boolean | null
    pushNotify: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    triggeredAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    alertType: $Enums.AlertType | null
    ticker: string | null
    status: $Enums.AlertStatus | null
    emailNotify: boolean | null
    pushNotify: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    triggeredAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    alertType: number
    condition: number
    ticker: number
    status: number
    emailNotify: number
    pushNotify: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    triggeredAt: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    alertType?: true
    ticker?: true
    status?: true
    emailNotify?: true
    pushNotify?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    triggeredAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    alertType?: true
    ticker?: true
    status?: true
    emailNotify?: true
    pushNotify?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    triggeredAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    alertType?: true
    condition?: true
    ticker?: true
    status?: true
    emailNotify?: true
    pushNotify?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    triggeredAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    userId: string
    name: string
    alertType: $Enums.AlertType
    condition: JsonValue
    ticker: string | null
    status: $Enums.AlertStatus
    emailNotify: boolean
    pushNotify: boolean
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    triggeredAt: Date | null
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    alertType?: boolean
    condition?: boolean
    ticker?: boolean
    status?: boolean
    emailNotify?: boolean
    pushNotify?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    triggeredAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    alertType?: boolean
    condition?: boolean
    ticker?: boolean
    status?: boolean
    emailNotify?: boolean
    pushNotify?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    triggeredAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    alertType?: boolean
    condition?: boolean
    ticker?: boolean
    status?: boolean
    emailNotify?: boolean
    pushNotify?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    triggeredAt?: boolean
  }

  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      alertType: $Enums.AlertType
      condition: Prisma.JsonValue
      ticker: string | null
      status: $Enums.AlertStatus
      emailNotify: boolean
      pushNotify: boolean
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
      triggeredAt: Date | null
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */ 
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly userId: FieldRef<"Alert", 'String'>
    readonly name: FieldRef<"Alert", 'String'>
    readonly alertType: FieldRef<"Alert", 'AlertType'>
    readonly condition: FieldRef<"Alert", 'Json'>
    readonly ticker: FieldRef<"Alert", 'String'>
    readonly status: FieldRef<"Alert", 'AlertStatus'>
    readonly emailNotify: FieldRef<"Alert", 'Boolean'>
    readonly pushNotify: FieldRef<"Alert", 'Boolean'>
    readonly expiresAt: FieldRef<"Alert", 'DateTime'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
    readonly updatedAt: FieldRef<"Alert", 'DateTime'>
    readonly triggeredAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model Backtest
   */

  export type AggregateBacktest = {
    _count: BacktestCountAggregateOutputType | null
    _avg: BacktestAvgAggregateOutputType | null
    _sum: BacktestSumAggregateOutputType | null
    _min: BacktestMinAggregateOutputType | null
    _max: BacktestMaxAggregateOutputType | null
  }

  export type BacktestAvgAggregateOutputType = {
    totalMatches: number | null
    avgReturn: Decimal | null
    winRate: Decimal | null
  }

  export type BacktestSumAggregateOutputType = {
    totalMatches: number | null
    avgReturn: Decimal | null
    winRate: Decimal | null
  }

  export type BacktestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    savedScanId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    timeframe: $Enums.Timeframe | null
    status: $Enums.BacktestStatus | null
    totalMatches: number | null
    avgReturn: Decimal | null
    winRate: Decimal | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type BacktestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    savedScanId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    timeframe: $Enums.Timeframe | null
    status: $Enums.BacktestStatus | null
    totalMatches: number | null
    avgReturn: Decimal | null
    winRate: Decimal | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type BacktestCountAggregateOutputType = {
    id: number
    userId: number
    savedScanId: number
    name: number
    startDate: number
    endDate: number
    timeframe: number
    definition: number
    status: number
    results: number
    totalMatches: number
    avgReturn: number
    winRate: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type BacktestAvgAggregateInputType = {
    totalMatches?: true
    avgReturn?: true
    winRate?: true
  }

  export type BacktestSumAggregateInputType = {
    totalMatches?: true
    avgReturn?: true
    winRate?: true
  }

  export type BacktestMinAggregateInputType = {
    id?: true
    userId?: true
    savedScanId?: true
    name?: true
    startDate?: true
    endDate?: true
    timeframe?: true
    status?: true
    totalMatches?: true
    avgReturn?: true
    winRate?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type BacktestMaxAggregateInputType = {
    id?: true
    userId?: true
    savedScanId?: true
    name?: true
    startDate?: true
    endDate?: true
    timeframe?: true
    status?: true
    totalMatches?: true
    avgReturn?: true
    winRate?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type BacktestCountAggregateInputType = {
    id?: true
    userId?: true
    savedScanId?: true
    name?: true
    startDate?: true
    endDate?: true
    timeframe?: true
    definition?: true
    status?: true
    results?: true
    totalMatches?: true
    avgReturn?: true
    winRate?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type BacktestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Backtest to aggregate.
     */
    where?: BacktestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backtests to fetch.
     */
    orderBy?: BacktestOrderByWithRelationInput | BacktestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BacktestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backtests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backtests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Backtests
    **/
    _count?: true | BacktestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BacktestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BacktestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BacktestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BacktestMaxAggregateInputType
  }

  export type GetBacktestAggregateType<T extends BacktestAggregateArgs> = {
        [P in keyof T & keyof AggregateBacktest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBacktest[P]>
      : GetScalarType<T[P], AggregateBacktest[P]>
  }




  export type BacktestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BacktestWhereInput
    orderBy?: BacktestOrderByWithAggregationInput | BacktestOrderByWithAggregationInput[]
    by: BacktestScalarFieldEnum[] | BacktestScalarFieldEnum
    having?: BacktestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BacktestCountAggregateInputType | true
    _avg?: BacktestAvgAggregateInputType
    _sum?: BacktestSumAggregateInputType
    _min?: BacktestMinAggregateInputType
    _max?: BacktestMaxAggregateInputType
  }

  export type BacktestGroupByOutputType = {
    id: string
    userId: string
    savedScanId: string | null
    name: string
    startDate: Date
    endDate: Date
    timeframe: $Enums.Timeframe
    definition: JsonValue
    status: $Enums.BacktestStatus
    results: JsonValue | null
    totalMatches: number | null
    avgReturn: Decimal | null
    winRate: Decimal | null
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    startedAt: Date | null
    completedAt: Date | null
    _count: BacktestCountAggregateOutputType | null
    _avg: BacktestAvgAggregateOutputType | null
    _sum: BacktestSumAggregateOutputType | null
    _min: BacktestMinAggregateOutputType | null
    _max: BacktestMaxAggregateOutputType | null
  }

  type GetBacktestGroupByPayload<T extends BacktestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BacktestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BacktestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BacktestGroupByOutputType[P]>
            : GetScalarType<T[P], BacktestGroupByOutputType[P]>
        }
      >
    >


  export type BacktestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    savedScanId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    timeframe?: boolean
    definition?: boolean
    status?: boolean
    results?: boolean
    totalMatches?: boolean
    avgReturn?: boolean
    winRate?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    savedScan?: boolean | Backtest$savedScanArgs<ExtArgs>
  }, ExtArgs["result"]["backtest"]>

  export type BacktestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    savedScanId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    timeframe?: boolean
    definition?: boolean
    status?: boolean
    results?: boolean
    totalMatches?: boolean
    avgReturn?: boolean
    winRate?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    savedScan?: boolean | Backtest$savedScanArgs<ExtArgs>
  }, ExtArgs["result"]["backtest"]>

  export type BacktestSelectScalar = {
    id?: boolean
    userId?: boolean
    savedScanId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    timeframe?: boolean
    definition?: boolean
    status?: boolean
    results?: boolean
    totalMatches?: boolean
    avgReturn?: boolean
    winRate?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type BacktestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    savedScan?: boolean | Backtest$savedScanArgs<ExtArgs>
  }
  export type BacktestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    savedScan?: boolean | Backtest$savedScanArgs<ExtArgs>
  }

  export type $BacktestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Backtest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      savedScan: Prisma.$SavedScanPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      savedScanId: string | null
      name: string
      startDate: Date
      endDate: Date
      timeframe: $Enums.Timeframe
      definition: Prisma.JsonValue
      status: $Enums.BacktestStatus
      results: Prisma.JsonValue | null
      totalMatches: number | null
      avgReturn: Prisma.Decimal | null
      winRate: Prisma.Decimal | null
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
      startedAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["backtest"]>
    composites: {}
  }

  type BacktestGetPayload<S extends boolean | null | undefined | BacktestDefaultArgs> = $Result.GetResult<Prisma.$BacktestPayload, S>

  type BacktestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BacktestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BacktestCountAggregateInputType | true
    }

  export interface BacktestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Backtest'], meta: { name: 'Backtest' } }
    /**
     * Find zero or one Backtest that matches the filter.
     * @param {BacktestFindUniqueArgs} args - Arguments to find a Backtest
     * @example
     * // Get one Backtest
     * const backtest = await prisma.backtest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BacktestFindUniqueArgs>(args: SelectSubset<T, BacktestFindUniqueArgs<ExtArgs>>): Prisma__BacktestClient<$Result.GetResult<Prisma.$BacktestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Backtest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BacktestFindUniqueOrThrowArgs} args - Arguments to find a Backtest
     * @example
     * // Get one Backtest
     * const backtest = await prisma.backtest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BacktestFindUniqueOrThrowArgs>(args: SelectSubset<T, BacktestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BacktestClient<$Result.GetResult<Prisma.$BacktestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Backtest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BacktestFindFirstArgs} args - Arguments to find a Backtest
     * @example
     * // Get one Backtest
     * const backtest = await prisma.backtest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BacktestFindFirstArgs>(args?: SelectSubset<T, BacktestFindFirstArgs<ExtArgs>>): Prisma__BacktestClient<$Result.GetResult<Prisma.$BacktestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Backtest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BacktestFindFirstOrThrowArgs} args - Arguments to find a Backtest
     * @example
     * // Get one Backtest
     * const backtest = await prisma.backtest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BacktestFindFirstOrThrowArgs>(args?: SelectSubset<T, BacktestFindFirstOrThrowArgs<ExtArgs>>): Prisma__BacktestClient<$Result.GetResult<Prisma.$BacktestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Backtests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BacktestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Backtests
     * const backtests = await prisma.backtest.findMany()
     * 
     * // Get first 10 Backtests
     * const backtests = await prisma.backtest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backtestWithIdOnly = await prisma.backtest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BacktestFindManyArgs>(args?: SelectSubset<T, BacktestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BacktestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Backtest.
     * @param {BacktestCreateArgs} args - Arguments to create a Backtest.
     * @example
     * // Create one Backtest
     * const Backtest = await prisma.backtest.create({
     *   data: {
     *     // ... data to create a Backtest
     *   }
     * })
     * 
     */
    create<T extends BacktestCreateArgs>(args: SelectSubset<T, BacktestCreateArgs<ExtArgs>>): Prisma__BacktestClient<$Result.GetResult<Prisma.$BacktestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Backtests.
     * @param {BacktestCreateManyArgs} args - Arguments to create many Backtests.
     * @example
     * // Create many Backtests
     * const backtest = await prisma.backtest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BacktestCreateManyArgs>(args?: SelectSubset<T, BacktestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Backtests and returns the data saved in the database.
     * @param {BacktestCreateManyAndReturnArgs} args - Arguments to create many Backtests.
     * @example
     * // Create many Backtests
     * const backtest = await prisma.backtest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Backtests and only return the `id`
     * const backtestWithIdOnly = await prisma.backtest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BacktestCreateManyAndReturnArgs>(args?: SelectSubset<T, BacktestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BacktestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Backtest.
     * @param {BacktestDeleteArgs} args - Arguments to delete one Backtest.
     * @example
     * // Delete one Backtest
     * const Backtest = await prisma.backtest.delete({
     *   where: {
     *     // ... filter to delete one Backtest
     *   }
     * })
     * 
     */
    delete<T extends BacktestDeleteArgs>(args: SelectSubset<T, BacktestDeleteArgs<ExtArgs>>): Prisma__BacktestClient<$Result.GetResult<Prisma.$BacktestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Backtest.
     * @param {BacktestUpdateArgs} args - Arguments to update one Backtest.
     * @example
     * // Update one Backtest
     * const backtest = await prisma.backtest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BacktestUpdateArgs>(args: SelectSubset<T, BacktestUpdateArgs<ExtArgs>>): Prisma__BacktestClient<$Result.GetResult<Prisma.$BacktestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Backtests.
     * @param {BacktestDeleteManyArgs} args - Arguments to filter Backtests to delete.
     * @example
     * // Delete a few Backtests
     * const { count } = await prisma.backtest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BacktestDeleteManyArgs>(args?: SelectSubset<T, BacktestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Backtests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BacktestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Backtests
     * const backtest = await prisma.backtest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BacktestUpdateManyArgs>(args: SelectSubset<T, BacktestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Backtest.
     * @param {BacktestUpsertArgs} args - Arguments to update or create a Backtest.
     * @example
     * // Update or create a Backtest
     * const backtest = await prisma.backtest.upsert({
     *   create: {
     *     // ... data to create a Backtest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Backtest we want to update
     *   }
     * })
     */
    upsert<T extends BacktestUpsertArgs>(args: SelectSubset<T, BacktestUpsertArgs<ExtArgs>>): Prisma__BacktestClient<$Result.GetResult<Prisma.$BacktestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Backtests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BacktestCountArgs} args - Arguments to filter Backtests to count.
     * @example
     * // Count the number of Backtests
     * const count = await prisma.backtest.count({
     *   where: {
     *     // ... the filter for the Backtests we want to count
     *   }
     * })
    **/
    count<T extends BacktestCountArgs>(
      args?: Subset<T, BacktestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BacktestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Backtest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BacktestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BacktestAggregateArgs>(args: Subset<T, BacktestAggregateArgs>): Prisma.PrismaPromise<GetBacktestAggregateType<T>>

    /**
     * Group by Backtest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BacktestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BacktestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BacktestGroupByArgs['orderBy'] }
        : { orderBy?: BacktestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BacktestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBacktestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Backtest model
   */
  readonly fields: BacktestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Backtest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BacktestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    savedScan<T extends Backtest$savedScanArgs<ExtArgs> = {}>(args?: Subset<T, Backtest$savedScanArgs<ExtArgs>>): Prisma__SavedScanClient<$Result.GetResult<Prisma.$SavedScanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Backtest model
   */ 
  interface BacktestFieldRefs {
    readonly id: FieldRef<"Backtest", 'String'>
    readonly userId: FieldRef<"Backtest", 'String'>
    readonly savedScanId: FieldRef<"Backtest", 'String'>
    readonly name: FieldRef<"Backtest", 'String'>
    readonly startDate: FieldRef<"Backtest", 'DateTime'>
    readonly endDate: FieldRef<"Backtest", 'DateTime'>
    readonly timeframe: FieldRef<"Backtest", 'Timeframe'>
    readonly definition: FieldRef<"Backtest", 'Json'>
    readonly status: FieldRef<"Backtest", 'BacktestStatus'>
    readonly results: FieldRef<"Backtest", 'Json'>
    readonly totalMatches: FieldRef<"Backtest", 'Int'>
    readonly avgReturn: FieldRef<"Backtest", 'Decimal'>
    readonly winRate: FieldRef<"Backtest", 'Decimal'>
    readonly errorMessage: FieldRef<"Backtest", 'String'>
    readonly createdAt: FieldRef<"Backtest", 'DateTime'>
    readonly updatedAt: FieldRef<"Backtest", 'DateTime'>
    readonly startedAt: FieldRef<"Backtest", 'DateTime'>
    readonly completedAt: FieldRef<"Backtest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Backtest findUnique
   */
  export type BacktestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backtest
     */
    select?: BacktestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BacktestInclude<ExtArgs> | null
    /**
     * Filter, which Backtest to fetch.
     */
    where: BacktestWhereUniqueInput
  }

  /**
   * Backtest findUniqueOrThrow
   */
  export type BacktestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backtest
     */
    select?: BacktestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BacktestInclude<ExtArgs> | null
    /**
     * Filter, which Backtest to fetch.
     */
    where: BacktestWhereUniqueInput
  }

  /**
   * Backtest findFirst
   */
  export type BacktestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backtest
     */
    select?: BacktestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BacktestInclude<ExtArgs> | null
    /**
     * Filter, which Backtest to fetch.
     */
    where?: BacktestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backtests to fetch.
     */
    orderBy?: BacktestOrderByWithRelationInput | BacktestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Backtests.
     */
    cursor?: BacktestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backtests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backtests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Backtests.
     */
    distinct?: BacktestScalarFieldEnum | BacktestScalarFieldEnum[]
  }

  /**
   * Backtest findFirstOrThrow
   */
  export type BacktestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backtest
     */
    select?: BacktestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BacktestInclude<ExtArgs> | null
    /**
     * Filter, which Backtest to fetch.
     */
    where?: BacktestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backtests to fetch.
     */
    orderBy?: BacktestOrderByWithRelationInput | BacktestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Backtests.
     */
    cursor?: BacktestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backtests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backtests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Backtests.
     */
    distinct?: BacktestScalarFieldEnum | BacktestScalarFieldEnum[]
  }

  /**
   * Backtest findMany
   */
  export type BacktestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backtest
     */
    select?: BacktestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BacktestInclude<ExtArgs> | null
    /**
     * Filter, which Backtests to fetch.
     */
    where?: BacktestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backtests to fetch.
     */
    orderBy?: BacktestOrderByWithRelationInput | BacktestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Backtests.
     */
    cursor?: BacktestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backtests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backtests.
     */
    skip?: number
    distinct?: BacktestScalarFieldEnum | BacktestScalarFieldEnum[]
  }

  /**
   * Backtest create
   */
  export type BacktestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backtest
     */
    select?: BacktestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BacktestInclude<ExtArgs> | null
    /**
     * The data needed to create a Backtest.
     */
    data: XOR<BacktestCreateInput, BacktestUncheckedCreateInput>
  }

  /**
   * Backtest createMany
   */
  export type BacktestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Backtests.
     */
    data: BacktestCreateManyInput | BacktestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Backtest createManyAndReturn
   */
  export type BacktestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backtest
     */
    select?: BacktestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Backtests.
     */
    data: BacktestCreateManyInput | BacktestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BacktestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Backtest update
   */
  export type BacktestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backtest
     */
    select?: BacktestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BacktestInclude<ExtArgs> | null
    /**
     * The data needed to update a Backtest.
     */
    data: XOR<BacktestUpdateInput, BacktestUncheckedUpdateInput>
    /**
     * Choose, which Backtest to update.
     */
    where: BacktestWhereUniqueInput
  }

  /**
   * Backtest updateMany
   */
  export type BacktestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Backtests.
     */
    data: XOR<BacktestUpdateManyMutationInput, BacktestUncheckedUpdateManyInput>
    /**
     * Filter which Backtests to update
     */
    where?: BacktestWhereInput
  }

  /**
   * Backtest upsert
   */
  export type BacktestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backtest
     */
    select?: BacktestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BacktestInclude<ExtArgs> | null
    /**
     * The filter to search for the Backtest to update in case it exists.
     */
    where: BacktestWhereUniqueInput
    /**
     * In case the Backtest found by the `where` argument doesn't exist, create a new Backtest with this data.
     */
    create: XOR<BacktestCreateInput, BacktestUncheckedCreateInput>
    /**
     * In case the Backtest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BacktestUpdateInput, BacktestUncheckedUpdateInput>
  }

  /**
   * Backtest delete
   */
  export type BacktestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backtest
     */
    select?: BacktestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BacktestInclude<ExtArgs> | null
    /**
     * Filter which Backtest to delete.
     */
    where: BacktestWhereUniqueInput
  }

  /**
   * Backtest deleteMany
   */
  export type BacktestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Backtests to delete
     */
    where?: BacktestWhereInput
  }

  /**
   * Backtest.savedScan
   */
  export type Backtest$savedScanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedScan
     */
    select?: SavedScanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedScanInclude<ExtArgs> | null
    where?: SavedScanWhereInput
  }

  /**
   * Backtest without action
   */
  export type BacktestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backtest
     */
    select?: BacktestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BacktestInclude<ExtArgs> | null
  }


  /**
   * Model FinancialMetric
   */

  export type AggregateFinancialMetric = {
    _count: FinancialMetricCountAggregateOutputType | null
    _min: FinancialMetricMinAggregateOutputType | null
    _max: FinancialMetricMaxAggregateOutputType | null
  }

  export type FinancialMetricMinAggregateOutputType = {
    id: string | null
    symbolId: string | null
    fetchedAt: Date | null
  }

  export type FinancialMetricMaxAggregateOutputType = {
    id: string | null
    symbolId: string | null
    fetchedAt: Date | null
  }

  export type FinancialMetricCountAggregateOutputType = {
    id: number
    symbolId: number
    metric: number
    fetchedAt: number
    _all: number
  }


  export type FinancialMetricMinAggregateInputType = {
    id?: true
    symbolId?: true
    fetchedAt?: true
  }

  export type FinancialMetricMaxAggregateInputType = {
    id?: true
    symbolId?: true
    fetchedAt?: true
  }

  export type FinancialMetricCountAggregateInputType = {
    id?: true
    symbolId?: true
    metric?: true
    fetchedAt?: true
    _all?: true
  }

  export type FinancialMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialMetric to aggregate.
     */
    where?: FinancialMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialMetrics to fetch.
     */
    orderBy?: FinancialMetricOrderByWithRelationInput | FinancialMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialMetrics
    **/
    _count?: true | FinancialMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialMetricMaxAggregateInputType
  }

  export type GetFinancialMetricAggregateType<T extends FinancialMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialMetric[P]>
      : GetScalarType<T[P], AggregateFinancialMetric[P]>
  }




  export type FinancialMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialMetricWhereInput
    orderBy?: FinancialMetricOrderByWithAggregationInput | FinancialMetricOrderByWithAggregationInput[]
    by: FinancialMetricScalarFieldEnum[] | FinancialMetricScalarFieldEnum
    having?: FinancialMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialMetricCountAggregateInputType | true
    _min?: FinancialMetricMinAggregateInputType
    _max?: FinancialMetricMaxAggregateInputType
  }

  export type FinancialMetricGroupByOutputType = {
    id: string
    symbolId: string
    metric: JsonValue
    fetchedAt: Date
    _count: FinancialMetricCountAggregateOutputType | null
    _min: FinancialMetricMinAggregateOutputType | null
    _max: FinancialMetricMaxAggregateOutputType | null
  }

  type GetFinancialMetricGroupByPayload<T extends FinancialMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialMetricGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialMetricGroupByOutputType[P]>
        }
      >
    >


  export type FinancialMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbolId?: boolean
    metric?: boolean
    fetchedAt?: boolean
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialMetric"]>

  export type FinancialMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbolId?: boolean
    metric?: boolean
    fetchedAt?: boolean
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialMetric"]>

  export type FinancialMetricSelectScalar = {
    id?: boolean
    symbolId?: boolean
    metric?: boolean
    fetchedAt?: boolean
  }

  export type FinancialMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }
  export type FinancialMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    symbol?: boolean | SymbolDefaultArgs<ExtArgs>
  }

  export type $FinancialMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialMetric"
    objects: {
      symbol: Prisma.$SymbolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      symbolId: string
      metric: Prisma.JsonValue
      fetchedAt: Date
    }, ExtArgs["result"]["financialMetric"]>
    composites: {}
  }

  type FinancialMetricGetPayload<S extends boolean | null | undefined | FinancialMetricDefaultArgs> = $Result.GetResult<Prisma.$FinancialMetricPayload, S>

  type FinancialMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FinancialMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FinancialMetricCountAggregateInputType | true
    }

  export interface FinancialMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialMetric'], meta: { name: 'FinancialMetric' } }
    /**
     * Find zero or one FinancialMetric that matches the filter.
     * @param {FinancialMetricFindUniqueArgs} args - Arguments to find a FinancialMetric
     * @example
     * // Get one FinancialMetric
     * const financialMetric = await prisma.financialMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialMetricFindUniqueArgs>(args: SelectSubset<T, FinancialMetricFindUniqueArgs<ExtArgs>>): Prisma__FinancialMetricClient<$Result.GetResult<Prisma.$FinancialMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FinancialMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FinancialMetricFindUniqueOrThrowArgs} args - Arguments to find a FinancialMetric
     * @example
     * // Get one FinancialMetric
     * const financialMetric = await prisma.financialMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialMetricClient<$Result.GetResult<Prisma.$FinancialMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FinancialMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialMetricFindFirstArgs} args - Arguments to find a FinancialMetric
     * @example
     * // Get one FinancialMetric
     * const financialMetric = await prisma.financialMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialMetricFindFirstArgs>(args?: SelectSubset<T, FinancialMetricFindFirstArgs<ExtArgs>>): Prisma__FinancialMetricClient<$Result.GetResult<Prisma.$FinancialMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FinancialMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialMetricFindFirstOrThrowArgs} args - Arguments to find a FinancialMetric
     * @example
     * // Get one FinancialMetric
     * const financialMetric = await prisma.financialMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialMetricClient<$Result.GetResult<Prisma.$FinancialMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FinancialMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialMetrics
     * const financialMetrics = await prisma.financialMetric.findMany()
     * 
     * // Get first 10 FinancialMetrics
     * const financialMetrics = await prisma.financialMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialMetricWithIdOnly = await prisma.financialMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialMetricFindManyArgs>(args?: SelectSubset<T, FinancialMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FinancialMetric.
     * @param {FinancialMetricCreateArgs} args - Arguments to create a FinancialMetric.
     * @example
     * // Create one FinancialMetric
     * const FinancialMetric = await prisma.financialMetric.create({
     *   data: {
     *     // ... data to create a FinancialMetric
     *   }
     * })
     * 
     */
    create<T extends FinancialMetricCreateArgs>(args: SelectSubset<T, FinancialMetricCreateArgs<ExtArgs>>): Prisma__FinancialMetricClient<$Result.GetResult<Prisma.$FinancialMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FinancialMetrics.
     * @param {FinancialMetricCreateManyArgs} args - Arguments to create many FinancialMetrics.
     * @example
     * // Create many FinancialMetrics
     * const financialMetric = await prisma.financialMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialMetricCreateManyArgs>(args?: SelectSubset<T, FinancialMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialMetrics and returns the data saved in the database.
     * @param {FinancialMetricCreateManyAndReturnArgs} args - Arguments to create many FinancialMetrics.
     * @example
     * // Create many FinancialMetrics
     * const financialMetric = await prisma.financialMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialMetrics and only return the `id`
     * const financialMetricWithIdOnly = await prisma.financialMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FinancialMetric.
     * @param {FinancialMetricDeleteArgs} args - Arguments to delete one FinancialMetric.
     * @example
     * // Delete one FinancialMetric
     * const FinancialMetric = await prisma.financialMetric.delete({
     *   where: {
     *     // ... filter to delete one FinancialMetric
     *   }
     * })
     * 
     */
    delete<T extends FinancialMetricDeleteArgs>(args: SelectSubset<T, FinancialMetricDeleteArgs<ExtArgs>>): Prisma__FinancialMetricClient<$Result.GetResult<Prisma.$FinancialMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FinancialMetric.
     * @param {FinancialMetricUpdateArgs} args - Arguments to update one FinancialMetric.
     * @example
     * // Update one FinancialMetric
     * const financialMetric = await prisma.financialMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialMetricUpdateArgs>(args: SelectSubset<T, FinancialMetricUpdateArgs<ExtArgs>>): Prisma__FinancialMetricClient<$Result.GetResult<Prisma.$FinancialMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FinancialMetrics.
     * @param {FinancialMetricDeleteManyArgs} args - Arguments to filter FinancialMetrics to delete.
     * @example
     * // Delete a few FinancialMetrics
     * const { count } = await prisma.financialMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialMetricDeleteManyArgs>(args?: SelectSubset<T, FinancialMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialMetrics
     * const financialMetric = await prisma.financialMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialMetricUpdateManyArgs>(args: SelectSubset<T, FinancialMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FinancialMetric.
     * @param {FinancialMetricUpsertArgs} args - Arguments to update or create a FinancialMetric.
     * @example
     * // Update or create a FinancialMetric
     * const financialMetric = await prisma.financialMetric.upsert({
     *   create: {
     *     // ... data to create a FinancialMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialMetric we want to update
     *   }
     * })
     */
    upsert<T extends FinancialMetricUpsertArgs>(args: SelectSubset<T, FinancialMetricUpsertArgs<ExtArgs>>): Prisma__FinancialMetricClient<$Result.GetResult<Prisma.$FinancialMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FinancialMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialMetricCountArgs} args - Arguments to filter FinancialMetrics to count.
     * @example
     * // Count the number of FinancialMetrics
     * const count = await prisma.financialMetric.count({
     *   where: {
     *     // ... the filter for the FinancialMetrics we want to count
     *   }
     * })
    **/
    count<T extends FinancialMetricCountArgs>(
      args?: Subset<T, FinancialMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialMetricAggregateArgs>(args: Subset<T, FinancialMetricAggregateArgs>): Prisma.PrismaPromise<GetFinancialMetricAggregateType<T>>

    /**
     * Group by FinancialMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialMetricGroupByArgs['orderBy'] }
        : { orderBy?: FinancialMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialMetric model
   */
  readonly fields: FinancialMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    symbol<T extends SymbolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SymbolDefaultArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialMetric model
   */ 
  interface FinancialMetricFieldRefs {
    readonly id: FieldRef<"FinancialMetric", 'String'>
    readonly symbolId: FieldRef<"FinancialMetric", 'String'>
    readonly metric: FieldRef<"FinancialMetric", 'Json'>
    readonly fetchedAt: FieldRef<"FinancialMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FinancialMetric findUnique
   */
  export type FinancialMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialMetric
     */
    select?: FinancialMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialMetricInclude<ExtArgs> | null
    /**
     * Filter, which FinancialMetric to fetch.
     */
    where: FinancialMetricWhereUniqueInput
  }

  /**
   * FinancialMetric findUniqueOrThrow
   */
  export type FinancialMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialMetric
     */
    select?: FinancialMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialMetricInclude<ExtArgs> | null
    /**
     * Filter, which FinancialMetric to fetch.
     */
    where: FinancialMetricWhereUniqueInput
  }

  /**
   * FinancialMetric findFirst
   */
  export type FinancialMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialMetric
     */
    select?: FinancialMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialMetricInclude<ExtArgs> | null
    /**
     * Filter, which FinancialMetric to fetch.
     */
    where?: FinancialMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialMetrics to fetch.
     */
    orderBy?: FinancialMetricOrderByWithRelationInput | FinancialMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialMetrics.
     */
    cursor?: FinancialMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialMetrics.
     */
    distinct?: FinancialMetricScalarFieldEnum | FinancialMetricScalarFieldEnum[]
  }

  /**
   * FinancialMetric findFirstOrThrow
   */
  export type FinancialMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialMetric
     */
    select?: FinancialMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialMetricInclude<ExtArgs> | null
    /**
     * Filter, which FinancialMetric to fetch.
     */
    where?: FinancialMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialMetrics to fetch.
     */
    orderBy?: FinancialMetricOrderByWithRelationInput | FinancialMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialMetrics.
     */
    cursor?: FinancialMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialMetrics.
     */
    distinct?: FinancialMetricScalarFieldEnum | FinancialMetricScalarFieldEnum[]
  }

  /**
   * FinancialMetric findMany
   */
  export type FinancialMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialMetric
     */
    select?: FinancialMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialMetricInclude<ExtArgs> | null
    /**
     * Filter, which FinancialMetrics to fetch.
     */
    where?: FinancialMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialMetrics to fetch.
     */
    orderBy?: FinancialMetricOrderByWithRelationInput | FinancialMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialMetrics.
     */
    cursor?: FinancialMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialMetrics.
     */
    skip?: number
    distinct?: FinancialMetricScalarFieldEnum | FinancialMetricScalarFieldEnum[]
  }

  /**
   * FinancialMetric create
   */
  export type FinancialMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialMetric
     */
    select?: FinancialMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialMetric.
     */
    data: XOR<FinancialMetricCreateInput, FinancialMetricUncheckedCreateInput>
  }

  /**
   * FinancialMetric createMany
   */
  export type FinancialMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialMetrics.
     */
    data: FinancialMetricCreateManyInput | FinancialMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialMetric createManyAndReturn
   */
  export type FinancialMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialMetric
     */
    select?: FinancialMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FinancialMetrics.
     */
    data: FinancialMetricCreateManyInput | FinancialMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialMetric update
   */
  export type FinancialMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialMetric
     */
    select?: FinancialMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialMetric.
     */
    data: XOR<FinancialMetricUpdateInput, FinancialMetricUncheckedUpdateInput>
    /**
     * Choose, which FinancialMetric to update.
     */
    where: FinancialMetricWhereUniqueInput
  }

  /**
   * FinancialMetric updateMany
   */
  export type FinancialMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialMetrics.
     */
    data: XOR<FinancialMetricUpdateManyMutationInput, FinancialMetricUncheckedUpdateManyInput>
    /**
     * Filter which FinancialMetrics to update
     */
    where?: FinancialMetricWhereInput
  }

  /**
   * FinancialMetric upsert
   */
  export type FinancialMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialMetric
     */
    select?: FinancialMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialMetric to update in case it exists.
     */
    where: FinancialMetricWhereUniqueInput
    /**
     * In case the FinancialMetric found by the `where` argument doesn't exist, create a new FinancialMetric with this data.
     */
    create: XOR<FinancialMetricCreateInput, FinancialMetricUncheckedCreateInput>
    /**
     * In case the FinancialMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialMetricUpdateInput, FinancialMetricUncheckedUpdateInput>
  }

  /**
   * FinancialMetric delete
   */
  export type FinancialMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialMetric
     */
    select?: FinancialMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialMetricInclude<ExtArgs> | null
    /**
     * Filter which FinancialMetric to delete.
     */
    where: FinancialMetricWhereUniqueInput
  }

  /**
   * FinancialMetric deleteMany
   */
  export type FinancialMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialMetrics to delete
     */
    where?: FinancialMetricWhereInput
  }

  /**
   * FinancialMetric without action
   */
  export type FinancialMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialMetric
     */
    select?: FinancialMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialMetricInclude<ExtArgs> | null
  }


  /**
   * Model SystemStatus
   */

  export type AggregateSystemStatus = {
    _count: SystemStatusCountAggregateOutputType | null
    _min: SystemStatusMinAggregateOutputType | null
    _max: SystemStatusMaxAggregateOutputType | null
  }

  export type SystemStatusMinAggregateOutputType = {
    key: string | null
    lastRun: Date | null
    status: string | null
    message: string | null
    updatedAt: Date | null
  }

  export type SystemStatusMaxAggregateOutputType = {
    key: string | null
    lastRun: Date | null
    status: string | null
    message: string | null
    updatedAt: Date | null
  }

  export type SystemStatusCountAggregateOutputType = {
    key: number
    lastRun: number
    status: number
    message: number
    updatedAt: number
    _all: number
  }


  export type SystemStatusMinAggregateInputType = {
    key?: true
    lastRun?: true
    status?: true
    message?: true
    updatedAt?: true
  }

  export type SystemStatusMaxAggregateInputType = {
    key?: true
    lastRun?: true
    status?: true
    message?: true
    updatedAt?: true
  }

  export type SystemStatusCountAggregateInputType = {
    key?: true
    lastRun?: true
    status?: true
    message?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemStatus to aggregate.
     */
    where?: SystemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStatuses to fetch.
     */
    orderBy?: SystemStatusOrderByWithRelationInput | SystemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemStatuses
    **/
    _count?: true | SystemStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemStatusMaxAggregateInputType
  }

  export type GetSystemStatusAggregateType<T extends SystemStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemStatus[P]>
      : GetScalarType<T[P], AggregateSystemStatus[P]>
  }




  export type SystemStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemStatusWhereInput
    orderBy?: SystemStatusOrderByWithAggregationInput | SystemStatusOrderByWithAggregationInput[]
    by: SystemStatusScalarFieldEnum[] | SystemStatusScalarFieldEnum
    having?: SystemStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemStatusCountAggregateInputType | true
    _min?: SystemStatusMinAggregateInputType
    _max?: SystemStatusMaxAggregateInputType
  }

  export type SystemStatusGroupByOutputType = {
    key: string
    lastRun: Date
    status: string
    message: string | null
    updatedAt: Date
    _count: SystemStatusCountAggregateOutputType | null
    _min: SystemStatusMinAggregateOutputType | null
    _max: SystemStatusMaxAggregateOutputType | null
  }

  type GetSystemStatusGroupByPayload<T extends SystemStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemStatusGroupByOutputType[P]>
            : GetScalarType<T[P], SystemStatusGroupByOutputType[P]>
        }
      >
    >


  export type SystemStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    lastRun?: boolean
    status?: boolean
    message?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemStatus"]>

  export type SystemStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    lastRun?: boolean
    status?: boolean
    message?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemStatus"]>

  export type SystemStatusSelectScalar = {
    key?: boolean
    lastRun?: boolean
    status?: boolean
    message?: boolean
    updatedAt?: boolean
  }


  export type $SystemStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      lastRun: Date
      status: string
      message: string | null
      updatedAt: Date
    }, ExtArgs["result"]["systemStatus"]>
    composites: {}
  }

  type SystemStatusGetPayload<S extends boolean | null | undefined | SystemStatusDefaultArgs> = $Result.GetResult<Prisma.$SystemStatusPayload, S>

  type SystemStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemStatusCountAggregateInputType | true
    }

  export interface SystemStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemStatus'], meta: { name: 'SystemStatus' } }
    /**
     * Find zero or one SystemStatus that matches the filter.
     * @param {SystemStatusFindUniqueArgs} args - Arguments to find a SystemStatus
     * @example
     * // Get one SystemStatus
     * const systemStatus = await prisma.systemStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemStatusFindUniqueArgs>(args: SelectSubset<T, SystemStatusFindUniqueArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemStatusFindUniqueOrThrowArgs} args - Arguments to find a SystemStatus
     * @example
     * // Get one SystemStatus
     * const systemStatus = await prisma.systemStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusFindFirstArgs} args - Arguments to find a SystemStatus
     * @example
     * // Get one SystemStatus
     * const systemStatus = await prisma.systemStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemStatusFindFirstArgs>(args?: SelectSubset<T, SystemStatusFindFirstArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusFindFirstOrThrowArgs} args - Arguments to find a SystemStatus
     * @example
     * // Get one SystemStatus
     * const systemStatus = await prisma.systemStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemStatuses
     * const systemStatuses = await prisma.systemStatus.findMany()
     * 
     * // Get first 10 SystemStatuses
     * const systemStatuses = await prisma.systemStatus.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const systemStatusWithKeyOnly = await prisma.systemStatus.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends SystemStatusFindManyArgs>(args?: SelectSubset<T, SystemStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemStatus.
     * @param {SystemStatusCreateArgs} args - Arguments to create a SystemStatus.
     * @example
     * // Create one SystemStatus
     * const SystemStatus = await prisma.systemStatus.create({
     *   data: {
     *     // ... data to create a SystemStatus
     *   }
     * })
     * 
     */
    create<T extends SystemStatusCreateArgs>(args: SelectSubset<T, SystemStatusCreateArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemStatuses.
     * @param {SystemStatusCreateManyArgs} args - Arguments to create many SystemStatuses.
     * @example
     * // Create many SystemStatuses
     * const systemStatus = await prisma.systemStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemStatusCreateManyArgs>(args?: SelectSubset<T, SystemStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemStatuses and returns the data saved in the database.
     * @param {SystemStatusCreateManyAndReturnArgs} args - Arguments to create many SystemStatuses.
     * @example
     * // Create many SystemStatuses
     * const systemStatus = await prisma.systemStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemStatuses and only return the `key`
     * const systemStatusWithKeyOnly = await prisma.systemStatus.createManyAndReturn({ 
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemStatus.
     * @param {SystemStatusDeleteArgs} args - Arguments to delete one SystemStatus.
     * @example
     * // Delete one SystemStatus
     * const SystemStatus = await prisma.systemStatus.delete({
     *   where: {
     *     // ... filter to delete one SystemStatus
     *   }
     * })
     * 
     */
    delete<T extends SystemStatusDeleteArgs>(args: SelectSubset<T, SystemStatusDeleteArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemStatus.
     * @param {SystemStatusUpdateArgs} args - Arguments to update one SystemStatus.
     * @example
     * // Update one SystemStatus
     * const systemStatus = await prisma.systemStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemStatusUpdateArgs>(args: SelectSubset<T, SystemStatusUpdateArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemStatuses.
     * @param {SystemStatusDeleteManyArgs} args - Arguments to filter SystemStatuses to delete.
     * @example
     * // Delete a few SystemStatuses
     * const { count } = await prisma.systemStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemStatusDeleteManyArgs>(args?: SelectSubset<T, SystemStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemStatuses
     * const systemStatus = await prisma.systemStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemStatusUpdateManyArgs>(args: SelectSubset<T, SystemStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemStatus.
     * @param {SystemStatusUpsertArgs} args - Arguments to update or create a SystemStatus.
     * @example
     * // Update or create a SystemStatus
     * const systemStatus = await prisma.systemStatus.upsert({
     *   create: {
     *     // ... data to create a SystemStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemStatus we want to update
     *   }
     * })
     */
    upsert<T extends SystemStatusUpsertArgs>(args: SelectSubset<T, SystemStatusUpsertArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusCountArgs} args - Arguments to filter SystemStatuses to count.
     * @example
     * // Count the number of SystemStatuses
     * const count = await prisma.systemStatus.count({
     *   where: {
     *     // ... the filter for the SystemStatuses we want to count
     *   }
     * })
    **/
    count<T extends SystemStatusCountArgs>(
      args?: Subset<T, SystemStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemStatusAggregateArgs>(args: Subset<T, SystemStatusAggregateArgs>): Prisma.PrismaPromise<GetSystemStatusAggregateType<T>>

    /**
     * Group by SystemStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemStatusGroupByArgs['orderBy'] }
        : { orderBy?: SystemStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemStatus model
   */
  readonly fields: SystemStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemStatus model
   */ 
  interface SystemStatusFieldRefs {
    readonly key: FieldRef<"SystemStatus", 'String'>
    readonly lastRun: FieldRef<"SystemStatus", 'DateTime'>
    readonly status: FieldRef<"SystemStatus", 'String'>
    readonly message: FieldRef<"SystemStatus", 'String'>
    readonly updatedAt: FieldRef<"SystemStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemStatus findUnique
   */
  export type SystemStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Filter, which SystemStatus to fetch.
     */
    where: SystemStatusWhereUniqueInput
  }

  /**
   * SystemStatus findUniqueOrThrow
   */
  export type SystemStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Filter, which SystemStatus to fetch.
     */
    where: SystemStatusWhereUniqueInput
  }

  /**
   * SystemStatus findFirst
   */
  export type SystemStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Filter, which SystemStatus to fetch.
     */
    where?: SystemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStatuses to fetch.
     */
    orderBy?: SystemStatusOrderByWithRelationInput | SystemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemStatuses.
     */
    cursor?: SystemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemStatuses.
     */
    distinct?: SystemStatusScalarFieldEnum | SystemStatusScalarFieldEnum[]
  }

  /**
   * SystemStatus findFirstOrThrow
   */
  export type SystemStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Filter, which SystemStatus to fetch.
     */
    where?: SystemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStatuses to fetch.
     */
    orderBy?: SystemStatusOrderByWithRelationInput | SystemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemStatuses.
     */
    cursor?: SystemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemStatuses.
     */
    distinct?: SystemStatusScalarFieldEnum | SystemStatusScalarFieldEnum[]
  }

  /**
   * SystemStatus findMany
   */
  export type SystemStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Filter, which SystemStatuses to fetch.
     */
    where?: SystemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStatuses to fetch.
     */
    orderBy?: SystemStatusOrderByWithRelationInput | SystemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemStatuses.
     */
    cursor?: SystemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStatuses.
     */
    skip?: number
    distinct?: SystemStatusScalarFieldEnum | SystemStatusScalarFieldEnum[]
  }

  /**
   * SystemStatus create
   */
  export type SystemStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemStatus.
     */
    data: XOR<SystemStatusCreateInput, SystemStatusUncheckedCreateInput>
  }

  /**
   * SystemStatus createMany
   */
  export type SystemStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemStatuses.
     */
    data: SystemStatusCreateManyInput | SystemStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemStatus createManyAndReturn
   */
  export type SystemStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemStatuses.
     */
    data: SystemStatusCreateManyInput | SystemStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemStatus update
   */
  export type SystemStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemStatus.
     */
    data: XOR<SystemStatusUpdateInput, SystemStatusUncheckedUpdateInput>
    /**
     * Choose, which SystemStatus to update.
     */
    where: SystemStatusWhereUniqueInput
  }

  /**
   * SystemStatus updateMany
   */
  export type SystemStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemStatuses.
     */
    data: XOR<SystemStatusUpdateManyMutationInput, SystemStatusUncheckedUpdateManyInput>
    /**
     * Filter which SystemStatuses to update
     */
    where?: SystemStatusWhereInput
  }

  /**
   * SystemStatus upsert
   */
  export type SystemStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemStatus to update in case it exists.
     */
    where: SystemStatusWhereUniqueInput
    /**
     * In case the SystemStatus found by the `where` argument doesn't exist, create a new SystemStatus with this data.
     */
    create: XOR<SystemStatusCreateInput, SystemStatusUncheckedCreateInput>
    /**
     * In case the SystemStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemStatusUpdateInput, SystemStatusUncheckedUpdateInput>
  }

  /**
   * SystemStatus delete
   */
  export type SystemStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Filter which SystemStatus to delete.
     */
    where: SystemStatusWhereUniqueInput
  }

  /**
   * SystemStatus deleteMany
   */
  export type SystemStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemStatuses to delete
     */
    where?: SystemStatusWhereInput
  }

  /**
   * SystemStatus without action
   */
  export type SystemStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    passwordHash: 'passwordHash',
    role: 'role',
    status: 'status',
    googleId: 'googleId',
    picture: 'picture',
    apiCallsToday: 'apiCallsToday',
    lastApiReset: 'lastApiReset',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SymbolScalarFieldEnum: {
    id: 'id',
    ticker: 'ticker',
    name: 'name',
    exchange: 'exchange',
    currency: 'currency',
    sector: 'sector',
    industry: 'industry',
    marketCap: 'marketCap',
    description: 'description',
    website: 'website',
    isActive: 'isActive',
    ipo: 'ipo',
    delistDate: 'delistDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastSyncedAt: 'lastSyncedAt'
  };

  export type SymbolScalarFieldEnum = (typeof SymbolScalarFieldEnum)[keyof typeof SymbolScalarFieldEnum]


  export const CandleScalarFieldEnum: {
    id: 'id',
    symbolId: 'symbolId',
    timeframe: 'timeframe',
    timestamp: 'timestamp',
    open: 'open',
    high: 'high',
    low: 'low',
    close: 'close',
    volume: 'volume',
    createdAt: 'createdAt'
  };

  export type CandleScalarFieldEnum = (typeof CandleScalarFieldEnum)[keyof typeof CandleScalarFieldEnum]


  export const IndicatorCacheScalarFieldEnum: {
    id: 'id',
    symbolId: 'symbolId',
    indicator: 'indicator',
    timeframe: 'timeframe',
    period: 'period',
    timestamp: 'timestamp',
    value: 'value',
    createdAt: 'createdAt'
  };

  export type IndicatorCacheScalarFieldEnum = (typeof IndicatorCacheScalarFieldEnum)[keyof typeof IndicatorCacheScalarFieldEnum]


  export const WatchlistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    isPublic: 'isPublic',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WatchlistScalarFieldEnum = (typeof WatchlistScalarFieldEnum)[keyof typeof WatchlistScalarFieldEnum]


  export const WatchlistSymbolScalarFieldEnum: {
    id: 'id',
    watchlistId: 'watchlistId',
    symbolId: 'symbolId',
    notes: 'notes',
    addedAt: 'addedAt'
  };

  export type WatchlistSymbolScalarFieldEnum = (typeof WatchlistSymbolScalarFieldEnum)[keyof typeof WatchlistSymbolScalarFieldEnum]


  export const SavedScanScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    definition: 'definition',
    symbolUniverse: 'symbolUniverse',
    isPublic: 'isPublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastRunAt: 'lastRunAt'
  };

  export type SavedScanScalarFieldEnum = (typeof SavedScanScalarFieldEnum)[keyof typeof SavedScanScalarFieldEnum]


  export const SavedScanVersionScalarFieldEnum: {
    id: 'id',
    savedScanId: 'savedScanId',
    versionNumber: 'versionNumber',
    definition: 'definition',
    createdAt: 'createdAt',
    createdById: 'createdById',
    comment: 'comment'
  };

  export type SavedScanVersionScalarFieldEnum = (typeof SavedScanVersionScalarFieldEnum)[keyof typeof SavedScanVersionScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    alertType: 'alertType',
    condition: 'condition',
    ticker: 'ticker',
    status: 'status',
    emailNotify: 'emailNotify',
    pushNotify: 'pushNotify',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    triggeredAt: 'triggeredAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const BacktestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    savedScanId: 'savedScanId',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    timeframe: 'timeframe',
    definition: 'definition',
    status: 'status',
    results: 'results',
    totalMatches: 'totalMatches',
    avgReturn: 'avgReturn',
    winRate: 'winRate',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type BacktestScalarFieldEnum = (typeof BacktestScalarFieldEnum)[keyof typeof BacktestScalarFieldEnum]


  export const FinancialMetricScalarFieldEnum: {
    id: 'id',
    symbolId: 'symbolId',
    metric: 'metric',
    fetchedAt: 'fetchedAt'
  };

  export type FinancialMetricScalarFieldEnum = (typeof FinancialMetricScalarFieldEnum)[keyof typeof FinancialMetricScalarFieldEnum]


  export const SystemStatusScalarFieldEnum: {
    key: 'key',
    lastRun: 'lastRun',
    status: 'status',
    message: 'message',
    updatedAt: 'updatedAt'
  };

  export type SystemStatusScalarFieldEnum = (typeof SystemStatusScalarFieldEnum)[keyof typeof SystemStatusScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Exchange'
   */
  export type EnumExchangeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Exchange'>
    


  /**
   * Reference to a field of type 'Exchange[]'
   */
  export type ListEnumExchangeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Exchange[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Timeframe'
   */
  export type EnumTimeframeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Timeframe'>
    


  /**
   * Reference to a field of type 'Timeframe[]'
   */
  export type ListEnumTimeframeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Timeframe[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'IndicatorType'
   */
  export type EnumIndicatorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IndicatorType'>
    


  /**
   * Reference to a field of type 'IndicatorType[]'
   */
  export type ListEnumIndicatorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IndicatorType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'AlertType'
   */
  export type EnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType'>
    


  /**
   * Reference to a field of type 'AlertType[]'
   */
  export type ListEnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType[]'>
    


  /**
   * Reference to a field of type 'AlertStatus'
   */
  export type EnumAlertStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertStatus'>
    


  /**
   * Reference to a field of type 'AlertStatus[]'
   */
  export type ListEnumAlertStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertStatus[]'>
    


  /**
   * Reference to a field of type 'BacktestStatus'
   */
  export type EnumBacktestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BacktestStatus'>
    


  /**
   * Reference to a field of type 'BacktestStatus[]'
   */
  export type ListEnumBacktestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BacktestStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    googleId?: StringNullableFilter<"User"> | string | null
    picture?: StringNullableFilter<"User"> | string | null
    apiCallsToday?: IntFilter<"User"> | number
    lastApiReset?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    watchlists?: WatchlistListRelationFilter
    savedScans?: SavedScanListRelationFilter
    alerts?: AlertListRelationFilter
    backtests?: BacktestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    googleId?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    apiCallsToday?: SortOrder
    lastApiReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    watchlists?: WatchlistOrderByRelationAggregateInput
    savedScans?: SavedScanOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
    backtests?: BacktestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    googleId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    picture?: StringNullableFilter<"User"> | string | null
    apiCallsToday?: IntFilter<"User"> | number
    lastApiReset?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    watchlists?: WatchlistListRelationFilter
    savedScans?: SavedScanListRelationFilter
    alerts?: AlertListRelationFilter
    backtests?: BacktestListRelationFilter
  }, "id" | "email" | "googleId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    googleId?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    apiCallsToday?: SortOrder
    lastApiReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    picture?: StringNullableWithAggregatesFilter<"User"> | string | null
    apiCallsToday?: IntWithAggregatesFilter<"User"> | number
    lastApiReset?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type SymbolWhereInput = {
    AND?: SymbolWhereInput | SymbolWhereInput[]
    OR?: SymbolWhereInput[]
    NOT?: SymbolWhereInput | SymbolWhereInput[]
    id?: StringFilter<"Symbol"> | string
    ticker?: StringFilter<"Symbol"> | string
    name?: StringFilter<"Symbol"> | string
    exchange?: EnumExchangeFilter<"Symbol"> | $Enums.Exchange
    currency?: StringFilter<"Symbol"> | string
    sector?: StringNullableFilter<"Symbol"> | string | null
    industry?: StringNullableFilter<"Symbol"> | string | null
    marketCap?: BigIntNullableFilter<"Symbol"> | bigint | number | null
    description?: StringNullableFilter<"Symbol"> | string | null
    website?: StringNullableFilter<"Symbol"> | string | null
    isActive?: BoolFilter<"Symbol"> | boolean
    ipo?: DateTimeNullableFilter<"Symbol"> | Date | string | null
    delistDate?: DateTimeNullableFilter<"Symbol"> | Date | string | null
    createdAt?: DateTimeFilter<"Symbol"> | Date | string
    updatedAt?: DateTimeFilter<"Symbol"> | Date | string
    lastSyncedAt?: DateTimeNullableFilter<"Symbol"> | Date | string | null
    candles?: CandleListRelationFilter
    indicators?: IndicatorCacheListRelationFilter
    watchlistSymbols?: WatchlistSymbolListRelationFilter
    financialMetrics?: FinancialMetricListRelationFilter
  }

  export type SymbolOrderByWithRelationInput = {
    id?: SortOrder
    ticker?: SortOrder
    name?: SortOrder
    exchange?: SortOrder
    currency?: SortOrder
    sector?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    marketCap?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ipo?: SortOrderInput | SortOrder
    delistDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    candles?: CandleOrderByRelationAggregateInput
    indicators?: IndicatorCacheOrderByRelationAggregateInput
    watchlistSymbols?: WatchlistSymbolOrderByRelationAggregateInput
    financialMetrics?: FinancialMetricOrderByRelationAggregateInput
  }

  export type SymbolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ticker?: string
    AND?: SymbolWhereInput | SymbolWhereInput[]
    OR?: SymbolWhereInput[]
    NOT?: SymbolWhereInput | SymbolWhereInput[]
    name?: StringFilter<"Symbol"> | string
    exchange?: EnumExchangeFilter<"Symbol"> | $Enums.Exchange
    currency?: StringFilter<"Symbol"> | string
    sector?: StringNullableFilter<"Symbol"> | string | null
    industry?: StringNullableFilter<"Symbol"> | string | null
    marketCap?: BigIntNullableFilter<"Symbol"> | bigint | number | null
    description?: StringNullableFilter<"Symbol"> | string | null
    website?: StringNullableFilter<"Symbol"> | string | null
    isActive?: BoolFilter<"Symbol"> | boolean
    ipo?: DateTimeNullableFilter<"Symbol"> | Date | string | null
    delistDate?: DateTimeNullableFilter<"Symbol"> | Date | string | null
    createdAt?: DateTimeFilter<"Symbol"> | Date | string
    updatedAt?: DateTimeFilter<"Symbol"> | Date | string
    lastSyncedAt?: DateTimeNullableFilter<"Symbol"> | Date | string | null
    candles?: CandleListRelationFilter
    indicators?: IndicatorCacheListRelationFilter
    watchlistSymbols?: WatchlistSymbolListRelationFilter
    financialMetrics?: FinancialMetricListRelationFilter
  }, "id" | "ticker">

  export type SymbolOrderByWithAggregationInput = {
    id?: SortOrder
    ticker?: SortOrder
    name?: SortOrder
    exchange?: SortOrder
    currency?: SortOrder
    sector?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    marketCap?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ipo?: SortOrderInput | SortOrder
    delistDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    _count?: SymbolCountOrderByAggregateInput
    _avg?: SymbolAvgOrderByAggregateInput
    _max?: SymbolMaxOrderByAggregateInput
    _min?: SymbolMinOrderByAggregateInput
    _sum?: SymbolSumOrderByAggregateInput
  }

  export type SymbolScalarWhereWithAggregatesInput = {
    AND?: SymbolScalarWhereWithAggregatesInput | SymbolScalarWhereWithAggregatesInput[]
    OR?: SymbolScalarWhereWithAggregatesInput[]
    NOT?: SymbolScalarWhereWithAggregatesInput | SymbolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Symbol"> | string
    ticker?: StringWithAggregatesFilter<"Symbol"> | string
    name?: StringWithAggregatesFilter<"Symbol"> | string
    exchange?: EnumExchangeWithAggregatesFilter<"Symbol"> | $Enums.Exchange
    currency?: StringWithAggregatesFilter<"Symbol"> | string
    sector?: StringNullableWithAggregatesFilter<"Symbol"> | string | null
    industry?: StringNullableWithAggregatesFilter<"Symbol"> | string | null
    marketCap?: BigIntNullableWithAggregatesFilter<"Symbol"> | bigint | number | null
    description?: StringNullableWithAggregatesFilter<"Symbol"> | string | null
    website?: StringNullableWithAggregatesFilter<"Symbol"> | string | null
    isActive?: BoolWithAggregatesFilter<"Symbol"> | boolean
    ipo?: DateTimeNullableWithAggregatesFilter<"Symbol"> | Date | string | null
    delistDate?: DateTimeNullableWithAggregatesFilter<"Symbol"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Symbol"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Symbol"> | Date | string
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Symbol"> | Date | string | null
  }

  export type CandleWhereInput = {
    AND?: CandleWhereInput | CandleWhereInput[]
    OR?: CandleWhereInput[]
    NOT?: CandleWhereInput | CandleWhereInput[]
    id?: StringFilter<"Candle"> | string
    symbolId?: StringFilter<"Candle"> | string
    timeframe?: EnumTimeframeFilter<"Candle"> | $Enums.Timeframe
    timestamp?: DateTimeFilter<"Candle"> | Date | string
    open?: DecimalFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    high?: DecimalFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    low?: DecimalFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    close?: DecimalFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    volume?: BigIntFilter<"Candle"> | bigint | number
    createdAt?: DateTimeFilter<"Candle"> | Date | string
    symbol?: XOR<SymbolRelationFilter, SymbolWhereInput>
  }

  export type CandleOrderByWithRelationInput = {
    id?: SortOrder
    symbolId?: SortOrder
    timeframe?: SortOrder
    timestamp?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    volume?: SortOrder
    createdAt?: SortOrder
    symbol?: SymbolOrderByWithRelationInput
  }

  export type CandleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    symbolId_timeframe_timestamp?: CandleSymbolIdTimeframeTimestampCompoundUniqueInput
    AND?: CandleWhereInput | CandleWhereInput[]
    OR?: CandleWhereInput[]
    NOT?: CandleWhereInput | CandleWhereInput[]
    symbolId?: StringFilter<"Candle"> | string
    timeframe?: EnumTimeframeFilter<"Candle"> | $Enums.Timeframe
    timestamp?: DateTimeFilter<"Candle"> | Date | string
    open?: DecimalFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    high?: DecimalFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    low?: DecimalFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    close?: DecimalFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    volume?: BigIntFilter<"Candle"> | bigint | number
    createdAt?: DateTimeFilter<"Candle"> | Date | string
    symbol?: XOR<SymbolRelationFilter, SymbolWhereInput>
  }, "id" | "symbolId_timeframe_timestamp">

  export type CandleOrderByWithAggregationInput = {
    id?: SortOrder
    symbolId?: SortOrder
    timeframe?: SortOrder
    timestamp?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    volume?: SortOrder
    createdAt?: SortOrder
    _count?: CandleCountOrderByAggregateInput
    _avg?: CandleAvgOrderByAggregateInput
    _max?: CandleMaxOrderByAggregateInput
    _min?: CandleMinOrderByAggregateInput
    _sum?: CandleSumOrderByAggregateInput
  }

  export type CandleScalarWhereWithAggregatesInput = {
    AND?: CandleScalarWhereWithAggregatesInput | CandleScalarWhereWithAggregatesInput[]
    OR?: CandleScalarWhereWithAggregatesInput[]
    NOT?: CandleScalarWhereWithAggregatesInput | CandleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Candle"> | string
    symbolId?: StringWithAggregatesFilter<"Candle"> | string
    timeframe?: EnumTimeframeWithAggregatesFilter<"Candle"> | $Enums.Timeframe
    timestamp?: DateTimeWithAggregatesFilter<"Candle"> | Date | string
    open?: DecimalWithAggregatesFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    high?: DecimalWithAggregatesFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    low?: DecimalWithAggregatesFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    close?: DecimalWithAggregatesFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    volume?: BigIntWithAggregatesFilter<"Candle"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"Candle"> | Date | string
  }

  export type IndicatorCacheWhereInput = {
    AND?: IndicatorCacheWhereInput | IndicatorCacheWhereInput[]
    OR?: IndicatorCacheWhereInput[]
    NOT?: IndicatorCacheWhereInput | IndicatorCacheWhereInput[]
    id?: StringFilter<"IndicatorCache"> | string
    symbolId?: StringFilter<"IndicatorCache"> | string
    indicator?: EnumIndicatorTypeFilter<"IndicatorCache"> | $Enums.IndicatorType
    timeframe?: EnumTimeframeFilter<"IndicatorCache"> | $Enums.Timeframe
    period?: IntFilter<"IndicatorCache"> | number
    timestamp?: DateTimeFilter<"IndicatorCache"> | Date | string
    value?: JsonFilter<"IndicatorCache">
    createdAt?: DateTimeFilter<"IndicatorCache"> | Date | string
    symbol?: XOR<SymbolRelationFilter, SymbolWhereInput>
  }

  export type IndicatorCacheOrderByWithRelationInput = {
    id?: SortOrder
    symbolId?: SortOrder
    indicator?: SortOrder
    timeframe?: SortOrder
    period?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    symbol?: SymbolOrderByWithRelationInput
  }

  export type IndicatorCacheWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    symbolId_indicator_timeframe_period_timestamp?: IndicatorCacheSymbolIdIndicatorTimeframePeriodTimestampCompoundUniqueInput
    AND?: IndicatorCacheWhereInput | IndicatorCacheWhereInput[]
    OR?: IndicatorCacheWhereInput[]
    NOT?: IndicatorCacheWhereInput | IndicatorCacheWhereInput[]
    symbolId?: StringFilter<"IndicatorCache"> | string
    indicator?: EnumIndicatorTypeFilter<"IndicatorCache"> | $Enums.IndicatorType
    timeframe?: EnumTimeframeFilter<"IndicatorCache"> | $Enums.Timeframe
    period?: IntFilter<"IndicatorCache"> | number
    timestamp?: DateTimeFilter<"IndicatorCache"> | Date | string
    value?: JsonFilter<"IndicatorCache">
    createdAt?: DateTimeFilter<"IndicatorCache"> | Date | string
    symbol?: XOR<SymbolRelationFilter, SymbolWhereInput>
  }, "id" | "symbolId_indicator_timeframe_period_timestamp">

  export type IndicatorCacheOrderByWithAggregationInput = {
    id?: SortOrder
    symbolId?: SortOrder
    indicator?: SortOrder
    timeframe?: SortOrder
    period?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    _count?: IndicatorCacheCountOrderByAggregateInput
    _avg?: IndicatorCacheAvgOrderByAggregateInput
    _max?: IndicatorCacheMaxOrderByAggregateInput
    _min?: IndicatorCacheMinOrderByAggregateInput
    _sum?: IndicatorCacheSumOrderByAggregateInput
  }

  export type IndicatorCacheScalarWhereWithAggregatesInput = {
    AND?: IndicatorCacheScalarWhereWithAggregatesInput | IndicatorCacheScalarWhereWithAggregatesInput[]
    OR?: IndicatorCacheScalarWhereWithAggregatesInput[]
    NOT?: IndicatorCacheScalarWhereWithAggregatesInput | IndicatorCacheScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IndicatorCache"> | string
    symbolId?: StringWithAggregatesFilter<"IndicatorCache"> | string
    indicator?: EnumIndicatorTypeWithAggregatesFilter<"IndicatorCache"> | $Enums.IndicatorType
    timeframe?: EnumTimeframeWithAggregatesFilter<"IndicatorCache"> | $Enums.Timeframe
    period?: IntWithAggregatesFilter<"IndicatorCache"> | number
    timestamp?: DateTimeWithAggregatesFilter<"IndicatorCache"> | Date | string
    value?: JsonWithAggregatesFilter<"IndicatorCache">
    createdAt?: DateTimeWithAggregatesFilter<"IndicatorCache"> | Date | string
  }

  export type WatchlistWhereInput = {
    AND?: WatchlistWhereInput | WatchlistWhereInput[]
    OR?: WatchlistWhereInput[]
    NOT?: WatchlistWhereInput | WatchlistWhereInput[]
    id?: StringFilter<"Watchlist"> | string
    userId?: StringFilter<"Watchlist"> | string
    name?: StringFilter<"Watchlist"> | string
    description?: StringNullableFilter<"Watchlist"> | string | null
    isPublic?: BoolFilter<"Watchlist"> | boolean
    sortOrder?: IntFilter<"Watchlist"> | number
    createdAt?: DateTimeFilter<"Watchlist"> | Date | string
    updatedAt?: DateTimeFilter<"Watchlist"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    symbols?: WatchlistSymbolListRelationFilter
  }

  export type WatchlistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    symbols?: WatchlistSymbolOrderByRelationAggregateInput
  }

  export type WatchlistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WatchlistWhereInput | WatchlistWhereInput[]
    OR?: WatchlistWhereInput[]
    NOT?: WatchlistWhereInput | WatchlistWhereInput[]
    userId?: StringFilter<"Watchlist"> | string
    name?: StringFilter<"Watchlist"> | string
    description?: StringNullableFilter<"Watchlist"> | string | null
    isPublic?: BoolFilter<"Watchlist"> | boolean
    sortOrder?: IntFilter<"Watchlist"> | number
    createdAt?: DateTimeFilter<"Watchlist"> | Date | string
    updatedAt?: DateTimeFilter<"Watchlist"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    symbols?: WatchlistSymbolListRelationFilter
  }, "id">

  export type WatchlistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WatchlistCountOrderByAggregateInput
    _avg?: WatchlistAvgOrderByAggregateInput
    _max?: WatchlistMaxOrderByAggregateInput
    _min?: WatchlistMinOrderByAggregateInput
    _sum?: WatchlistSumOrderByAggregateInput
  }

  export type WatchlistScalarWhereWithAggregatesInput = {
    AND?: WatchlistScalarWhereWithAggregatesInput | WatchlistScalarWhereWithAggregatesInput[]
    OR?: WatchlistScalarWhereWithAggregatesInput[]
    NOT?: WatchlistScalarWhereWithAggregatesInput | WatchlistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Watchlist"> | string
    userId?: StringWithAggregatesFilter<"Watchlist"> | string
    name?: StringWithAggregatesFilter<"Watchlist"> | string
    description?: StringNullableWithAggregatesFilter<"Watchlist"> | string | null
    isPublic?: BoolWithAggregatesFilter<"Watchlist"> | boolean
    sortOrder?: IntWithAggregatesFilter<"Watchlist"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Watchlist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Watchlist"> | Date | string
  }

  export type WatchlistSymbolWhereInput = {
    AND?: WatchlistSymbolWhereInput | WatchlistSymbolWhereInput[]
    OR?: WatchlistSymbolWhereInput[]
    NOT?: WatchlistSymbolWhereInput | WatchlistSymbolWhereInput[]
    id?: StringFilter<"WatchlistSymbol"> | string
    watchlistId?: StringFilter<"WatchlistSymbol"> | string
    symbolId?: StringFilter<"WatchlistSymbol"> | string
    notes?: StringNullableFilter<"WatchlistSymbol"> | string | null
    addedAt?: DateTimeFilter<"WatchlistSymbol"> | Date | string
    watchlist?: XOR<WatchlistRelationFilter, WatchlistWhereInput>
    symbol?: XOR<SymbolRelationFilter, SymbolWhereInput>
  }

  export type WatchlistSymbolOrderByWithRelationInput = {
    id?: SortOrder
    watchlistId?: SortOrder
    symbolId?: SortOrder
    notes?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    watchlist?: WatchlistOrderByWithRelationInput
    symbol?: SymbolOrderByWithRelationInput
  }

  export type WatchlistSymbolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    watchlistId_symbolId?: WatchlistSymbolWatchlistIdSymbolIdCompoundUniqueInput
    AND?: WatchlistSymbolWhereInput | WatchlistSymbolWhereInput[]
    OR?: WatchlistSymbolWhereInput[]
    NOT?: WatchlistSymbolWhereInput | WatchlistSymbolWhereInput[]
    watchlistId?: StringFilter<"WatchlistSymbol"> | string
    symbolId?: StringFilter<"WatchlistSymbol"> | string
    notes?: StringNullableFilter<"WatchlistSymbol"> | string | null
    addedAt?: DateTimeFilter<"WatchlistSymbol"> | Date | string
    watchlist?: XOR<WatchlistRelationFilter, WatchlistWhereInput>
    symbol?: XOR<SymbolRelationFilter, SymbolWhereInput>
  }, "id" | "watchlistId_symbolId">

  export type WatchlistSymbolOrderByWithAggregationInput = {
    id?: SortOrder
    watchlistId?: SortOrder
    symbolId?: SortOrder
    notes?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    _count?: WatchlistSymbolCountOrderByAggregateInput
    _max?: WatchlistSymbolMaxOrderByAggregateInput
    _min?: WatchlistSymbolMinOrderByAggregateInput
  }

  export type WatchlistSymbolScalarWhereWithAggregatesInput = {
    AND?: WatchlistSymbolScalarWhereWithAggregatesInput | WatchlistSymbolScalarWhereWithAggregatesInput[]
    OR?: WatchlistSymbolScalarWhereWithAggregatesInput[]
    NOT?: WatchlistSymbolScalarWhereWithAggregatesInput | WatchlistSymbolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WatchlistSymbol"> | string
    watchlistId?: StringWithAggregatesFilter<"WatchlistSymbol"> | string
    symbolId?: StringWithAggregatesFilter<"WatchlistSymbol"> | string
    notes?: StringNullableWithAggregatesFilter<"WatchlistSymbol"> | string | null
    addedAt?: DateTimeWithAggregatesFilter<"WatchlistSymbol"> | Date | string
  }

  export type SavedScanWhereInput = {
    AND?: SavedScanWhereInput | SavedScanWhereInput[]
    OR?: SavedScanWhereInput[]
    NOT?: SavedScanWhereInput | SavedScanWhereInput[]
    id?: StringFilter<"SavedScan"> | string
    userId?: StringFilter<"SavedScan"> | string
    name?: StringFilter<"SavedScan"> | string
    description?: StringNullableFilter<"SavedScan"> | string | null
    definition?: JsonFilter<"SavedScan">
    symbolUniverse?: StringNullableListFilter<"SavedScan">
    isPublic?: BoolFilter<"SavedScan"> | boolean
    createdAt?: DateTimeFilter<"SavedScan"> | Date | string
    updatedAt?: DateTimeFilter<"SavedScan"> | Date | string
    lastRunAt?: DateTimeNullableFilter<"SavedScan"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    backtests?: BacktestListRelationFilter
    versions?: SavedScanVersionListRelationFilter
  }

  export type SavedScanOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    definition?: SortOrder
    symbolUniverse?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    backtests?: BacktestOrderByRelationAggregateInput
    versions?: SavedScanVersionOrderByRelationAggregateInput
  }

  export type SavedScanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SavedScanWhereInput | SavedScanWhereInput[]
    OR?: SavedScanWhereInput[]
    NOT?: SavedScanWhereInput | SavedScanWhereInput[]
    userId?: StringFilter<"SavedScan"> | string
    name?: StringFilter<"SavedScan"> | string
    description?: StringNullableFilter<"SavedScan"> | string | null
    definition?: JsonFilter<"SavedScan">
    symbolUniverse?: StringNullableListFilter<"SavedScan">
    isPublic?: BoolFilter<"SavedScan"> | boolean
    createdAt?: DateTimeFilter<"SavedScan"> | Date | string
    updatedAt?: DateTimeFilter<"SavedScan"> | Date | string
    lastRunAt?: DateTimeNullableFilter<"SavedScan"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    backtests?: BacktestListRelationFilter
    versions?: SavedScanVersionListRelationFilter
  }, "id">

  export type SavedScanOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    definition?: SortOrder
    symbolUniverse?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    _count?: SavedScanCountOrderByAggregateInput
    _max?: SavedScanMaxOrderByAggregateInput
    _min?: SavedScanMinOrderByAggregateInput
  }

  export type SavedScanScalarWhereWithAggregatesInput = {
    AND?: SavedScanScalarWhereWithAggregatesInput | SavedScanScalarWhereWithAggregatesInput[]
    OR?: SavedScanScalarWhereWithAggregatesInput[]
    NOT?: SavedScanScalarWhereWithAggregatesInput | SavedScanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavedScan"> | string
    userId?: StringWithAggregatesFilter<"SavedScan"> | string
    name?: StringWithAggregatesFilter<"SavedScan"> | string
    description?: StringNullableWithAggregatesFilter<"SavedScan"> | string | null
    definition?: JsonWithAggregatesFilter<"SavedScan">
    symbolUniverse?: StringNullableListFilter<"SavedScan">
    isPublic?: BoolWithAggregatesFilter<"SavedScan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SavedScan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SavedScan"> | Date | string
    lastRunAt?: DateTimeNullableWithAggregatesFilter<"SavedScan"> | Date | string | null
  }

  export type SavedScanVersionWhereInput = {
    AND?: SavedScanVersionWhereInput | SavedScanVersionWhereInput[]
    OR?: SavedScanVersionWhereInput[]
    NOT?: SavedScanVersionWhereInput | SavedScanVersionWhereInput[]
    id?: StringFilter<"SavedScanVersion"> | string
    savedScanId?: StringFilter<"SavedScanVersion"> | string
    versionNumber?: IntFilter<"SavedScanVersion"> | number
    definition?: JsonFilter<"SavedScanVersion">
    createdAt?: DateTimeFilter<"SavedScanVersion"> | Date | string
    createdById?: StringNullableFilter<"SavedScanVersion"> | string | null
    comment?: StringNullableFilter<"SavedScanVersion"> | string | null
    savedScan?: XOR<SavedScanRelationFilter, SavedScanWhereInput>
  }

  export type SavedScanVersionOrderByWithRelationInput = {
    id?: SortOrder
    savedScanId?: SortOrder
    versionNumber?: SortOrder
    definition?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    savedScan?: SavedScanOrderByWithRelationInput
  }

  export type SavedScanVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    savedScanId_versionNumber?: SavedScanVersionSavedScanIdVersionNumberCompoundUniqueInput
    AND?: SavedScanVersionWhereInput | SavedScanVersionWhereInput[]
    OR?: SavedScanVersionWhereInput[]
    NOT?: SavedScanVersionWhereInput | SavedScanVersionWhereInput[]
    savedScanId?: StringFilter<"SavedScanVersion"> | string
    versionNumber?: IntFilter<"SavedScanVersion"> | number
    definition?: JsonFilter<"SavedScanVersion">
    createdAt?: DateTimeFilter<"SavedScanVersion"> | Date | string
    createdById?: StringNullableFilter<"SavedScanVersion"> | string | null
    comment?: StringNullableFilter<"SavedScanVersion"> | string | null
    savedScan?: XOR<SavedScanRelationFilter, SavedScanWhereInput>
  }, "id" | "savedScanId_versionNumber">

  export type SavedScanVersionOrderByWithAggregationInput = {
    id?: SortOrder
    savedScanId?: SortOrder
    versionNumber?: SortOrder
    definition?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: SavedScanVersionCountOrderByAggregateInput
    _avg?: SavedScanVersionAvgOrderByAggregateInput
    _max?: SavedScanVersionMaxOrderByAggregateInput
    _min?: SavedScanVersionMinOrderByAggregateInput
    _sum?: SavedScanVersionSumOrderByAggregateInput
  }

  export type SavedScanVersionScalarWhereWithAggregatesInput = {
    AND?: SavedScanVersionScalarWhereWithAggregatesInput | SavedScanVersionScalarWhereWithAggregatesInput[]
    OR?: SavedScanVersionScalarWhereWithAggregatesInput[]
    NOT?: SavedScanVersionScalarWhereWithAggregatesInput | SavedScanVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavedScanVersion"> | string
    savedScanId?: StringWithAggregatesFilter<"SavedScanVersion"> | string
    versionNumber?: IntWithAggregatesFilter<"SavedScanVersion"> | number
    definition?: JsonWithAggregatesFilter<"SavedScanVersion">
    createdAt?: DateTimeWithAggregatesFilter<"SavedScanVersion"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"SavedScanVersion"> | string | null
    comment?: StringNullableWithAggregatesFilter<"SavedScanVersion"> | string | null
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    userId?: StringFilter<"Alert"> | string
    name?: StringFilter<"Alert"> | string
    alertType?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    condition?: JsonFilter<"Alert">
    ticker?: StringNullableFilter<"Alert"> | string | null
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    emailNotify?: BoolFilter<"Alert"> | boolean
    pushNotify?: BoolFilter<"Alert"> | boolean
    expiresAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    triggeredAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    alertType?: SortOrder
    condition?: SortOrder
    ticker?: SortOrderInput | SortOrder
    status?: SortOrder
    emailNotify?: SortOrder
    pushNotify?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggeredAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    userId?: StringFilter<"Alert"> | string
    name?: StringFilter<"Alert"> | string
    alertType?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    condition?: JsonFilter<"Alert">
    ticker?: StringNullableFilter<"Alert"> | string | null
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    emailNotify?: BoolFilter<"Alert"> | boolean
    pushNotify?: BoolFilter<"Alert"> | boolean
    expiresAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    triggeredAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    alertType?: SortOrder
    condition?: SortOrder
    ticker?: SortOrderInput | SortOrder
    status?: SortOrder
    emailNotify?: SortOrder
    pushNotify?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggeredAt?: SortOrderInput | SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    userId?: StringWithAggregatesFilter<"Alert"> | string
    name?: StringWithAggregatesFilter<"Alert"> | string
    alertType?: EnumAlertTypeWithAggregatesFilter<"Alert"> | $Enums.AlertType
    condition?: JsonWithAggregatesFilter<"Alert">
    ticker?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    status?: EnumAlertStatusWithAggregatesFilter<"Alert"> | $Enums.AlertStatus
    emailNotify?: BoolWithAggregatesFilter<"Alert"> | boolean
    pushNotify?: BoolWithAggregatesFilter<"Alert"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    triggeredAt?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
  }

  export type BacktestWhereInput = {
    AND?: BacktestWhereInput | BacktestWhereInput[]
    OR?: BacktestWhereInput[]
    NOT?: BacktestWhereInput | BacktestWhereInput[]
    id?: StringFilter<"Backtest"> | string
    userId?: StringFilter<"Backtest"> | string
    savedScanId?: StringNullableFilter<"Backtest"> | string | null
    name?: StringFilter<"Backtest"> | string
    startDate?: DateTimeFilter<"Backtest"> | Date | string
    endDate?: DateTimeFilter<"Backtest"> | Date | string
    timeframe?: EnumTimeframeFilter<"Backtest"> | $Enums.Timeframe
    definition?: JsonFilter<"Backtest">
    status?: EnumBacktestStatusFilter<"Backtest"> | $Enums.BacktestStatus
    results?: JsonNullableFilter<"Backtest">
    totalMatches?: IntNullableFilter<"Backtest"> | number | null
    avgReturn?: DecimalNullableFilter<"Backtest"> | Decimal | DecimalJsLike | number | string | null
    winRate?: DecimalNullableFilter<"Backtest"> | Decimal | DecimalJsLike | number | string | null
    errorMessage?: StringNullableFilter<"Backtest"> | string | null
    createdAt?: DateTimeFilter<"Backtest"> | Date | string
    updatedAt?: DateTimeFilter<"Backtest"> | Date | string
    startedAt?: DateTimeNullableFilter<"Backtest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Backtest"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    savedScan?: XOR<SavedScanNullableRelationFilter, SavedScanWhereInput> | null
  }

  export type BacktestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    savedScanId?: SortOrderInput | SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    timeframe?: SortOrder
    definition?: SortOrder
    status?: SortOrder
    results?: SortOrderInput | SortOrder
    totalMatches?: SortOrderInput | SortOrder
    avgReturn?: SortOrderInput | SortOrder
    winRate?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    savedScan?: SavedScanOrderByWithRelationInput
  }

  export type BacktestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BacktestWhereInput | BacktestWhereInput[]
    OR?: BacktestWhereInput[]
    NOT?: BacktestWhereInput | BacktestWhereInput[]
    userId?: StringFilter<"Backtest"> | string
    savedScanId?: StringNullableFilter<"Backtest"> | string | null
    name?: StringFilter<"Backtest"> | string
    startDate?: DateTimeFilter<"Backtest"> | Date | string
    endDate?: DateTimeFilter<"Backtest"> | Date | string
    timeframe?: EnumTimeframeFilter<"Backtest"> | $Enums.Timeframe
    definition?: JsonFilter<"Backtest">
    status?: EnumBacktestStatusFilter<"Backtest"> | $Enums.BacktestStatus
    results?: JsonNullableFilter<"Backtest">
    totalMatches?: IntNullableFilter<"Backtest"> | number | null
    avgReturn?: DecimalNullableFilter<"Backtest"> | Decimal | DecimalJsLike | number | string | null
    winRate?: DecimalNullableFilter<"Backtest"> | Decimal | DecimalJsLike | number | string | null
    errorMessage?: StringNullableFilter<"Backtest"> | string | null
    createdAt?: DateTimeFilter<"Backtest"> | Date | string
    updatedAt?: DateTimeFilter<"Backtest"> | Date | string
    startedAt?: DateTimeNullableFilter<"Backtest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Backtest"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    savedScan?: XOR<SavedScanNullableRelationFilter, SavedScanWhereInput> | null
  }, "id">

  export type BacktestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    savedScanId?: SortOrderInput | SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    timeframe?: SortOrder
    definition?: SortOrder
    status?: SortOrder
    results?: SortOrderInput | SortOrder
    totalMatches?: SortOrderInput | SortOrder
    avgReturn?: SortOrderInput | SortOrder
    winRate?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: BacktestCountOrderByAggregateInput
    _avg?: BacktestAvgOrderByAggregateInput
    _max?: BacktestMaxOrderByAggregateInput
    _min?: BacktestMinOrderByAggregateInput
    _sum?: BacktestSumOrderByAggregateInput
  }

  export type BacktestScalarWhereWithAggregatesInput = {
    AND?: BacktestScalarWhereWithAggregatesInput | BacktestScalarWhereWithAggregatesInput[]
    OR?: BacktestScalarWhereWithAggregatesInput[]
    NOT?: BacktestScalarWhereWithAggregatesInput | BacktestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Backtest"> | string
    userId?: StringWithAggregatesFilter<"Backtest"> | string
    savedScanId?: StringNullableWithAggregatesFilter<"Backtest"> | string | null
    name?: StringWithAggregatesFilter<"Backtest"> | string
    startDate?: DateTimeWithAggregatesFilter<"Backtest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Backtest"> | Date | string
    timeframe?: EnumTimeframeWithAggregatesFilter<"Backtest"> | $Enums.Timeframe
    definition?: JsonWithAggregatesFilter<"Backtest">
    status?: EnumBacktestStatusWithAggregatesFilter<"Backtest"> | $Enums.BacktestStatus
    results?: JsonNullableWithAggregatesFilter<"Backtest">
    totalMatches?: IntNullableWithAggregatesFilter<"Backtest"> | number | null
    avgReturn?: DecimalNullableWithAggregatesFilter<"Backtest"> | Decimal | DecimalJsLike | number | string | null
    winRate?: DecimalNullableWithAggregatesFilter<"Backtest"> | Decimal | DecimalJsLike | number | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"Backtest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Backtest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Backtest"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"Backtest"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Backtest"> | Date | string | null
  }

  export type FinancialMetricWhereInput = {
    AND?: FinancialMetricWhereInput | FinancialMetricWhereInput[]
    OR?: FinancialMetricWhereInput[]
    NOT?: FinancialMetricWhereInput | FinancialMetricWhereInput[]
    id?: StringFilter<"FinancialMetric"> | string
    symbolId?: StringFilter<"FinancialMetric"> | string
    metric?: JsonFilter<"FinancialMetric">
    fetchedAt?: DateTimeFilter<"FinancialMetric"> | Date | string
    symbol?: XOR<SymbolRelationFilter, SymbolWhereInput>
  }

  export type FinancialMetricOrderByWithRelationInput = {
    id?: SortOrder
    symbolId?: SortOrder
    metric?: SortOrder
    fetchedAt?: SortOrder
    symbol?: SymbolOrderByWithRelationInput
  }

  export type FinancialMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FinancialMetricWhereInput | FinancialMetricWhereInput[]
    OR?: FinancialMetricWhereInput[]
    NOT?: FinancialMetricWhereInput | FinancialMetricWhereInput[]
    symbolId?: StringFilter<"FinancialMetric"> | string
    metric?: JsonFilter<"FinancialMetric">
    fetchedAt?: DateTimeFilter<"FinancialMetric"> | Date | string
    symbol?: XOR<SymbolRelationFilter, SymbolWhereInput>
  }, "id">

  export type FinancialMetricOrderByWithAggregationInput = {
    id?: SortOrder
    symbolId?: SortOrder
    metric?: SortOrder
    fetchedAt?: SortOrder
    _count?: FinancialMetricCountOrderByAggregateInput
    _max?: FinancialMetricMaxOrderByAggregateInput
    _min?: FinancialMetricMinOrderByAggregateInput
  }

  export type FinancialMetricScalarWhereWithAggregatesInput = {
    AND?: FinancialMetricScalarWhereWithAggregatesInput | FinancialMetricScalarWhereWithAggregatesInput[]
    OR?: FinancialMetricScalarWhereWithAggregatesInput[]
    NOT?: FinancialMetricScalarWhereWithAggregatesInput | FinancialMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinancialMetric"> | string
    symbolId?: StringWithAggregatesFilter<"FinancialMetric"> | string
    metric?: JsonWithAggregatesFilter<"FinancialMetric">
    fetchedAt?: DateTimeWithAggregatesFilter<"FinancialMetric"> | Date | string
  }

  export type SystemStatusWhereInput = {
    AND?: SystemStatusWhereInput | SystemStatusWhereInput[]
    OR?: SystemStatusWhereInput[]
    NOT?: SystemStatusWhereInput | SystemStatusWhereInput[]
    key?: StringFilter<"SystemStatus"> | string
    lastRun?: DateTimeFilter<"SystemStatus"> | Date | string
    status?: StringFilter<"SystemStatus"> | string
    message?: StringNullableFilter<"SystemStatus"> | string | null
    updatedAt?: DateTimeFilter<"SystemStatus"> | Date | string
  }

  export type SystemStatusOrderByWithRelationInput = {
    key?: SortOrder
    lastRun?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type SystemStatusWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: SystemStatusWhereInput | SystemStatusWhereInput[]
    OR?: SystemStatusWhereInput[]
    NOT?: SystemStatusWhereInput | SystemStatusWhereInput[]
    lastRun?: DateTimeFilter<"SystemStatus"> | Date | string
    status?: StringFilter<"SystemStatus"> | string
    message?: StringNullableFilter<"SystemStatus"> | string | null
    updatedAt?: DateTimeFilter<"SystemStatus"> | Date | string
  }, "key">

  export type SystemStatusOrderByWithAggregationInput = {
    key?: SortOrder
    lastRun?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: SystemStatusCountOrderByAggregateInput
    _max?: SystemStatusMaxOrderByAggregateInput
    _min?: SystemStatusMinOrderByAggregateInput
  }

  export type SystemStatusScalarWhereWithAggregatesInput = {
    AND?: SystemStatusScalarWhereWithAggregatesInput | SystemStatusScalarWhereWithAggregatesInput[]
    OR?: SystemStatusScalarWhereWithAggregatesInput[]
    NOT?: SystemStatusScalarWhereWithAggregatesInput | SystemStatusScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"SystemStatus"> | string
    lastRun?: DateTimeWithAggregatesFilter<"SystemStatus"> | Date | string
    status?: StringWithAggregatesFilter<"SystemStatus"> | string
    message?: StringNullableWithAggregatesFilter<"SystemStatus"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SystemStatus"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    googleId?: string | null
    picture?: string | null
    apiCallsToday?: number
    lastApiReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    watchlists?: WatchlistCreateNestedManyWithoutUserInput
    savedScans?: SavedScanCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    backtests?: BacktestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    googleId?: string | null
    picture?: string | null
    apiCallsToday?: number
    lastApiReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    watchlists?: WatchlistUncheckedCreateNestedManyWithoutUserInput
    savedScans?: SavedScanUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    backtests?: BacktestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallsToday?: IntFieldUpdateOperationsInput | number
    lastApiReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchlists?: WatchlistUpdateManyWithoutUserNestedInput
    savedScans?: SavedScanUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    backtests?: BacktestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallsToday?: IntFieldUpdateOperationsInput | number
    lastApiReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchlists?: WatchlistUncheckedUpdateManyWithoutUserNestedInput
    savedScans?: SavedScanUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    backtests?: BacktestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    googleId?: string | null
    picture?: string | null
    apiCallsToday?: number
    lastApiReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallsToday?: IntFieldUpdateOperationsInput | number
    lastApiReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallsToday?: IntFieldUpdateOperationsInput | number
    lastApiReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SymbolCreateInput = {
    id?: string
    ticker: string
    name: string
    exchange: $Enums.Exchange
    currency?: string
    sector?: string | null
    industry?: string | null
    marketCap?: bigint | number | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    ipo?: Date | string | null
    delistDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    candles?: CandleCreateNestedManyWithoutSymbolInput
    indicators?: IndicatorCacheCreateNestedManyWithoutSymbolInput
    watchlistSymbols?: WatchlistSymbolCreateNestedManyWithoutSymbolInput
    financialMetrics?: FinancialMetricCreateNestedManyWithoutSymbolInput
  }

  export type SymbolUncheckedCreateInput = {
    id?: string
    ticker: string
    name: string
    exchange: $Enums.Exchange
    currency?: string
    sector?: string | null
    industry?: string | null
    marketCap?: bigint | number | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    ipo?: Date | string | null
    delistDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    candles?: CandleUncheckedCreateNestedManyWithoutSymbolInput
    indicators?: IndicatorCacheUncheckedCreateNestedManyWithoutSymbolInput
    watchlistSymbols?: WatchlistSymbolUncheckedCreateNestedManyWithoutSymbolInput
    financialMetrics?: FinancialMetricUncheckedCreateNestedManyWithoutSymbolInput
  }

  export type SymbolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange?: EnumExchangeFieldUpdateOperationsInput | $Enums.Exchange
    currency?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delistDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candles?: CandleUpdateManyWithoutSymbolNestedInput
    indicators?: IndicatorCacheUpdateManyWithoutSymbolNestedInput
    watchlistSymbols?: WatchlistSymbolUpdateManyWithoutSymbolNestedInput
    financialMetrics?: FinancialMetricUpdateManyWithoutSymbolNestedInput
  }

  export type SymbolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange?: EnumExchangeFieldUpdateOperationsInput | $Enums.Exchange
    currency?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delistDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candles?: CandleUncheckedUpdateManyWithoutSymbolNestedInput
    indicators?: IndicatorCacheUncheckedUpdateManyWithoutSymbolNestedInput
    watchlistSymbols?: WatchlistSymbolUncheckedUpdateManyWithoutSymbolNestedInput
    financialMetrics?: FinancialMetricUncheckedUpdateManyWithoutSymbolNestedInput
  }

  export type SymbolCreateManyInput = {
    id?: string
    ticker: string
    name: string
    exchange: $Enums.Exchange
    currency?: string
    sector?: string | null
    industry?: string | null
    marketCap?: bigint | number | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    ipo?: Date | string | null
    delistDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
  }

  export type SymbolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange?: EnumExchangeFieldUpdateOperationsInput | $Enums.Exchange
    currency?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delistDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SymbolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange?: EnumExchangeFieldUpdateOperationsInput | $Enums.Exchange
    currency?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delistDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CandleCreateInput = {
    id?: string
    timeframe: $Enums.Timeframe
    timestamp: Date | string
    open: Decimal | DecimalJsLike | number | string
    high: Decimal | DecimalJsLike | number | string
    low: Decimal | DecimalJsLike | number | string
    close: Decimal | DecimalJsLike | number | string
    volume: bigint | number
    createdAt?: Date | string
    symbol: SymbolCreateNestedOneWithoutCandlesInput
  }

  export type CandleUncheckedCreateInput = {
    id?: string
    symbolId: string
    timeframe: $Enums.Timeframe
    timestamp: Date | string
    open: Decimal | DecimalJsLike | number | string
    high: Decimal | DecimalJsLike | number | string
    low: Decimal | DecimalJsLike | number | string
    close: Decimal | DecimalJsLike | number | string
    volume: bigint | number
    createdAt?: Date | string
  }

  export type CandleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    high?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    low?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    close?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbol?: SymbolUpdateOneRequiredWithoutCandlesNestedInput
  }

  export type CandleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbolId?: StringFieldUpdateOperationsInput | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    high?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    low?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    close?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandleCreateManyInput = {
    id?: string
    symbolId: string
    timeframe: $Enums.Timeframe
    timestamp: Date | string
    open: Decimal | DecimalJsLike | number | string
    high: Decimal | DecimalJsLike | number | string
    low: Decimal | DecimalJsLike | number | string
    close: Decimal | DecimalJsLike | number | string
    volume: bigint | number
    createdAt?: Date | string
  }

  export type CandleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    high?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    low?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    close?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbolId?: StringFieldUpdateOperationsInput | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    high?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    low?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    close?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCacheCreateInput = {
    id?: string
    indicator: $Enums.IndicatorType
    timeframe: $Enums.Timeframe
    period: number
    timestamp: Date | string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    symbol: SymbolCreateNestedOneWithoutIndicatorsInput
  }

  export type IndicatorCacheUncheckedCreateInput = {
    id?: string
    symbolId: string
    indicator: $Enums.IndicatorType
    timeframe: $Enums.Timeframe
    period: number
    timestamp: Date | string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type IndicatorCacheUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicator?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    period?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbol?: SymbolUpdateOneRequiredWithoutIndicatorsNestedInput
  }

  export type IndicatorCacheUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbolId?: StringFieldUpdateOperationsInput | string
    indicator?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    period?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCacheCreateManyInput = {
    id?: string
    symbolId: string
    indicator: $Enums.IndicatorType
    timeframe: $Enums.Timeframe
    period: number
    timestamp: Date | string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type IndicatorCacheUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicator?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    period?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCacheUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbolId?: StringFieldUpdateOperationsInput | string
    indicator?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    period?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistCreateInput = {
    id?: string
    name: string
    description?: string | null
    isPublic?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWatchlistsInput
    symbols?: WatchlistSymbolCreateNestedManyWithoutWatchlistInput
  }

  export type WatchlistUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    isPublic?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    symbols?: WatchlistSymbolUncheckedCreateNestedManyWithoutWatchlistInput
  }

  export type WatchlistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchlistsNestedInput
    symbols?: WatchlistSymbolUpdateManyWithoutWatchlistNestedInput
  }

  export type WatchlistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbols?: WatchlistSymbolUncheckedUpdateManyWithoutWatchlistNestedInput
  }

  export type WatchlistCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    isPublic?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WatchlistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistSymbolCreateInput = {
    id?: string
    notes?: string | null
    addedAt?: Date | string
    watchlist: WatchlistCreateNestedOneWithoutSymbolsInput
    symbol: SymbolCreateNestedOneWithoutWatchlistSymbolsInput
  }

  export type WatchlistSymbolUncheckedCreateInput = {
    id?: string
    watchlistId: string
    symbolId: string
    notes?: string | null
    addedAt?: Date | string
  }

  export type WatchlistSymbolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlist?: WatchlistUpdateOneRequiredWithoutSymbolsNestedInput
    symbol?: SymbolUpdateOneRequiredWithoutWatchlistSymbolsNestedInput
  }

  export type WatchlistSymbolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchlistId?: StringFieldUpdateOperationsInput | string
    symbolId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistSymbolCreateManyInput = {
    id?: string
    watchlistId: string
    symbolId: string
    notes?: string | null
    addedAt?: Date | string
  }

  export type WatchlistSymbolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistSymbolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchlistId?: StringFieldUpdateOperationsInput | string
    symbolId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedScanCreateInput = {
    id?: string
    name: string
    description?: string | null
    definition: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanCreatesymbolUniverseInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
    user: UserCreateNestedOneWithoutSavedScansInput
    backtests?: BacktestCreateNestedManyWithoutSavedScanInput
    versions?: SavedScanVersionCreateNestedManyWithoutSavedScanInput
  }

  export type SavedScanUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    definition: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanCreatesymbolUniverseInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
    backtests?: BacktestUncheckedCreateNestedManyWithoutSavedScanInput
    versions?: SavedScanVersionUncheckedCreateNestedManyWithoutSavedScanInput
  }

  export type SavedScanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanUpdatesymbolUniverseInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSavedScansNestedInput
    backtests?: BacktestUpdateManyWithoutSavedScanNestedInput
    versions?: SavedScanVersionUpdateManyWithoutSavedScanNestedInput
  }

  export type SavedScanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanUpdatesymbolUniverseInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    backtests?: BacktestUncheckedUpdateManyWithoutSavedScanNestedInput
    versions?: SavedScanVersionUncheckedUpdateManyWithoutSavedScanNestedInput
  }

  export type SavedScanCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    definition: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanCreatesymbolUniverseInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
  }

  export type SavedScanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanUpdatesymbolUniverseInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedScanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanUpdatesymbolUniverseInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedScanVersionCreateInput = {
    id?: string
    versionNumber: number
    definition: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdById?: string | null
    comment?: string | null
    savedScan: SavedScanCreateNestedOneWithoutVersionsInput
  }

  export type SavedScanVersionUncheckedCreateInput = {
    id?: string
    savedScanId: string
    versionNumber: number
    definition: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdById?: string | null
    comment?: string | null
  }

  export type SavedScanVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    definition?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    savedScan?: SavedScanUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type SavedScanVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    savedScanId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    definition?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SavedScanVersionCreateManyInput = {
    id?: string
    savedScanId: string
    versionNumber: number
    definition: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdById?: string | null
    comment?: string | null
  }

  export type SavedScanVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    definition?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SavedScanVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    savedScanId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    definition?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertCreateInput = {
    id?: string
    name: string
    alertType: $Enums.AlertType
    condition: JsonNullValueInput | InputJsonValue
    ticker?: string | null
    status?: $Enums.AlertStatus
    emailNotify?: boolean
    pushNotify?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    triggeredAt?: Date | string | null
    user: UserCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    alertType: $Enums.AlertType
    condition: JsonNullValueInput | InputJsonValue
    ticker?: string | null
    status?: $Enums.AlertStatus
    emailNotify?: boolean
    pushNotify?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    triggeredAt?: Date | string | null
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    condition?: JsonNullValueInput | InputJsonValue
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    emailNotify?: BoolFieldUpdateOperationsInput | boolean
    pushNotify?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    condition?: JsonNullValueInput | InputJsonValue
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    emailNotify?: BoolFieldUpdateOperationsInput | boolean
    pushNotify?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertCreateManyInput = {
    id?: string
    userId: string
    name: string
    alertType: $Enums.AlertType
    condition: JsonNullValueInput | InputJsonValue
    ticker?: string | null
    status?: $Enums.AlertStatus
    emailNotify?: boolean
    pushNotify?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    triggeredAt?: Date | string | null
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    condition?: JsonNullValueInput | InputJsonValue
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    emailNotify?: BoolFieldUpdateOperationsInput | boolean
    pushNotify?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    condition?: JsonNullValueInput | InputJsonValue
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    emailNotify?: BoolFieldUpdateOperationsInput | boolean
    pushNotify?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BacktestCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    timeframe: $Enums.Timeframe
    definition: JsonNullValueInput | InputJsonValue
    status?: $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: number | null
    avgReturn?: Decimal | DecimalJsLike | number | string | null
    winRate?: Decimal | DecimalJsLike | number | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBacktestsInput
    savedScan?: SavedScanCreateNestedOneWithoutBacktestsInput
  }

  export type BacktestUncheckedCreateInput = {
    id?: string
    userId: string
    savedScanId?: string | null
    name: string
    startDate: Date | string
    endDate: Date | string
    timeframe: $Enums.Timeframe
    definition: JsonNullValueInput | InputJsonValue
    status?: $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: number | null
    avgReturn?: Decimal | DecimalJsLike | number | string | null
    winRate?: Decimal | DecimalJsLike | number | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type BacktestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    definition?: JsonNullValueInput | InputJsonValue
    status?: EnumBacktestStatusFieldUpdateOperationsInput | $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: NullableIntFieldUpdateOperationsInput | number | null
    avgReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBacktestsNestedInput
    savedScan?: SavedScanUpdateOneWithoutBacktestsNestedInput
  }

  export type BacktestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    savedScanId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    definition?: JsonNullValueInput | InputJsonValue
    status?: EnumBacktestStatusFieldUpdateOperationsInput | $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: NullableIntFieldUpdateOperationsInput | number | null
    avgReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BacktestCreateManyInput = {
    id?: string
    userId: string
    savedScanId?: string | null
    name: string
    startDate: Date | string
    endDate: Date | string
    timeframe: $Enums.Timeframe
    definition: JsonNullValueInput | InputJsonValue
    status?: $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: number | null
    avgReturn?: Decimal | DecimalJsLike | number | string | null
    winRate?: Decimal | DecimalJsLike | number | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type BacktestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    definition?: JsonNullValueInput | InputJsonValue
    status?: EnumBacktestStatusFieldUpdateOperationsInput | $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: NullableIntFieldUpdateOperationsInput | number | null
    avgReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BacktestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    savedScanId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    definition?: JsonNullValueInput | InputJsonValue
    status?: EnumBacktestStatusFieldUpdateOperationsInput | $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: NullableIntFieldUpdateOperationsInput | number | null
    avgReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinancialMetricCreateInput = {
    id?: string
    metric: JsonNullValueInput | InputJsonValue
    fetchedAt?: Date | string
    symbol: SymbolCreateNestedOneWithoutFinancialMetricsInput
  }

  export type FinancialMetricUncheckedCreateInput = {
    id?: string
    symbolId: string
    metric: JsonNullValueInput | InputJsonValue
    fetchedAt?: Date | string
  }

  export type FinancialMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metric?: JsonNullValueInput | InputJsonValue
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbol?: SymbolUpdateOneRequiredWithoutFinancialMetricsNestedInput
  }

  export type FinancialMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbolId?: StringFieldUpdateOperationsInput | string
    metric?: JsonNullValueInput | InputJsonValue
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialMetricCreateManyInput = {
    id?: string
    symbolId: string
    metric: JsonNullValueInput | InputJsonValue
    fetchedAt?: Date | string
  }

  export type FinancialMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metric?: JsonNullValueInput | InputJsonValue
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbolId?: StringFieldUpdateOperationsInput | string
    metric?: JsonNullValueInput | InputJsonValue
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemStatusCreateInput = {
    key: string
    lastRun: Date | string
    status: string
    message?: string | null
    updatedAt?: Date | string
  }

  export type SystemStatusUncheckedCreateInput = {
    key: string
    lastRun: Date | string
    status: string
    message?: string | null
    updatedAt?: Date | string
  }

  export type SystemStatusUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    lastRun?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemStatusUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    lastRun?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemStatusCreateManyInput = {
    key: string
    lastRun: Date | string
    status: string
    message?: string | null
    updatedAt?: Date | string
  }

  export type SystemStatusUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    lastRun?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemStatusUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    lastRun?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type WatchlistListRelationFilter = {
    every?: WatchlistWhereInput
    some?: WatchlistWhereInput
    none?: WatchlistWhereInput
  }

  export type SavedScanListRelationFilter = {
    every?: SavedScanWhereInput
    some?: SavedScanWhereInput
    none?: SavedScanWhereInput
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type BacktestListRelationFilter = {
    every?: BacktestWhereInput
    some?: BacktestWhereInput
    none?: BacktestWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type WatchlistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedScanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BacktestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    googleId?: SortOrder
    picture?: SortOrder
    apiCallsToday?: SortOrder
    lastApiReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    apiCallsToday?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    googleId?: SortOrder
    picture?: SortOrder
    apiCallsToday?: SortOrder
    lastApiReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    status?: SortOrder
    googleId?: SortOrder
    picture?: SortOrder
    apiCallsToday?: SortOrder
    lastApiReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    apiCallsToday?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumExchangeFilter<$PrismaModel = never> = {
    equals?: $Enums.Exchange | EnumExchangeFieldRefInput<$PrismaModel>
    in?: $Enums.Exchange[] | ListEnumExchangeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Exchange[] | ListEnumExchangeFieldRefInput<$PrismaModel>
    not?: NestedEnumExchangeFilter<$PrismaModel> | $Enums.Exchange
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CandleListRelationFilter = {
    every?: CandleWhereInput
    some?: CandleWhereInput
    none?: CandleWhereInput
  }

  export type IndicatorCacheListRelationFilter = {
    every?: IndicatorCacheWhereInput
    some?: IndicatorCacheWhereInput
    none?: IndicatorCacheWhereInput
  }

  export type WatchlistSymbolListRelationFilter = {
    every?: WatchlistSymbolWhereInput
    some?: WatchlistSymbolWhereInput
    none?: WatchlistSymbolWhereInput
  }

  export type FinancialMetricListRelationFilter = {
    every?: FinancialMetricWhereInput
    some?: FinancialMetricWhereInput
    none?: FinancialMetricWhereInput
  }

  export type CandleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IndicatorCacheOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WatchlistSymbolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SymbolCountOrderByAggregateInput = {
    id?: SortOrder
    ticker?: SortOrder
    name?: SortOrder
    exchange?: SortOrder
    currency?: SortOrder
    sector?: SortOrder
    industry?: SortOrder
    marketCap?: SortOrder
    description?: SortOrder
    website?: SortOrder
    isActive?: SortOrder
    ipo?: SortOrder
    delistDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncedAt?: SortOrder
  }

  export type SymbolAvgOrderByAggregateInput = {
    marketCap?: SortOrder
  }

  export type SymbolMaxOrderByAggregateInput = {
    id?: SortOrder
    ticker?: SortOrder
    name?: SortOrder
    exchange?: SortOrder
    currency?: SortOrder
    sector?: SortOrder
    industry?: SortOrder
    marketCap?: SortOrder
    description?: SortOrder
    website?: SortOrder
    isActive?: SortOrder
    ipo?: SortOrder
    delistDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncedAt?: SortOrder
  }

  export type SymbolMinOrderByAggregateInput = {
    id?: SortOrder
    ticker?: SortOrder
    name?: SortOrder
    exchange?: SortOrder
    currency?: SortOrder
    sector?: SortOrder
    industry?: SortOrder
    marketCap?: SortOrder
    description?: SortOrder
    website?: SortOrder
    isActive?: SortOrder
    ipo?: SortOrder
    delistDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncedAt?: SortOrder
  }

  export type SymbolSumOrderByAggregateInput = {
    marketCap?: SortOrder
  }

  export type EnumExchangeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Exchange | EnumExchangeFieldRefInput<$PrismaModel>
    in?: $Enums.Exchange[] | ListEnumExchangeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Exchange[] | ListEnumExchangeFieldRefInput<$PrismaModel>
    not?: NestedEnumExchangeWithAggregatesFilter<$PrismaModel> | $Enums.Exchange
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExchangeFilter<$PrismaModel>
    _max?: NestedEnumExchangeFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumTimeframeFilter<$PrismaModel = never> = {
    equals?: $Enums.Timeframe | EnumTimeframeFieldRefInput<$PrismaModel>
    in?: $Enums.Timeframe[] | ListEnumTimeframeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Timeframe[] | ListEnumTimeframeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeframeFilter<$PrismaModel> | $Enums.Timeframe
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type SymbolRelationFilter = {
    is?: SymbolWhereInput
    isNot?: SymbolWhereInput
  }

  export type CandleSymbolIdTimeframeTimestampCompoundUniqueInput = {
    symbolId: string
    timeframe: $Enums.Timeframe
    timestamp: Date | string
  }

  export type CandleCountOrderByAggregateInput = {
    id?: SortOrder
    symbolId?: SortOrder
    timeframe?: SortOrder
    timestamp?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    volume?: SortOrder
    createdAt?: SortOrder
  }

  export type CandleAvgOrderByAggregateInput = {
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    volume?: SortOrder
  }

  export type CandleMaxOrderByAggregateInput = {
    id?: SortOrder
    symbolId?: SortOrder
    timeframe?: SortOrder
    timestamp?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    volume?: SortOrder
    createdAt?: SortOrder
  }

  export type CandleMinOrderByAggregateInput = {
    id?: SortOrder
    symbolId?: SortOrder
    timeframe?: SortOrder
    timestamp?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    volume?: SortOrder
    createdAt?: SortOrder
  }

  export type CandleSumOrderByAggregateInput = {
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    volume?: SortOrder
  }

  export type EnumTimeframeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Timeframe | EnumTimeframeFieldRefInput<$PrismaModel>
    in?: $Enums.Timeframe[] | ListEnumTimeframeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Timeframe[] | ListEnumTimeframeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeframeWithAggregatesFilter<$PrismaModel> | $Enums.Timeframe
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTimeframeFilter<$PrismaModel>
    _max?: NestedEnumTimeframeFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumIndicatorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IndicatorType | EnumIndicatorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIndicatorTypeFilter<$PrismaModel> | $Enums.IndicatorType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IndicatorCacheSymbolIdIndicatorTimeframePeriodTimestampCompoundUniqueInput = {
    symbolId: string
    indicator: $Enums.IndicatorType
    timeframe: $Enums.Timeframe
    period: number
    timestamp: Date | string
  }

  export type IndicatorCacheCountOrderByAggregateInput = {
    id?: SortOrder
    symbolId?: SortOrder
    indicator?: SortOrder
    timeframe?: SortOrder
    period?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type IndicatorCacheAvgOrderByAggregateInput = {
    period?: SortOrder
  }

  export type IndicatorCacheMaxOrderByAggregateInput = {
    id?: SortOrder
    symbolId?: SortOrder
    indicator?: SortOrder
    timeframe?: SortOrder
    period?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type IndicatorCacheMinOrderByAggregateInput = {
    id?: SortOrder
    symbolId?: SortOrder
    indicator?: SortOrder
    timeframe?: SortOrder
    period?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type IndicatorCacheSumOrderByAggregateInput = {
    period?: SortOrder
  }

  export type EnumIndicatorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IndicatorType | EnumIndicatorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIndicatorTypeWithAggregatesFilter<$PrismaModel> | $Enums.IndicatorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIndicatorTypeFilter<$PrismaModel>
    _max?: NestedEnumIndicatorTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type WatchlistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WatchlistAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type WatchlistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WatchlistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WatchlistSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type WatchlistRelationFilter = {
    is?: WatchlistWhereInput
    isNot?: WatchlistWhereInput
  }

  export type WatchlistSymbolWatchlistIdSymbolIdCompoundUniqueInput = {
    watchlistId: string
    symbolId: string
  }

  export type WatchlistSymbolCountOrderByAggregateInput = {
    id?: SortOrder
    watchlistId?: SortOrder
    symbolId?: SortOrder
    notes?: SortOrder
    addedAt?: SortOrder
  }

  export type WatchlistSymbolMaxOrderByAggregateInput = {
    id?: SortOrder
    watchlistId?: SortOrder
    symbolId?: SortOrder
    notes?: SortOrder
    addedAt?: SortOrder
  }

  export type WatchlistSymbolMinOrderByAggregateInput = {
    id?: SortOrder
    watchlistId?: SortOrder
    symbolId?: SortOrder
    notes?: SortOrder
    addedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SavedScanVersionListRelationFilter = {
    every?: SavedScanVersionWhereInput
    some?: SavedScanVersionWhereInput
    none?: SavedScanVersionWhereInput
  }

  export type SavedScanVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedScanCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    definition?: SortOrder
    symbolUniverse?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrder
  }

  export type SavedScanMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrder
  }

  export type SavedScanMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrder
  }

  export type SavedScanRelationFilter = {
    is?: SavedScanWhereInput
    isNot?: SavedScanWhereInput
  }

  export type SavedScanVersionSavedScanIdVersionNumberCompoundUniqueInput = {
    savedScanId: string
    versionNumber: number
  }

  export type SavedScanVersionCountOrderByAggregateInput = {
    id?: SortOrder
    savedScanId?: SortOrder
    versionNumber?: SortOrder
    definition?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    comment?: SortOrder
  }

  export type SavedScanVersionAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type SavedScanVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    savedScanId?: SortOrder
    versionNumber?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    comment?: SortOrder
  }

  export type SavedScanVersionMinOrderByAggregateInput = {
    id?: SortOrder
    savedScanId?: SortOrder
    versionNumber?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    comment?: SortOrder
  }

  export type SavedScanVersionSumOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type EnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type EnumAlertStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusFilter<$PrismaModel> | $Enums.AlertStatus
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    alertType?: SortOrder
    condition?: SortOrder
    ticker?: SortOrder
    status?: SortOrder
    emailNotify?: SortOrder
    pushNotify?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggeredAt?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    alertType?: SortOrder
    ticker?: SortOrder
    status?: SortOrder
    emailNotify?: SortOrder
    pushNotify?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggeredAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    alertType?: SortOrder
    ticker?: SortOrder
    status?: SortOrder
    emailNotify?: SortOrder
    pushNotify?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggeredAt?: SortOrder
  }

  export type EnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type EnumAlertStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertStatusFilter<$PrismaModel>
  }

  export type EnumBacktestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BacktestStatus | EnumBacktestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BacktestStatus[] | ListEnumBacktestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BacktestStatus[] | ListEnumBacktestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBacktestStatusFilter<$PrismaModel> | $Enums.BacktestStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type SavedScanNullableRelationFilter = {
    is?: SavedScanWhereInput | null
    isNot?: SavedScanWhereInput | null
  }

  export type BacktestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    savedScanId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    timeframe?: SortOrder
    definition?: SortOrder
    status?: SortOrder
    results?: SortOrder
    totalMatches?: SortOrder
    avgReturn?: SortOrder
    winRate?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BacktestAvgOrderByAggregateInput = {
    totalMatches?: SortOrder
    avgReturn?: SortOrder
    winRate?: SortOrder
  }

  export type BacktestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    savedScanId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    timeframe?: SortOrder
    status?: SortOrder
    totalMatches?: SortOrder
    avgReturn?: SortOrder
    winRate?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BacktestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    savedScanId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    timeframe?: SortOrder
    status?: SortOrder
    totalMatches?: SortOrder
    avgReturn?: SortOrder
    winRate?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BacktestSumOrderByAggregateInput = {
    totalMatches?: SortOrder
    avgReturn?: SortOrder
    winRate?: SortOrder
  }

  export type EnumBacktestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BacktestStatus | EnumBacktestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BacktestStatus[] | ListEnumBacktestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BacktestStatus[] | ListEnumBacktestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBacktestStatusWithAggregatesFilter<$PrismaModel> | $Enums.BacktestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBacktestStatusFilter<$PrismaModel>
    _max?: NestedEnumBacktestStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type FinancialMetricCountOrderByAggregateInput = {
    id?: SortOrder
    symbolId?: SortOrder
    metric?: SortOrder
    fetchedAt?: SortOrder
  }

  export type FinancialMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    symbolId?: SortOrder
    fetchedAt?: SortOrder
  }

  export type FinancialMetricMinOrderByAggregateInput = {
    id?: SortOrder
    symbolId?: SortOrder
    fetchedAt?: SortOrder
  }

  export type SystemStatusCountOrderByAggregateInput = {
    key?: SortOrder
    lastRun?: SortOrder
    status?: SortOrder
    message?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemStatusMaxOrderByAggregateInput = {
    key?: SortOrder
    lastRun?: SortOrder
    status?: SortOrder
    message?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemStatusMinOrderByAggregateInput = {
    key?: SortOrder
    lastRun?: SortOrder
    status?: SortOrder
    message?: SortOrder
    updatedAt?: SortOrder
  }

  export type WatchlistCreateNestedManyWithoutUserInput = {
    create?: XOR<WatchlistCreateWithoutUserInput, WatchlistUncheckedCreateWithoutUserInput> | WatchlistCreateWithoutUserInput[] | WatchlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistCreateOrConnectWithoutUserInput | WatchlistCreateOrConnectWithoutUserInput[]
    createMany?: WatchlistCreateManyUserInputEnvelope
    connect?: WatchlistWhereUniqueInput | WatchlistWhereUniqueInput[]
  }

  export type SavedScanCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedScanCreateWithoutUserInput, SavedScanUncheckedCreateWithoutUserInput> | SavedScanCreateWithoutUserInput[] | SavedScanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedScanCreateOrConnectWithoutUserInput | SavedScanCreateOrConnectWithoutUserInput[]
    createMany?: SavedScanCreateManyUserInputEnvelope
    connect?: SavedScanWhereUniqueInput | SavedScanWhereUniqueInput[]
  }

  export type AlertCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type BacktestCreateNestedManyWithoutUserInput = {
    create?: XOR<BacktestCreateWithoutUserInput, BacktestUncheckedCreateWithoutUserInput> | BacktestCreateWithoutUserInput[] | BacktestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BacktestCreateOrConnectWithoutUserInput | BacktestCreateOrConnectWithoutUserInput[]
    createMany?: BacktestCreateManyUserInputEnvelope
    connect?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
  }

  export type WatchlistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WatchlistCreateWithoutUserInput, WatchlistUncheckedCreateWithoutUserInput> | WatchlistCreateWithoutUserInput[] | WatchlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistCreateOrConnectWithoutUserInput | WatchlistCreateOrConnectWithoutUserInput[]
    createMany?: WatchlistCreateManyUserInputEnvelope
    connect?: WatchlistWhereUniqueInput | WatchlistWhereUniqueInput[]
  }

  export type SavedScanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedScanCreateWithoutUserInput, SavedScanUncheckedCreateWithoutUserInput> | SavedScanCreateWithoutUserInput[] | SavedScanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedScanCreateOrConnectWithoutUserInput | SavedScanCreateOrConnectWithoutUserInput[]
    createMany?: SavedScanCreateManyUserInputEnvelope
    connect?: SavedScanWhereUniqueInput | SavedScanWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type BacktestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BacktestCreateWithoutUserInput, BacktestUncheckedCreateWithoutUserInput> | BacktestCreateWithoutUserInput[] | BacktestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BacktestCreateOrConnectWithoutUserInput | BacktestCreateOrConnectWithoutUserInput[]
    createMany?: BacktestCreateManyUserInputEnvelope
    connect?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type WatchlistUpdateManyWithoutUserNestedInput = {
    create?: XOR<WatchlistCreateWithoutUserInput, WatchlistUncheckedCreateWithoutUserInput> | WatchlistCreateWithoutUserInput[] | WatchlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistCreateOrConnectWithoutUserInput | WatchlistCreateOrConnectWithoutUserInput[]
    upsert?: WatchlistUpsertWithWhereUniqueWithoutUserInput | WatchlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WatchlistCreateManyUserInputEnvelope
    set?: WatchlistWhereUniqueInput | WatchlistWhereUniqueInput[]
    disconnect?: WatchlistWhereUniqueInput | WatchlistWhereUniqueInput[]
    delete?: WatchlistWhereUniqueInput | WatchlistWhereUniqueInput[]
    connect?: WatchlistWhereUniqueInput | WatchlistWhereUniqueInput[]
    update?: WatchlistUpdateWithWhereUniqueWithoutUserInput | WatchlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WatchlistUpdateManyWithWhereWithoutUserInput | WatchlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WatchlistScalarWhereInput | WatchlistScalarWhereInput[]
  }

  export type SavedScanUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedScanCreateWithoutUserInput, SavedScanUncheckedCreateWithoutUserInput> | SavedScanCreateWithoutUserInput[] | SavedScanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedScanCreateOrConnectWithoutUserInput | SavedScanCreateOrConnectWithoutUserInput[]
    upsert?: SavedScanUpsertWithWhereUniqueWithoutUserInput | SavedScanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedScanCreateManyUserInputEnvelope
    set?: SavedScanWhereUniqueInput | SavedScanWhereUniqueInput[]
    disconnect?: SavedScanWhereUniqueInput | SavedScanWhereUniqueInput[]
    delete?: SavedScanWhereUniqueInput | SavedScanWhereUniqueInput[]
    connect?: SavedScanWhereUniqueInput | SavedScanWhereUniqueInput[]
    update?: SavedScanUpdateWithWhereUniqueWithoutUserInput | SavedScanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedScanUpdateManyWithWhereWithoutUserInput | SavedScanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedScanScalarWhereInput | SavedScanScalarWhereInput[]
  }

  export type AlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutUserInput | AlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutUserInput | AlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutUserInput | AlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type BacktestUpdateManyWithoutUserNestedInput = {
    create?: XOR<BacktestCreateWithoutUserInput, BacktestUncheckedCreateWithoutUserInput> | BacktestCreateWithoutUserInput[] | BacktestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BacktestCreateOrConnectWithoutUserInput | BacktestCreateOrConnectWithoutUserInput[]
    upsert?: BacktestUpsertWithWhereUniqueWithoutUserInput | BacktestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BacktestCreateManyUserInputEnvelope
    set?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    disconnect?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    delete?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    connect?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    update?: BacktestUpdateWithWhereUniqueWithoutUserInput | BacktestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BacktestUpdateManyWithWhereWithoutUserInput | BacktestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BacktestScalarWhereInput | BacktestScalarWhereInput[]
  }

  export type WatchlistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WatchlistCreateWithoutUserInput, WatchlistUncheckedCreateWithoutUserInput> | WatchlistCreateWithoutUserInput[] | WatchlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchlistCreateOrConnectWithoutUserInput | WatchlistCreateOrConnectWithoutUserInput[]
    upsert?: WatchlistUpsertWithWhereUniqueWithoutUserInput | WatchlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WatchlistCreateManyUserInputEnvelope
    set?: WatchlistWhereUniqueInput | WatchlistWhereUniqueInput[]
    disconnect?: WatchlistWhereUniqueInput | WatchlistWhereUniqueInput[]
    delete?: WatchlistWhereUniqueInput | WatchlistWhereUniqueInput[]
    connect?: WatchlistWhereUniqueInput | WatchlistWhereUniqueInput[]
    update?: WatchlistUpdateWithWhereUniqueWithoutUserInput | WatchlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WatchlistUpdateManyWithWhereWithoutUserInput | WatchlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WatchlistScalarWhereInput | WatchlistScalarWhereInput[]
  }

  export type SavedScanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedScanCreateWithoutUserInput, SavedScanUncheckedCreateWithoutUserInput> | SavedScanCreateWithoutUserInput[] | SavedScanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedScanCreateOrConnectWithoutUserInput | SavedScanCreateOrConnectWithoutUserInput[]
    upsert?: SavedScanUpsertWithWhereUniqueWithoutUserInput | SavedScanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedScanCreateManyUserInputEnvelope
    set?: SavedScanWhereUniqueInput | SavedScanWhereUniqueInput[]
    disconnect?: SavedScanWhereUniqueInput | SavedScanWhereUniqueInput[]
    delete?: SavedScanWhereUniqueInput | SavedScanWhereUniqueInput[]
    connect?: SavedScanWhereUniqueInput | SavedScanWhereUniqueInput[]
    update?: SavedScanUpdateWithWhereUniqueWithoutUserInput | SavedScanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedScanUpdateManyWithWhereWithoutUserInput | SavedScanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedScanScalarWhereInput | SavedScanScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutUserInput | AlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutUserInput | AlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutUserInput | AlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type BacktestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BacktestCreateWithoutUserInput, BacktestUncheckedCreateWithoutUserInput> | BacktestCreateWithoutUserInput[] | BacktestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BacktestCreateOrConnectWithoutUserInput | BacktestCreateOrConnectWithoutUserInput[]
    upsert?: BacktestUpsertWithWhereUniqueWithoutUserInput | BacktestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BacktestCreateManyUserInputEnvelope
    set?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    disconnect?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    delete?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    connect?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    update?: BacktestUpdateWithWhereUniqueWithoutUserInput | BacktestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BacktestUpdateManyWithWhereWithoutUserInput | BacktestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BacktestScalarWhereInput | BacktestScalarWhereInput[]
  }

  export type CandleCreateNestedManyWithoutSymbolInput = {
    create?: XOR<CandleCreateWithoutSymbolInput, CandleUncheckedCreateWithoutSymbolInput> | CandleCreateWithoutSymbolInput[] | CandleUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: CandleCreateOrConnectWithoutSymbolInput | CandleCreateOrConnectWithoutSymbolInput[]
    createMany?: CandleCreateManySymbolInputEnvelope
    connect?: CandleWhereUniqueInput | CandleWhereUniqueInput[]
  }

  export type IndicatorCacheCreateNestedManyWithoutSymbolInput = {
    create?: XOR<IndicatorCacheCreateWithoutSymbolInput, IndicatorCacheUncheckedCreateWithoutSymbolInput> | IndicatorCacheCreateWithoutSymbolInput[] | IndicatorCacheUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: IndicatorCacheCreateOrConnectWithoutSymbolInput | IndicatorCacheCreateOrConnectWithoutSymbolInput[]
    createMany?: IndicatorCacheCreateManySymbolInputEnvelope
    connect?: IndicatorCacheWhereUniqueInput | IndicatorCacheWhereUniqueInput[]
  }

  export type WatchlistSymbolCreateNestedManyWithoutSymbolInput = {
    create?: XOR<WatchlistSymbolCreateWithoutSymbolInput, WatchlistSymbolUncheckedCreateWithoutSymbolInput> | WatchlistSymbolCreateWithoutSymbolInput[] | WatchlistSymbolUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: WatchlistSymbolCreateOrConnectWithoutSymbolInput | WatchlistSymbolCreateOrConnectWithoutSymbolInput[]
    createMany?: WatchlistSymbolCreateManySymbolInputEnvelope
    connect?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
  }

  export type FinancialMetricCreateNestedManyWithoutSymbolInput = {
    create?: XOR<FinancialMetricCreateWithoutSymbolInput, FinancialMetricUncheckedCreateWithoutSymbolInput> | FinancialMetricCreateWithoutSymbolInput[] | FinancialMetricUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: FinancialMetricCreateOrConnectWithoutSymbolInput | FinancialMetricCreateOrConnectWithoutSymbolInput[]
    createMany?: FinancialMetricCreateManySymbolInputEnvelope
    connect?: FinancialMetricWhereUniqueInput | FinancialMetricWhereUniqueInput[]
  }

  export type CandleUncheckedCreateNestedManyWithoutSymbolInput = {
    create?: XOR<CandleCreateWithoutSymbolInput, CandleUncheckedCreateWithoutSymbolInput> | CandleCreateWithoutSymbolInput[] | CandleUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: CandleCreateOrConnectWithoutSymbolInput | CandleCreateOrConnectWithoutSymbolInput[]
    createMany?: CandleCreateManySymbolInputEnvelope
    connect?: CandleWhereUniqueInput | CandleWhereUniqueInput[]
  }

  export type IndicatorCacheUncheckedCreateNestedManyWithoutSymbolInput = {
    create?: XOR<IndicatorCacheCreateWithoutSymbolInput, IndicatorCacheUncheckedCreateWithoutSymbolInput> | IndicatorCacheCreateWithoutSymbolInput[] | IndicatorCacheUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: IndicatorCacheCreateOrConnectWithoutSymbolInput | IndicatorCacheCreateOrConnectWithoutSymbolInput[]
    createMany?: IndicatorCacheCreateManySymbolInputEnvelope
    connect?: IndicatorCacheWhereUniqueInput | IndicatorCacheWhereUniqueInput[]
  }

  export type WatchlistSymbolUncheckedCreateNestedManyWithoutSymbolInput = {
    create?: XOR<WatchlistSymbolCreateWithoutSymbolInput, WatchlistSymbolUncheckedCreateWithoutSymbolInput> | WatchlistSymbolCreateWithoutSymbolInput[] | WatchlistSymbolUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: WatchlistSymbolCreateOrConnectWithoutSymbolInput | WatchlistSymbolCreateOrConnectWithoutSymbolInput[]
    createMany?: WatchlistSymbolCreateManySymbolInputEnvelope
    connect?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
  }

  export type FinancialMetricUncheckedCreateNestedManyWithoutSymbolInput = {
    create?: XOR<FinancialMetricCreateWithoutSymbolInput, FinancialMetricUncheckedCreateWithoutSymbolInput> | FinancialMetricCreateWithoutSymbolInput[] | FinancialMetricUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: FinancialMetricCreateOrConnectWithoutSymbolInput | FinancialMetricCreateOrConnectWithoutSymbolInput[]
    createMany?: FinancialMetricCreateManySymbolInputEnvelope
    connect?: FinancialMetricWhereUniqueInput | FinancialMetricWhereUniqueInput[]
  }

  export type EnumExchangeFieldUpdateOperationsInput = {
    set?: $Enums.Exchange
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CandleUpdateManyWithoutSymbolNestedInput = {
    create?: XOR<CandleCreateWithoutSymbolInput, CandleUncheckedCreateWithoutSymbolInput> | CandleCreateWithoutSymbolInput[] | CandleUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: CandleCreateOrConnectWithoutSymbolInput | CandleCreateOrConnectWithoutSymbolInput[]
    upsert?: CandleUpsertWithWhereUniqueWithoutSymbolInput | CandleUpsertWithWhereUniqueWithoutSymbolInput[]
    createMany?: CandleCreateManySymbolInputEnvelope
    set?: CandleWhereUniqueInput | CandleWhereUniqueInput[]
    disconnect?: CandleWhereUniqueInput | CandleWhereUniqueInput[]
    delete?: CandleWhereUniqueInput | CandleWhereUniqueInput[]
    connect?: CandleWhereUniqueInput | CandleWhereUniqueInput[]
    update?: CandleUpdateWithWhereUniqueWithoutSymbolInput | CandleUpdateWithWhereUniqueWithoutSymbolInput[]
    updateMany?: CandleUpdateManyWithWhereWithoutSymbolInput | CandleUpdateManyWithWhereWithoutSymbolInput[]
    deleteMany?: CandleScalarWhereInput | CandleScalarWhereInput[]
  }

  export type IndicatorCacheUpdateManyWithoutSymbolNestedInput = {
    create?: XOR<IndicatorCacheCreateWithoutSymbolInput, IndicatorCacheUncheckedCreateWithoutSymbolInput> | IndicatorCacheCreateWithoutSymbolInput[] | IndicatorCacheUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: IndicatorCacheCreateOrConnectWithoutSymbolInput | IndicatorCacheCreateOrConnectWithoutSymbolInput[]
    upsert?: IndicatorCacheUpsertWithWhereUniqueWithoutSymbolInput | IndicatorCacheUpsertWithWhereUniqueWithoutSymbolInput[]
    createMany?: IndicatorCacheCreateManySymbolInputEnvelope
    set?: IndicatorCacheWhereUniqueInput | IndicatorCacheWhereUniqueInput[]
    disconnect?: IndicatorCacheWhereUniqueInput | IndicatorCacheWhereUniqueInput[]
    delete?: IndicatorCacheWhereUniqueInput | IndicatorCacheWhereUniqueInput[]
    connect?: IndicatorCacheWhereUniqueInput | IndicatorCacheWhereUniqueInput[]
    update?: IndicatorCacheUpdateWithWhereUniqueWithoutSymbolInput | IndicatorCacheUpdateWithWhereUniqueWithoutSymbolInput[]
    updateMany?: IndicatorCacheUpdateManyWithWhereWithoutSymbolInput | IndicatorCacheUpdateManyWithWhereWithoutSymbolInput[]
    deleteMany?: IndicatorCacheScalarWhereInput | IndicatorCacheScalarWhereInput[]
  }

  export type WatchlistSymbolUpdateManyWithoutSymbolNestedInput = {
    create?: XOR<WatchlistSymbolCreateWithoutSymbolInput, WatchlistSymbolUncheckedCreateWithoutSymbolInput> | WatchlistSymbolCreateWithoutSymbolInput[] | WatchlistSymbolUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: WatchlistSymbolCreateOrConnectWithoutSymbolInput | WatchlistSymbolCreateOrConnectWithoutSymbolInput[]
    upsert?: WatchlistSymbolUpsertWithWhereUniqueWithoutSymbolInput | WatchlistSymbolUpsertWithWhereUniqueWithoutSymbolInput[]
    createMany?: WatchlistSymbolCreateManySymbolInputEnvelope
    set?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    disconnect?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    delete?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    connect?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    update?: WatchlistSymbolUpdateWithWhereUniqueWithoutSymbolInput | WatchlistSymbolUpdateWithWhereUniqueWithoutSymbolInput[]
    updateMany?: WatchlistSymbolUpdateManyWithWhereWithoutSymbolInput | WatchlistSymbolUpdateManyWithWhereWithoutSymbolInput[]
    deleteMany?: WatchlistSymbolScalarWhereInput | WatchlistSymbolScalarWhereInput[]
  }

  export type FinancialMetricUpdateManyWithoutSymbolNestedInput = {
    create?: XOR<FinancialMetricCreateWithoutSymbolInput, FinancialMetricUncheckedCreateWithoutSymbolInput> | FinancialMetricCreateWithoutSymbolInput[] | FinancialMetricUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: FinancialMetricCreateOrConnectWithoutSymbolInput | FinancialMetricCreateOrConnectWithoutSymbolInput[]
    upsert?: FinancialMetricUpsertWithWhereUniqueWithoutSymbolInput | FinancialMetricUpsertWithWhereUniqueWithoutSymbolInput[]
    createMany?: FinancialMetricCreateManySymbolInputEnvelope
    set?: FinancialMetricWhereUniqueInput | FinancialMetricWhereUniqueInput[]
    disconnect?: FinancialMetricWhereUniqueInput | FinancialMetricWhereUniqueInput[]
    delete?: FinancialMetricWhereUniqueInput | FinancialMetricWhereUniqueInput[]
    connect?: FinancialMetricWhereUniqueInput | FinancialMetricWhereUniqueInput[]
    update?: FinancialMetricUpdateWithWhereUniqueWithoutSymbolInput | FinancialMetricUpdateWithWhereUniqueWithoutSymbolInput[]
    updateMany?: FinancialMetricUpdateManyWithWhereWithoutSymbolInput | FinancialMetricUpdateManyWithWhereWithoutSymbolInput[]
    deleteMany?: FinancialMetricScalarWhereInput | FinancialMetricScalarWhereInput[]
  }

  export type CandleUncheckedUpdateManyWithoutSymbolNestedInput = {
    create?: XOR<CandleCreateWithoutSymbolInput, CandleUncheckedCreateWithoutSymbolInput> | CandleCreateWithoutSymbolInput[] | CandleUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: CandleCreateOrConnectWithoutSymbolInput | CandleCreateOrConnectWithoutSymbolInput[]
    upsert?: CandleUpsertWithWhereUniqueWithoutSymbolInput | CandleUpsertWithWhereUniqueWithoutSymbolInput[]
    createMany?: CandleCreateManySymbolInputEnvelope
    set?: CandleWhereUniqueInput | CandleWhereUniqueInput[]
    disconnect?: CandleWhereUniqueInput | CandleWhereUniqueInput[]
    delete?: CandleWhereUniqueInput | CandleWhereUniqueInput[]
    connect?: CandleWhereUniqueInput | CandleWhereUniqueInput[]
    update?: CandleUpdateWithWhereUniqueWithoutSymbolInput | CandleUpdateWithWhereUniqueWithoutSymbolInput[]
    updateMany?: CandleUpdateManyWithWhereWithoutSymbolInput | CandleUpdateManyWithWhereWithoutSymbolInput[]
    deleteMany?: CandleScalarWhereInput | CandleScalarWhereInput[]
  }

  export type IndicatorCacheUncheckedUpdateManyWithoutSymbolNestedInput = {
    create?: XOR<IndicatorCacheCreateWithoutSymbolInput, IndicatorCacheUncheckedCreateWithoutSymbolInput> | IndicatorCacheCreateWithoutSymbolInput[] | IndicatorCacheUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: IndicatorCacheCreateOrConnectWithoutSymbolInput | IndicatorCacheCreateOrConnectWithoutSymbolInput[]
    upsert?: IndicatorCacheUpsertWithWhereUniqueWithoutSymbolInput | IndicatorCacheUpsertWithWhereUniqueWithoutSymbolInput[]
    createMany?: IndicatorCacheCreateManySymbolInputEnvelope
    set?: IndicatorCacheWhereUniqueInput | IndicatorCacheWhereUniqueInput[]
    disconnect?: IndicatorCacheWhereUniqueInput | IndicatorCacheWhereUniqueInput[]
    delete?: IndicatorCacheWhereUniqueInput | IndicatorCacheWhereUniqueInput[]
    connect?: IndicatorCacheWhereUniqueInput | IndicatorCacheWhereUniqueInput[]
    update?: IndicatorCacheUpdateWithWhereUniqueWithoutSymbolInput | IndicatorCacheUpdateWithWhereUniqueWithoutSymbolInput[]
    updateMany?: IndicatorCacheUpdateManyWithWhereWithoutSymbolInput | IndicatorCacheUpdateManyWithWhereWithoutSymbolInput[]
    deleteMany?: IndicatorCacheScalarWhereInput | IndicatorCacheScalarWhereInput[]
  }

  export type WatchlistSymbolUncheckedUpdateManyWithoutSymbolNestedInput = {
    create?: XOR<WatchlistSymbolCreateWithoutSymbolInput, WatchlistSymbolUncheckedCreateWithoutSymbolInput> | WatchlistSymbolCreateWithoutSymbolInput[] | WatchlistSymbolUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: WatchlistSymbolCreateOrConnectWithoutSymbolInput | WatchlistSymbolCreateOrConnectWithoutSymbolInput[]
    upsert?: WatchlistSymbolUpsertWithWhereUniqueWithoutSymbolInput | WatchlistSymbolUpsertWithWhereUniqueWithoutSymbolInput[]
    createMany?: WatchlistSymbolCreateManySymbolInputEnvelope
    set?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    disconnect?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    delete?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    connect?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    update?: WatchlistSymbolUpdateWithWhereUniqueWithoutSymbolInput | WatchlistSymbolUpdateWithWhereUniqueWithoutSymbolInput[]
    updateMany?: WatchlistSymbolUpdateManyWithWhereWithoutSymbolInput | WatchlistSymbolUpdateManyWithWhereWithoutSymbolInput[]
    deleteMany?: WatchlistSymbolScalarWhereInput | WatchlistSymbolScalarWhereInput[]
  }

  export type FinancialMetricUncheckedUpdateManyWithoutSymbolNestedInput = {
    create?: XOR<FinancialMetricCreateWithoutSymbolInput, FinancialMetricUncheckedCreateWithoutSymbolInput> | FinancialMetricCreateWithoutSymbolInput[] | FinancialMetricUncheckedCreateWithoutSymbolInput[]
    connectOrCreate?: FinancialMetricCreateOrConnectWithoutSymbolInput | FinancialMetricCreateOrConnectWithoutSymbolInput[]
    upsert?: FinancialMetricUpsertWithWhereUniqueWithoutSymbolInput | FinancialMetricUpsertWithWhereUniqueWithoutSymbolInput[]
    createMany?: FinancialMetricCreateManySymbolInputEnvelope
    set?: FinancialMetricWhereUniqueInput | FinancialMetricWhereUniqueInput[]
    disconnect?: FinancialMetricWhereUniqueInput | FinancialMetricWhereUniqueInput[]
    delete?: FinancialMetricWhereUniqueInput | FinancialMetricWhereUniqueInput[]
    connect?: FinancialMetricWhereUniqueInput | FinancialMetricWhereUniqueInput[]
    update?: FinancialMetricUpdateWithWhereUniqueWithoutSymbolInput | FinancialMetricUpdateWithWhereUniqueWithoutSymbolInput[]
    updateMany?: FinancialMetricUpdateManyWithWhereWithoutSymbolInput | FinancialMetricUpdateManyWithWhereWithoutSymbolInput[]
    deleteMany?: FinancialMetricScalarWhereInput | FinancialMetricScalarWhereInput[]
  }

  export type SymbolCreateNestedOneWithoutCandlesInput = {
    create?: XOR<SymbolCreateWithoutCandlesInput, SymbolUncheckedCreateWithoutCandlesInput>
    connectOrCreate?: SymbolCreateOrConnectWithoutCandlesInput
    connect?: SymbolWhereUniqueInput
  }

  export type EnumTimeframeFieldUpdateOperationsInput = {
    set?: $Enums.Timeframe
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type SymbolUpdateOneRequiredWithoutCandlesNestedInput = {
    create?: XOR<SymbolCreateWithoutCandlesInput, SymbolUncheckedCreateWithoutCandlesInput>
    connectOrCreate?: SymbolCreateOrConnectWithoutCandlesInput
    upsert?: SymbolUpsertWithoutCandlesInput
    connect?: SymbolWhereUniqueInput
    update?: XOR<XOR<SymbolUpdateToOneWithWhereWithoutCandlesInput, SymbolUpdateWithoutCandlesInput>, SymbolUncheckedUpdateWithoutCandlesInput>
  }

  export type SymbolCreateNestedOneWithoutIndicatorsInput = {
    create?: XOR<SymbolCreateWithoutIndicatorsInput, SymbolUncheckedCreateWithoutIndicatorsInput>
    connectOrCreate?: SymbolCreateOrConnectWithoutIndicatorsInput
    connect?: SymbolWhereUniqueInput
  }

  export type EnumIndicatorTypeFieldUpdateOperationsInput = {
    set?: $Enums.IndicatorType
  }

  export type SymbolUpdateOneRequiredWithoutIndicatorsNestedInput = {
    create?: XOR<SymbolCreateWithoutIndicatorsInput, SymbolUncheckedCreateWithoutIndicatorsInput>
    connectOrCreate?: SymbolCreateOrConnectWithoutIndicatorsInput
    upsert?: SymbolUpsertWithoutIndicatorsInput
    connect?: SymbolWhereUniqueInput
    update?: XOR<XOR<SymbolUpdateToOneWithWhereWithoutIndicatorsInput, SymbolUpdateWithoutIndicatorsInput>, SymbolUncheckedUpdateWithoutIndicatorsInput>
  }

  export type UserCreateNestedOneWithoutWatchlistsInput = {
    create?: XOR<UserCreateWithoutWatchlistsInput, UserUncheckedCreateWithoutWatchlistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchlistsInput
    connect?: UserWhereUniqueInput
  }

  export type WatchlistSymbolCreateNestedManyWithoutWatchlistInput = {
    create?: XOR<WatchlistSymbolCreateWithoutWatchlistInput, WatchlistSymbolUncheckedCreateWithoutWatchlistInput> | WatchlistSymbolCreateWithoutWatchlistInput[] | WatchlistSymbolUncheckedCreateWithoutWatchlistInput[]
    connectOrCreate?: WatchlistSymbolCreateOrConnectWithoutWatchlistInput | WatchlistSymbolCreateOrConnectWithoutWatchlistInput[]
    createMany?: WatchlistSymbolCreateManyWatchlistInputEnvelope
    connect?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
  }

  export type WatchlistSymbolUncheckedCreateNestedManyWithoutWatchlistInput = {
    create?: XOR<WatchlistSymbolCreateWithoutWatchlistInput, WatchlistSymbolUncheckedCreateWithoutWatchlistInput> | WatchlistSymbolCreateWithoutWatchlistInput[] | WatchlistSymbolUncheckedCreateWithoutWatchlistInput[]
    connectOrCreate?: WatchlistSymbolCreateOrConnectWithoutWatchlistInput | WatchlistSymbolCreateOrConnectWithoutWatchlistInput[]
    createMany?: WatchlistSymbolCreateManyWatchlistInputEnvelope
    connect?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWatchlistsNestedInput = {
    create?: XOR<UserCreateWithoutWatchlistsInput, UserUncheckedCreateWithoutWatchlistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchlistsInput
    upsert?: UserUpsertWithoutWatchlistsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWatchlistsInput, UserUpdateWithoutWatchlistsInput>, UserUncheckedUpdateWithoutWatchlistsInput>
  }

  export type WatchlistSymbolUpdateManyWithoutWatchlistNestedInput = {
    create?: XOR<WatchlistSymbolCreateWithoutWatchlistInput, WatchlistSymbolUncheckedCreateWithoutWatchlistInput> | WatchlistSymbolCreateWithoutWatchlistInput[] | WatchlistSymbolUncheckedCreateWithoutWatchlistInput[]
    connectOrCreate?: WatchlistSymbolCreateOrConnectWithoutWatchlistInput | WatchlistSymbolCreateOrConnectWithoutWatchlistInput[]
    upsert?: WatchlistSymbolUpsertWithWhereUniqueWithoutWatchlistInput | WatchlistSymbolUpsertWithWhereUniqueWithoutWatchlistInput[]
    createMany?: WatchlistSymbolCreateManyWatchlistInputEnvelope
    set?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    disconnect?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    delete?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    connect?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    update?: WatchlistSymbolUpdateWithWhereUniqueWithoutWatchlistInput | WatchlistSymbolUpdateWithWhereUniqueWithoutWatchlistInput[]
    updateMany?: WatchlistSymbolUpdateManyWithWhereWithoutWatchlistInput | WatchlistSymbolUpdateManyWithWhereWithoutWatchlistInput[]
    deleteMany?: WatchlistSymbolScalarWhereInput | WatchlistSymbolScalarWhereInput[]
  }

  export type WatchlistSymbolUncheckedUpdateManyWithoutWatchlistNestedInput = {
    create?: XOR<WatchlistSymbolCreateWithoutWatchlistInput, WatchlistSymbolUncheckedCreateWithoutWatchlistInput> | WatchlistSymbolCreateWithoutWatchlistInput[] | WatchlistSymbolUncheckedCreateWithoutWatchlistInput[]
    connectOrCreate?: WatchlistSymbolCreateOrConnectWithoutWatchlistInput | WatchlistSymbolCreateOrConnectWithoutWatchlistInput[]
    upsert?: WatchlistSymbolUpsertWithWhereUniqueWithoutWatchlistInput | WatchlistSymbolUpsertWithWhereUniqueWithoutWatchlistInput[]
    createMany?: WatchlistSymbolCreateManyWatchlistInputEnvelope
    set?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    disconnect?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    delete?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    connect?: WatchlistSymbolWhereUniqueInput | WatchlistSymbolWhereUniqueInput[]
    update?: WatchlistSymbolUpdateWithWhereUniqueWithoutWatchlistInput | WatchlistSymbolUpdateWithWhereUniqueWithoutWatchlistInput[]
    updateMany?: WatchlistSymbolUpdateManyWithWhereWithoutWatchlistInput | WatchlistSymbolUpdateManyWithWhereWithoutWatchlistInput[]
    deleteMany?: WatchlistSymbolScalarWhereInput | WatchlistSymbolScalarWhereInput[]
  }

  export type WatchlistCreateNestedOneWithoutSymbolsInput = {
    create?: XOR<WatchlistCreateWithoutSymbolsInput, WatchlistUncheckedCreateWithoutSymbolsInput>
    connectOrCreate?: WatchlistCreateOrConnectWithoutSymbolsInput
    connect?: WatchlistWhereUniqueInput
  }

  export type SymbolCreateNestedOneWithoutWatchlistSymbolsInput = {
    create?: XOR<SymbolCreateWithoutWatchlistSymbolsInput, SymbolUncheckedCreateWithoutWatchlistSymbolsInput>
    connectOrCreate?: SymbolCreateOrConnectWithoutWatchlistSymbolsInput
    connect?: SymbolWhereUniqueInput
  }

  export type WatchlistUpdateOneRequiredWithoutSymbolsNestedInput = {
    create?: XOR<WatchlistCreateWithoutSymbolsInput, WatchlistUncheckedCreateWithoutSymbolsInput>
    connectOrCreate?: WatchlistCreateOrConnectWithoutSymbolsInput
    upsert?: WatchlistUpsertWithoutSymbolsInput
    connect?: WatchlistWhereUniqueInput
    update?: XOR<XOR<WatchlistUpdateToOneWithWhereWithoutSymbolsInput, WatchlistUpdateWithoutSymbolsInput>, WatchlistUncheckedUpdateWithoutSymbolsInput>
  }

  export type SymbolUpdateOneRequiredWithoutWatchlistSymbolsNestedInput = {
    create?: XOR<SymbolCreateWithoutWatchlistSymbolsInput, SymbolUncheckedCreateWithoutWatchlistSymbolsInput>
    connectOrCreate?: SymbolCreateOrConnectWithoutWatchlistSymbolsInput
    upsert?: SymbolUpsertWithoutWatchlistSymbolsInput
    connect?: SymbolWhereUniqueInput
    update?: XOR<XOR<SymbolUpdateToOneWithWhereWithoutWatchlistSymbolsInput, SymbolUpdateWithoutWatchlistSymbolsInput>, SymbolUncheckedUpdateWithoutWatchlistSymbolsInput>
  }

  export type SavedScanCreatesymbolUniverseInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSavedScansInput = {
    create?: XOR<UserCreateWithoutSavedScansInput, UserUncheckedCreateWithoutSavedScansInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedScansInput
    connect?: UserWhereUniqueInput
  }

  export type BacktestCreateNestedManyWithoutSavedScanInput = {
    create?: XOR<BacktestCreateWithoutSavedScanInput, BacktestUncheckedCreateWithoutSavedScanInput> | BacktestCreateWithoutSavedScanInput[] | BacktestUncheckedCreateWithoutSavedScanInput[]
    connectOrCreate?: BacktestCreateOrConnectWithoutSavedScanInput | BacktestCreateOrConnectWithoutSavedScanInput[]
    createMany?: BacktestCreateManySavedScanInputEnvelope
    connect?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
  }

  export type SavedScanVersionCreateNestedManyWithoutSavedScanInput = {
    create?: XOR<SavedScanVersionCreateWithoutSavedScanInput, SavedScanVersionUncheckedCreateWithoutSavedScanInput> | SavedScanVersionCreateWithoutSavedScanInput[] | SavedScanVersionUncheckedCreateWithoutSavedScanInput[]
    connectOrCreate?: SavedScanVersionCreateOrConnectWithoutSavedScanInput | SavedScanVersionCreateOrConnectWithoutSavedScanInput[]
    createMany?: SavedScanVersionCreateManySavedScanInputEnvelope
    connect?: SavedScanVersionWhereUniqueInput | SavedScanVersionWhereUniqueInput[]
  }

  export type BacktestUncheckedCreateNestedManyWithoutSavedScanInput = {
    create?: XOR<BacktestCreateWithoutSavedScanInput, BacktestUncheckedCreateWithoutSavedScanInput> | BacktestCreateWithoutSavedScanInput[] | BacktestUncheckedCreateWithoutSavedScanInput[]
    connectOrCreate?: BacktestCreateOrConnectWithoutSavedScanInput | BacktestCreateOrConnectWithoutSavedScanInput[]
    createMany?: BacktestCreateManySavedScanInputEnvelope
    connect?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
  }

  export type SavedScanVersionUncheckedCreateNestedManyWithoutSavedScanInput = {
    create?: XOR<SavedScanVersionCreateWithoutSavedScanInput, SavedScanVersionUncheckedCreateWithoutSavedScanInput> | SavedScanVersionCreateWithoutSavedScanInput[] | SavedScanVersionUncheckedCreateWithoutSavedScanInput[]
    connectOrCreate?: SavedScanVersionCreateOrConnectWithoutSavedScanInput | SavedScanVersionCreateOrConnectWithoutSavedScanInput[]
    createMany?: SavedScanVersionCreateManySavedScanInputEnvelope
    connect?: SavedScanVersionWhereUniqueInput | SavedScanVersionWhereUniqueInput[]
  }

  export type SavedScanUpdatesymbolUniverseInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutSavedScansNestedInput = {
    create?: XOR<UserCreateWithoutSavedScansInput, UserUncheckedCreateWithoutSavedScansInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedScansInput
    upsert?: UserUpsertWithoutSavedScansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedScansInput, UserUpdateWithoutSavedScansInput>, UserUncheckedUpdateWithoutSavedScansInput>
  }

  export type BacktestUpdateManyWithoutSavedScanNestedInput = {
    create?: XOR<BacktestCreateWithoutSavedScanInput, BacktestUncheckedCreateWithoutSavedScanInput> | BacktestCreateWithoutSavedScanInput[] | BacktestUncheckedCreateWithoutSavedScanInput[]
    connectOrCreate?: BacktestCreateOrConnectWithoutSavedScanInput | BacktestCreateOrConnectWithoutSavedScanInput[]
    upsert?: BacktestUpsertWithWhereUniqueWithoutSavedScanInput | BacktestUpsertWithWhereUniqueWithoutSavedScanInput[]
    createMany?: BacktestCreateManySavedScanInputEnvelope
    set?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    disconnect?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    delete?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    connect?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    update?: BacktestUpdateWithWhereUniqueWithoutSavedScanInput | BacktestUpdateWithWhereUniqueWithoutSavedScanInput[]
    updateMany?: BacktestUpdateManyWithWhereWithoutSavedScanInput | BacktestUpdateManyWithWhereWithoutSavedScanInput[]
    deleteMany?: BacktestScalarWhereInput | BacktestScalarWhereInput[]
  }

  export type SavedScanVersionUpdateManyWithoutSavedScanNestedInput = {
    create?: XOR<SavedScanVersionCreateWithoutSavedScanInput, SavedScanVersionUncheckedCreateWithoutSavedScanInput> | SavedScanVersionCreateWithoutSavedScanInput[] | SavedScanVersionUncheckedCreateWithoutSavedScanInput[]
    connectOrCreate?: SavedScanVersionCreateOrConnectWithoutSavedScanInput | SavedScanVersionCreateOrConnectWithoutSavedScanInput[]
    upsert?: SavedScanVersionUpsertWithWhereUniqueWithoutSavedScanInput | SavedScanVersionUpsertWithWhereUniqueWithoutSavedScanInput[]
    createMany?: SavedScanVersionCreateManySavedScanInputEnvelope
    set?: SavedScanVersionWhereUniqueInput | SavedScanVersionWhereUniqueInput[]
    disconnect?: SavedScanVersionWhereUniqueInput | SavedScanVersionWhereUniqueInput[]
    delete?: SavedScanVersionWhereUniqueInput | SavedScanVersionWhereUniqueInput[]
    connect?: SavedScanVersionWhereUniqueInput | SavedScanVersionWhereUniqueInput[]
    update?: SavedScanVersionUpdateWithWhereUniqueWithoutSavedScanInput | SavedScanVersionUpdateWithWhereUniqueWithoutSavedScanInput[]
    updateMany?: SavedScanVersionUpdateManyWithWhereWithoutSavedScanInput | SavedScanVersionUpdateManyWithWhereWithoutSavedScanInput[]
    deleteMany?: SavedScanVersionScalarWhereInput | SavedScanVersionScalarWhereInput[]
  }

  export type BacktestUncheckedUpdateManyWithoutSavedScanNestedInput = {
    create?: XOR<BacktestCreateWithoutSavedScanInput, BacktestUncheckedCreateWithoutSavedScanInput> | BacktestCreateWithoutSavedScanInput[] | BacktestUncheckedCreateWithoutSavedScanInput[]
    connectOrCreate?: BacktestCreateOrConnectWithoutSavedScanInput | BacktestCreateOrConnectWithoutSavedScanInput[]
    upsert?: BacktestUpsertWithWhereUniqueWithoutSavedScanInput | BacktestUpsertWithWhereUniqueWithoutSavedScanInput[]
    createMany?: BacktestCreateManySavedScanInputEnvelope
    set?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    disconnect?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    delete?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    connect?: BacktestWhereUniqueInput | BacktestWhereUniqueInput[]
    update?: BacktestUpdateWithWhereUniqueWithoutSavedScanInput | BacktestUpdateWithWhereUniqueWithoutSavedScanInput[]
    updateMany?: BacktestUpdateManyWithWhereWithoutSavedScanInput | BacktestUpdateManyWithWhereWithoutSavedScanInput[]
    deleteMany?: BacktestScalarWhereInput | BacktestScalarWhereInput[]
  }

  export type SavedScanVersionUncheckedUpdateManyWithoutSavedScanNestedInput = {
    create?: XOR<SavedScanVersionCreateWithoutSavedScanInput, SavedScanVersionUncheckedCreateWithoutSavedScanInput> | SavedScanVersionCreateWithoutSavedScanInput[] | SavedScanVersionUncheckedCreateWithoutSavedScanInput[]
    connectOrCreate?: SavedScanVersionCreateOrConnectWithoutSavedScanInput | SavedScanVersionCreateOrConnectWithoutSavedScanInput[]
    upsert?: SavedScanVersionUpsertWithWhereUniqueWithoutSavedScanInput | SavedScanVersionUpsertWithWhereUniqueWithoutSavedScanInput[]
    createMany?: SavedScanVersionCreateManySavedScanInputEnvelope
    set?: SavedScanVersionWhereUniqueInput | SavedScanVersionWhereUniqueInput[]
    disconnect?: SavedScanVersionWhereUniqueInput | SavedScanVersionWhereUniqueInput[]
    delete?: SavedScanVersionWhereUniqueInput | SavedScanVersionWhereUniqueInput[]
    connect?: SavedScanVersionWhereUniqueInput | SavedScanVersionWhereUniqueInput[]
    update?: SavedScanVersionUpdateWithWhereUniqueWithoutSavedScanInput | SavedScanVersionUpdateWithWhereUniqueWithoutSavedScanInput[]
    updateMany?: SavedScanVersionUpdateManyWithWhereWithoutSavedScanInput | SavedScanVersionUpdateManyWithWhereWithoutSavedScanInput[]
    deleteMany?: SavedScanVersionScalarWhereInput | SavedScanVersionScalarWhereInput[]
  }

  export type SavedScanCreateNestedOneWithoutVersionsInput = {
    create?: XOR<SavedScanCreateWithoutVersionsInput, SavedScanUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: SavedScanCreateOrConnectWithoutVersionsInput
    connect?: SavedScanWhereUniqueInput
  }

  export type SavedScanUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<SavedScanCreateWithoutVersionsInput, SavedScanUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: SavedScanCreateOrConnectWithoutVersionsInput
    upsert?: SavedScanUpsertWithoutVersionsInput
    connect?: SavedScanWhereUniqueInput
    update?: XOR<XOR<SavedScanUpdateToOneWithWhereWithoutVersionsInput, SavedScanUpdateWithoutVersionsInput>, SavedScanUncheckedUpdateWithoutVersionsInput>
  }

  export type UserCreateNestedOneWithoutAlertsInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAlertTypeFieldUpdateOperationsInput = {
    set?: $Enums.AlertType
  }

  export type EnumAlertStatusFieldUpdateOperationsInput = {
    set?: $Enums.AlertStatus
  }

  export type UserUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    upsert?: UserUpsertWithoutAlertsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAlertsInput, UserUpdateWithoutAlertsInput>, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type UserCreateNestedOneWithoutBacktestsInput = {
    create?: XOR<UserCreateWithoutBacktestsInput, UserUncheckedCreateWithoutBacktestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBacktestsInput
    connect?: UserWhereUniqueInput
  }

  export type SavedScanCreateNestedOneWithoutBacktestsInput = {
    create?: XOR<SavedScanCreateWithoutBacktestsInput, SavedScanUncheckedCreateWithoutBacktestsInput>
    connectOrCreate?: SavedScanCreateOrConnectWithoutBacktestsInput
    connect?: SavedScanWhereUniqueInput
  }

  export type EnumBacktestStatusFieldUpdateOperationsInput = {
    set?: $Enums.BacktestStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutBacktestsNestedInput = {
    create?: XOR<UserCreateWithoutBacktestsInput, UserUncheckedCreateWithoutBacktestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBacktestsInput
    upsert?: UserUpsertWithoutBacktestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBacktestsInput, UserUpdateWithoutBacktestsInput>, UserUncheckedUpdateWithoutBacktestsInput>
  }

  export type SavedScanUpdateOneWithoutBacktestsNestedInput = {
    create?: XOR<SavedScanCreateWithoutBacktestsInput, SavedScanUncheckedCreateWithoutBacktestsInput>
    connectOrCreate?: SavedScanCreateOrConnectWithoutBacktestsInput
    upsert?: SavedScanUpsertWithoutBacktestsInput
    disconnect?: SavedScanWhereInput | boolean
    delete?: SavedScanWhereInput | boolean
    connect?: SavedScanWhereUniqueInput
    update?: XOR<XOR<SavedScanUpdateToOneWithWhereWithoutBacktestsInput, SavedScanUpdateWithoutBacktestsInput>, SavedScanUncheckedUpdateWithoutBacktestsInput>
  }

  export type SymbolCreateNestedOneWithoutFinancialMetricsInput = {
    create?: XOR<SymbolCreateWithoutFinancialMetricsInput, SymbolUncheckedCreateWithoutFinancialMetricsInput>
    connectOrCreate?: SymbolCreateOrConnectWithoutFinancialMetricsInput
    connect?: SymbolWhereUniqueInput
  }

  export type SymbolUpdateOneRequiredWithoutFinancialMetricsNestedInput = {
    create?: XOR<SymbolCreateWithoutFinancialMetricsInput, SymbolUncheckedCreateWithoutFinancialMetricsInput>
    connectOrCreate?: SymbolCreateOrConnectWithoutFinancialMetricsInput
    upsert?: SymbolUpsertWithoutFinancialMetricsInput
    connect?: SymbolWhereUniqueInput
    update?: XOR<XOR<SymbolUpdateToOneWithWhereWithoutFinancialMetricsInput, SymbolUpdateWithoutFinancialMetricsInput>, SymbolUncheckedUpdateWithoutFinancialMetricsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumExchangeFilter<$PrismaModel = never> = {
    equals?: $Enums.Exchange | EnumExchangeFieldRefInput<$PrismaModel>
    in?: $Enums.Exchange[] | ListEnumExchangeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Exchange[] | ListEnumExchangeFieldRefInput<$PrismaModel>
    not?: NestedEnumExchangeFilter<$PrismaModel> | $Enums.Exchange
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumExchangeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Exchange | EnumExchangeFieldRefInput<$PrismaModel>
    in?: $Enums.Exchange[] | ListEnumExchangeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Exchange[] | ListEnumExchangeFieldRefInput<$PrismaModel>
    not?: NestedEnumExchangeWithAggregatesFilter<$PrismaModel> | $Enums.Exchange
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExchangeFilter<$PrismaModel>
    _max?: NestedEnumExchangeFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTimeframeFilter<$PrismaModel = never> = {
    equals?: $Enums.Timeframe | EnumTimeframeFieldRefInput<$PrismaModel>
    in?: $Enums.Timeframe[] | ListEnumTimeframeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Timeframe[] | ListEnumTimeframeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeframeFilter<$PrismaModel> | $Enums.Timeframe
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumTimeframeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Timeframe | EnumTimeframeFieldRefInput<$PrismaModel>
    in?: $Enums.Timeframe[] | ListEnumTimeframeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Timeframe[] | ListEnumTimeframeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeframeWithAggregatesFilter<$PrismaModel> | $Enums.Timeframe
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTimeframeFilter<$PrismaModel>
    _max?: NestedEnumTimeframeFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumIndicatorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IndicatorType | EnumIndicatorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIndicatorTypeFilter<$PrismaModel> | $Enums.IndicatorType
  }

  export type NestedEnumIndicatorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IndicatorType | EnumIndicatorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIndicatorTypeWithAggregatesFilter<$PrismaModel> | $Enums.IndicatorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIndicatorTypeFilter<$PrismaModel>
    _max?: NestedEnumIndicatorTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type NestedEnumAlertStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusFilter<$PrismaModel> | $Enums.AlertStatus
  }

  export type NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertStatusFilter<$PrismaModel>
  }

  export type NestedEnumBacktestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BacktestStatus | EnumBacktestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BacktestStatus[] | ListEnumBacktestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BacktestStatus[] | ListEnumBacktestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBacktestStatusFilter<$PrismaModel> | $Enums.BacktestStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumBacktestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BacktestStatus | EnumBacktestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BacktestStatus[] | ListEnumBacktestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BacktestStatus[] | ListEnumBacktestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBacktestStatusWithAggregatesFilter<$PrismaModel> | $Enums.BacktestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBacktestStatusFilter<$PrismaModel>
    _max?: NestedEnumBacktestStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type WatchlistCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    isPublic?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    symbols?: WatchlistSymbolCreateNestedManyWithoutWatchlistInput
  }

  export type WatchlistUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    isPublic?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    symbols?: WatchlistSymbolUncheckedCreateNestedManyWithoutWatchlistInput
  }

  export type WatchlistCreateOrConnectWithoutUserInput = {
    where: WatchlistWhereUniqueInput
    create: XOR<WatchlistCreateWithoutUserInput, WatchlistUncheckedCreateWithoutUserInput>
  }

  export type WatchlistCreateManyUserInputEnvelope = {
    data: WatchlistCreateManyUserInput | WatchlistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SavedScanCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    definition: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanCreatesymbolUniverseInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
    backtests?: BacktestCreateNestedManyWithoutSavedScanInput
    versions?: SavedScanVersionCreateNestedManyWithoutSavedScanInput
  }

  export type SavedScanUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    definition: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanCreatesymbolUniverseInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
    backtests?: BacktestUncheckedCreateNestedManyWithoutSavedScanInput
    versions?: SavedScanVersionUncheckedCreateNestedManyWithoutSavedScanInput
  }

  export type SavedScanCreateOrConnectWithoutUserInput = {
    where: SavedScanWhereUniqueInput
    create: XOR<SavedScanCreateWithoutUserInput, SavedScanUncheckedCreateWithoutUserInput>
  }

  export type SavedScanCreateManyUserInputEnvelope = {
    data: SavedScanCreateManyUserInput | SavedScanCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutUserInput = {
    id?: string
    name: string
    alertType: $Enums.AlertType
    condition: JsonNullValueInput | InputJsonValue
    ticker?: string | null
    status?: $Enums.AlertStatus
    emailNotify?: boolean
    pushNotify?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    triggeredAt?: Date | string | null
  }

  export type AlertUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    alertType: $Enums.AlertType
    condition: JsonNullValueInput | InputJsonValue
    ticker?: string | null
    status?: $Enums.AlertStatus
    emailNotify?: boolean
    pushNotify?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    triggeredAt?: Date | string | null
  }

  export type AlertCreateOrConnectWithoutUserInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertCreateManyUserInputEnvelope = {
    data: AlertCreateManyUserInput | AlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BacktestCreateWithoutUserInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    timeframe: $Enums.Timeframe
    definition: JsonNullValueInput | InputJsonValue
    status?: $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: number | null
    avgReturn?: Decimal | DecimalJsLike | number | string | null
    winRate?: Decimal | DecimalJsLike | number | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    savedScan?: SavedScanCreateNestedOneWithoutBacktestsInput
  }

  export type BacktestUncheckedCreateWithoutUserInput = {
    id?: string
    savedScanId?: string | null
    name: string
    startDate: Date | string
    endDate: Date | string
    timeframe: $Enums.Timeframe
    definition: JsonNullValueInput | InputJsonValue
    status?: $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: number | null
    avgReturn?: Decimal | DecimalJsLike | number | string | null
    winRate?: Decimal | DecimalJsLike | number | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type BacktestCreateOrConnectWithoutUserInput = {
    where: BacktestWhereUniqueInput
    create: XOR<BacktestCreateWithoutUserInput, BacktestUncheckedCreateWithoutUserInput>
  }

  export type BacktestCreateManyUserInputEnvelope = {
    data: BacktestCreateManyUserInput | BacktestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WatchlistUpsertWithWhereUniqueWithoutUserInput = {
    where: WatchlistWhereUniqueInput
    update: XOR<WatchlistUpdateWithoutUserInput, WatchlistUncheckedUpdateWithoutUserInput>
    create: XOR<WatchlistCreateWithoutUserInput, WatchlistUncheckedCreateWithoutUserInput>
  }

  export type WatchlistUpdateWithWhereUniqueWithoutUserInput = {
    where: WatchlistWhereUniqueInput
    data: XOR<WatchlistUpdateWithoutUserInput, WatchlistUncheckedUpdateWithoutUserInput>
  }

  export type WatchlistUpdateManyWithWhereWithoutUserInput = {
    where: WatchlistScalarWhereInput
    data: XOR<WatchlistUpdateManyMutationInput, WatchlistUncheckedUpdateManyWithoutUserInput>
  }

  export type WatchlistScalarWhereInput = {
    AND?: WatchlistScalarWhereInput | WatchlistScalarWhereInput[]
    OR?: WatchlistScalarWhereInput[]
    NOT?: WatchlistScalarWhereInput | WatchlistScalarWhereInput[]
    id?: StringFilter<"Watchlist"> | string
    userId?: StringFilter<"Watchlist"> | string
    name?: StringFilter<"Watchlist"> | string
    description?: StringNullableFilter<"Watchlist"> | string | null
    isPublic?: BoolFilter<"Watchlist"> | boolean
    sortOrder?: IntFilter<"Watchlist"> | number
    createdAt?: DateTimeFilter<"Watchlist"> | Date | string
    updatedAt?: DateTimeFilter<"Watchlist"> | Date | string
  }

  export type SavedScanUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedScanWhereUniqueInput
    update: XOR<SavedScanUpdateWithoutUserInput, SavedScanUncheckedUpdateWithoutUserInput>
    create: XOR<SavedScanCreateWithoutUserInput, SavedScanUncheckedCreateWithoutUserInput>
  }

  export type SavedScanUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedScanWhereUniqueInput
    data: XOR<SavedScanUpdateWithoutUserInput, SavedScanUncheckedUpdateWithoutUserInput>
  }

  export type SavedScanUpdateManyWithWhereWithoutUserInput = {
    where: SavedScanScalarWhereInput
    data: XOR<SavedScanUpdateManyMutationInput, SavedScanUncheckedUpdateManyWithoutUserInput>
  }

  export type SavedScanScalarWhereInput = {
    AND?: SavedScanScalarWhereInput | SavedScanScalarWhereInput[]
    OR?: SavedScanScalarWhereInput[]
    NOT?: SavedScanScalarWhereInput | SavedScanScalarWhereInput[]
    id?: StringFilter<"SavedScan"> | string
    userId?: StringFilter<"SavedScan"> | string
    name?: StringFilter<"SavedScan"> | string
    description?: StringNullableFilter<"SavedScan"> | string | null
    definition?: JsonFilter<"SavedScan">
    symbolUniverse?: StringNullableListFilter<"SavedScan">
    isPublic?: BoolFilter<"SavedScan"> | boolean
    createdAt?: DateTimeFilter<"SavedScan"> | Date | string
    updatedAt?: DateTimeFilter<"SavedScan"> | Date | string
    lastRunAt?: DateTimeNullableFilter<"SavedScan"> | Date | string | null
  }

  export type AlertUpsertWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
  }

  export type AlertUpdateManyWithWhereWithoutUserInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutUserInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: StringFilter<"Alert"> | string
    userId?: StringFilter<"Alert"> | string
    name?: StringFilter<"Alert"> | string
    alertType?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    condition?: JsonFilter<"Alert">
    ticker?: StringNullableFilter<"Alert"> | string | null
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    emailNotify?: BoolFilter<"Alert"> | boolean
    pushNotify?: BoolFilter<"Alert"> | boolean
    expiresAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    triggeredAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
  }

  export type BacktestUpsertWithWhereUniqueWithoutUserInput = {
    where: BacktestWhereUniqueInput
    update: XOR<BacktestUpdateWithoutUserInput, BacktestUncheckedUpdateWithoutUserInput>
    create: XOR<BacktestCreateWithoutUserInput, BacktestUncheckedCreateWithoutUserInput>
  }

  export type BacktestUpdateWithWhereUniqueWithoutUserInput = {
    where: BacktestWhereUniqueInput
    data: XOR<BacktestUpdateWithoutUserInput, BacktestUncheckedUpdateWithoutUserInput>
  }

  export type BacktestUpdateManyWithWhereWithoutUserInput = {
    where: BacktestScalarWhereInput
    data: XOR<BacktestUpdateManyMutationInput, BacktestUncheckedUpdateManyWithoutUserInput>
  }

  export type BacktestScalarWhereInput = {
    AND?: BacktestScalarWhereInput | BacktestScalarWhereInput[]
    OR?: BacktestScalarWhereInput[]
    NOT?: BacktestScalarWhereInput | BacktestScalarWhereInput[]
    id?: StringFilter<"Backtest"> | string
    userId?: StringFilter<"Backtest"> | string
    savedScanId?: StringNullableFilter<"Backtest"> | string | null
    name?: StringFilter<"Backtest"> | string
    startDate?: DateTimeFilter<"Backtest"> | Date | string
    endDate?: DateTimeFilter<"Backtest"> | Date | string
    timeframe?: EnumTimeframeFilter<"Backtest"> | $Enums.Timeframe
    definition?: JsonFilter<"Backtest">
    status?: EnumBacktestStatusFilter<"Backtest"> | $Enums.BacktestStatus
    results?: JsonNullableFilter<"Backtest">
    totalMatches?: IntNullableFilter<"Backtest"> | number | null
    avgReturn?: DecimalNullableFilter<"Backtest"> | Decimal | DecimalJsLike | number | string | null
    winRate?: DecimalNullableFilter<"Backtest"> | Decimal | DecimalJsLike | number | string | null
    errorMessage?: StringNullableFilter<"Backtest"> | string | null
    createdAt?: DateTimeFilter<"Backtest"> | Date | string
    updatedAt?: DateTimeFilter<"Backtest"> | Date | string
    startedAt?: DateTimeNullableFilter<"Backtest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Backtest"> | Date | string | null
  }

  export type CandleCreateWithoutSymbolInput = {
    id?: string
    timeframe: $Enums.Timeframe
    timestamp: Date | string
    open: Decimal | DecimalJsLike | number | string
    high: Decimal | DecimalJsLike | number | string
    low: Decimal | DecimalJsLike | number | string
    close: Decimal | DecimalJsLike | number | string
    volume: bigint | number
    createdAt?: Date | string
  }

  export type CandleUncheckedCreateWithoutSymbolInput = {
    id?: string
    timeframe: $Enums.Timeframe
    timestamp: Date | string
    open: Decimal | DecimalJsLike | number | string
    high: Decimal | DecimalJsLike | number | string
    low: Decimal | DecimalJsLike | number | string
    close: Decimal | DecimalJsLike | number | string
    volume: bigint | number
    createdAt?: Date | string
  }

  export type CandleCreateOrConnectWithoutSymbolInput = {
    where: CandleWhereUniqueInput
    create: XOR<CandleCreateWithoutSymbolInput, CandleUncheckedCreateWithoutSymbolInput>
  }

  export type CandleCreateManySymbolInputEnvelope = {
    data: CandleCreateManySymbolInput | CandleCreateManySymbolInput[]
    skipDuplicates?: boolean
  }

  export type IndicatorCacheCreateWithoutSymbolInput = {
    id?: string
    indicator: $Enums.IndicatorType
    timeframe: $Enums.Timeframe
    period: number
    timestamp: Date | string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type IndicatorCacheUncheckedCreateWithoutSymbolInput = {
    id?: string
    indicator: $Enums.IndicatorType
    timeframe: $Enums.Timeframe
    period: number
    timestamp: Date | string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type IndicatorCacheCreateOrConnectWithoutSymbolInput = {
    where: IndicatorCacheWhereUniqueInput
    create: XOR<IndicatorCacheCreateWithoutSymbolInput, IndicatorCacheUncheckedCreateWithoutSymbolInput>
  }

  export type IndicatorCacheCreateManySymbolInputEnvelope = {
    data: IndicatorCacheCreateManySymbolInput | IndicatorCacheCreateManySymbolInput[]
    skipDuplicates?: boolean
  }

  export type WatchlistSymbolCreateWithoutSymbolInput = {
    id?: string
    notes?: string | null
    addedAt?: Date | string
    watchlist: WatchlistCreateNestedOneWithoutSymbolsInput
  }

  export type WatchlistSymbolUncheckedCreateWithoutSymbolInput = {
    id?: string
    watchlistId: string
    notes?: string | null
    addedAt?: Date | string
  }

  export type WatchlistSymbolCreateOrConnectWithoutSymbolInput = {
    where: WatchlistSymbolWhereUniqueInput
    create: XOR<WatchlistSymbolCreateWithoutSymbolInput, WatchlistSymbolUncheckedCreateWithoutSymbolInput>
  }

  export type WatchlistSymbolCreateManySymbolInputEnvelope = {
    data: WatchlistSymbolCreateManySymbolInput | WatchlistSymbolCreateManySymbolInput[]
    skipDuplicates?: boolean
  }

  export type FinancialMetricCreateWithoutSymbolInput = {
    id?: string
    metric: JsonNullValueInput | InputJsonValue
    fetchedAt?: Date | string
  }

  export type FinancialMetricUncheckedCreateWithoutSymbolInput = {
    id?: string
    metric: JsonNullValueInput | InputJsonValue
    fetchedAt?: Date | string
  }

  export type FinancialMetricCreateOrConnectWithoutSymbolInput = {
    where: FinancialMetricWhereUniqueInput
    create: XOR<FinancialMetricCreateWithoutSymbolInput, FinancialMetricUncheckedCreateWithoutSymbolInput>
  }

  export type FinancialMetricCreateManySymbolInputEnvelope = {
    data: FinancialMetricCreateManySymbolInput | FinancialMetricCreateManySymbolInput[]
    skipDuplicates?: boolean
  }

  export type CandleUpsertWithWhereUniqueWithoutSymbolInput = {
    where: CandleWhereUniqueInput
    update: XOR<CandleUpdateWithoutSymbolInput, CandleUncheckedUpdateWithoutSymbolInput>
    create: XOR<CandleCreateWithoutSymbolInput, CandleUncheckedCreateWithoutSymbolInput>
  }

  export type CandleUpdateWithWhereUniqueWithoutSymbolInput = {
    where: CandleWhereUniqueInput
    data: XOR<CandleUpdateWithoutSymbolInput, CandleUncheckedUpdateWithoutSymbolInput>
  }

  export type CandleUpdateManyWithWhereWithoutSymbolInput = {
    where: CandleScalarWhereInput
    data: XOR<CandleUpdateManyMutationInput, CandleUncheckedUpdateManyWithoutSymbolInput>
  }

  export type CandleScalarWhereInput = {
    AND?: CandleScalarWhereInput | CandleScalarWhereInput[]
    OR?: CandleScalarWhereInput[]
    NOT?: CandleScalarWhereInput | CandleScalarWhereInput[]
    id?: StringFilter<"Candle"> | string
    symbolId?: StringFilter<"Candle"> | string
    timeframe?: EnumTimeframeFilter<"Candle"> | $Enums.Timeframe
    timestamp?: DateTimeFilter<"Candle"> | Date | string
    open?: DecimalFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    high?: DecimalFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    low?: DecimalFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    close?: DecimalFilter<"Candle"> | Decimal | DecimalJsLike | number | string
    volume?: BigIntFilter<"Candle"> | bigint | number
    createdAt?: DateTimeFilter<"Candle"> | Date | string
  }

  export type IndicatorCacheUpsertWithWhereUniqueWithoutSymbolInput = {
    where: IndicatorCacheWhereUniqueInput
    update: XOR<IndicatorCacheUpdateWithoutSymbolInput, IndicatorCacheUncheckedUpdateWithoutSymbolInput>
    create: XOR<IndicatorCacheCreateWithoutSymbolInput, IndicatorCacheUncheckedCreateWithoutSymbolInput>
  }

  export type IndicatorCacheUpdateWithWhereUniqueWithoutSymbolInput = {
    where: IndicatorCacheWhereUniqueInput
    data: XOR<IndicatorCacheUpdateWithoutSymbolInput, IndicatorCacheUncheckedUpdateWithoutSymbolInput>
  }

  export type IndicatorCacheUpdateManyWithWhereWithoutSymbolInput = {
    where: IndicatorCacheScalarWhereInput
    data: XOR<IndicatorCacheUpdateManyMutationInput, IndicatorCacheUncheckedUpdateManyWithoutSymbolInput>
  }

  export type IndicatorCacheScalarWhereInput = {
    AND?: IndicatorCacheScalarWhereInput | IndicatorCacheScalarWhereInput[]
    OR?: IndicatorCacheScalarWhereInput[]
    NOT?: IndicatorCacheScalarWhereInput | IndicatorCacheScalarWhereInput[]
    id?: StringFilter<"IndicatorCache"> | string
    symbolId?: StringFilter<"IndicatorCache"> | string
    indicator?: EnumIndicatorTypeFilter<"IndicatorCache"> | $Enums.IndicatorType
    timeframe?: EnumTimeframeFilter<"IndicatorCache"> | $Enums.Timeframe
    period?: IntFilter<"IndicatorCache"> | number
    timestamp?: DateTimeFilter<"IndicatorCache"> | Date | string
    value?: JsonFilter<"IndicatorCache">
    createdAt?: DateTimeFilter<"IndicatorCache"> | Date | string
  }

  export type WatchlistSymbolUpsertWithWhereUniqueWithoutSymbolInput = {
    where: WatchlistSymbolWhereUniqueInput
    update: XOR<WatchlistSymbolUpdateWithoutSymbolInput, WatchlistSymbolUncheckedUpdateWithoutSymbolInput>
    create: XOR<WatchlistSymbolCreateWithoutSymbolInput, WatchlistSymbolUncheckedCreateWithoutSymbolInput>
  }

  export type WatchlistSymbolUpdateWithWhereUniqueWithoutSymbolInput = {
    where: WatchlistSymbolWhereUniqueInput
    data: XOR<WatchlistSymbolUpdateWithoutSymbolInput, WatchlistSymbolUncheckedUpdateWithoutSymbolInput>
  }

  export type WatchlistSymbolUpdateManyWithWhereWithoutSymbolInput = {
    where: WatchlistSymbolScalarWhereInput
    data: XOR<WatchlistSymbolUpdateManyMutationInput, WatchlistSymbolUncheckedUpdateManyWithoutSymbolInput>
  }

  export type WatchlistSymbolScalarWhereInput = {
    AND?: WatchlistSymbolScalarWhereInput | WatchlistSymbolScalarWhereInput[]
    OR?: WatchlistSymbolScalarWhereInput[]
    NOT?: WatchlistSymbolScalarWhereInput | WatchlistSymbolScalarWhereInput[]
    id?: StringFilter<"WatchlistSymbol"> | string
    watchlistId?: StringFilter<"WatchlistSymbol"> | string
    symbolId?: StringFilter<"WatchlistSymbol"> | string
    notes?: StringNullableFilter<"WatchlistSymbol"> | string | null
    addedAt?: DateTimeFilter<"WatchlistSymbol"> | Date | string
  }

  export type FinancialMetricUpsertWithWhereUniqueWithoutSymbolInput = {
    where: FinancialMetricWhereUniqueInput
    update: XOR<FinancialMetricUpdateWithoutSymbolInput, FinancialMetricUncheckedUpdateWithoutSymbolInput>
    create: XOR<FinancialMetricCreateWithoutSymbolInput, FinancialMetricUncheckedCreateWithoutSymbolInput>
  }

  export type FinancialMetricUpdateWithWhereUniqueWithoutSymbolInput = {
    where: FinancialMetricWhereUniqueInput
    data: XOR<FinancialMetricUpdateWithoutSymbolInput, FinancialMetricUncheckedUpdateWithoutSymbolInput>
  }

  export type FinancialMetricUpdateManyWithWhereWithoutSymbolInput = {
    where: FinancialMetricScalarWhereInput
    data: XOR<FinancialMetricUpdateManyMutationInput, FinancialMetricUncheckedUpdateManyWithoutSymbolInput>
  }

  export type FinancialMetricScalarWhereInput = {
    AND?: FinancialMetricScalarWhereInput | FinancialMetricScalarWhereInput[]
    OR?: FinancialMetricScalarWhereInput[]
    NOT?: FinancialMetricScalarWhereInput | FinancialMetricScalarWhereInput[]
    id?: StringFilter<"FinancialMetric"> | string
    symbolId?: StringFilter<"FinancialMetric"> | string
    metric?: JsonFilter<"FinancialMetric">
    fetchedAt?: DateTimeFilter<"FinancialMetric"> | Date | string
  }

  export type SymbolCreateWithoutCandlesInput = {
    id?: string
    ticker: string
    name: string
    exchange: $Enums.Exchange
    currency?: string
    sector?: string | null
    industry?: string | null
    marketCap?: bigint | number | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    ipo?: Date | string | null
    delistDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    indicators?: IndicatorCacheCreateNestedManyWithoutSymbolInput
    watchlistSymbols?: WatchlistSymbolCreateNestedManyWithoutSymbolInput
    financialMetrics?: FinancialMetricCreateNestedManyWithoutSymbolInput
  }

  export type SymbolUncheckedCreateWithoutCandlesInput = {
    id?: string
    ticker: string
    name: string
    exchange: $Enums.Exchange
    currency?: string
    sector?: string | null
    industry?: string | null
    marketCap?: bigint | number | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    ipo?: Date | string | null
    delistDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    indicators?: IndicatorCacheUncheckedCreateNestedManyWithoutSymbolInput
    watchlistSymbols?: WatchlistSymbolUncheckedCreateNestedManyWithoutSymbolInput
    financialMetrics?: FinancialMetricUncheckedCreateNestedManyWithoutSymbolInput
  }

  export type SymbolCreateOrConnectWithoutCandlesInput = {
    where: SymbolWhereUniqueInput
    create: XOR<SymbolCreateWithoutCandlesInput, SymbolUncheckedCreateWithoutCandlesInput>
  }

  export type SymbolUpsertWithoutCandlesInput = {
    update: XOR<SymbolUpdateWithoutCandlesInput, SymbolUncheckedUpdateWithoutCandlesInput>
    create: XOR<SymbolCreateWithoutCandlesInput, SymbolUncheckedCreateWithoutCandlesInput>
    where?: SymbolWhereInput
  }

  export type SymbolUpdateToOneWithWhereWithoutCandlesInput = {
    where?: SymbolWhereInput
    data: XOR<SymbolUpdateWithoutCandlesInput, SymbolUncheckedUpdateWithoutCandlesInput>
  }

  export type SymbolUpdateWithoutCandlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange?: EnumExchangeFieldUpdateOperationsInput | $Enums.Exchange
    currency?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delistDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    indicators?: IndicatorCacheUpdateManyWithoutSymbolNestedInput
    watchlistSymbols?: WatchlistSymbolUpdateManyWithoutSymbolNestedInput
    financialMetrics?: FinancialMetricUpdateManyWithoutSymbolNestedInput
  }

  export type SymbolUncheckedUpdateWithoutCandlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange?: EnumExchangeFieldUpdateOperationsInput | $Enums.Exchange
    currency?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delistDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    indicators?: IndicatorCacheUncheckedUpdateManyWithoutSymbolNestedInput
    watchlistSymbols?: WatchlistSymbolUncheckedUpdateManyWithoutSymbolNestedInput
    financialMetrics?: FinancialMetricUncheckedUpdateManyWithoutSymbolNestedInput
  }

  export type SymbolCreateWithoutIndicatorsInput = {
    id?: string
    ticker: string
    name: string
    exchange: $Enums.Exchange
    currency?: string
    sector?: string | null
    industry?: string | null
    marketCap?: bigint | number | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    ipo?: Date | string | null
    delistDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    candles?: CandleCreateNestedManyWithoutSymbolInput
    watchlistSymbols?: WatchlistSymbolCreateNestedManyWithoutSymbolInput
    financialMetrics?: FinancialMetricCreateNestedManyWithoutSymbolInput
  }

  export type SymbolUncheckedCreateWithoutIndicatorsInput = {
    id?: string
    ticker: string
    name: string
    exchange: $Enums.Exchange
    currency?: string
    sector?: string | null
    industry?: string | null
    marketCap?: bigint | number | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    ipo?: Date | string | null
    delistDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    candles?: CandleUncheckedCreateNestedManyWithoutSymbolInput
    watchlistSymbols?: WatchlistSymbolUncheckedCreateNestedManyWithoutSymbolInput
    financialMetrics?: FinancialMetricUncheckedCreateNestedManyWithoutSymbolInput
  }

  export type SymbolCreateOrConnectWithoutIndicatorsInput = {
    where: SymbolWhereUniqueInput
    create: XOR<SymbolCreateWithoutIndicatorsInput, SymbolUncheckedCreateWithoutIndicatorsInput>
  }

  export type SymbolUpsertWithoutIndicatorsInput = {
    update: XOR<SymbolUpdateWithoutIndicatorsInput, SymbolUncheckedUpdateWithoutIndicatorsInput>
    create: XOR<SymbolCreateWithoutIndicatorsInput, SymbolUncheckedCreateWithoutIndicatorsInput>
    where?: SymbolWhereInput
  }

  export type SymbolUpdateToOneWithWhereWithoutIndicatorsInput = {
    where?: SymbolWhereInput
    data: XOR<SymbolUpdateWithoutIndicatorsInput, SymbolUncheckedUpdateWithoutIndicatorsInput>
  }

  export type SymbolUpdateWithoutIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange?: EnumExchangeFieldUpdateOperationsInput | $Enums.Exchange
    currency?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delistDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candles?: CandleUpdateManyWithoutSymbolNestedInput
    watchlistSymbols?: WatchlistSymbolUpdateManyWithoutSymbolNestedInput
    financialMetrics?: FinancialMetricUpdateManyWithoutSymbolNestedInput
  }

  export type SymbolUncheckedUpdateWithoutIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange?: EnumExchangeFieldUpdateOperationsInput | $Enums.Exchange
    currency?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delistDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candles?: CandleUncheckedUpdateManyWithoutSymbolNestedInput
    watchlistSymbols?: WatchlistSymbolUncheckedUpdateManyWithoutSymbolNestedInput
    financialMetrics?: FinancialMetricUncheckedUpdateManyWithoutSymbolNestedInput
  }

  export type UserCreateWithoutWatchlistsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    googleId?: string | null
    picture?: string | null
    apiCallsToday?: number
    lastApiReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    savedScans?: SavedScanCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    backtests?: BacktestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWatchlistsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    googleId?: string | null
    picture?: string | null
    apiCallsToday?: number
    lastApiReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    savedScans?: SavedScanUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    backtests?: BacktestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWatchlistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWatchlistsInput, UserUncheckedCreateWithoutWatchlistsInput>
  }

  export type WatchlistSymbolCreateWithoutWatchlistInput = {
    id?: string
    notes?: string | null
    addedAt?: Date | string
    symbol: SymbolCreateNestedOneWithoutWatchlistSymbolsInput
  }

  export type WatchlistSymbolUncheckedCreateWithoutWatchlistInput = {
    id?: string
    symbolId: string
    notes?: string | null
    addedAt?: Date | string
  }

  export type WatchlistSymbolCreateOrConnectWithoutWatchlistInput = {
    where: WatchlistSymbolWhereUniqueInput
    create: XOR<WatchlistSymbolCreateWithoutWatchlistInput, WatchlistSymbolUncheckedCreateWithoutWatchlistInput>
  }

  export type WatchlistSymbolCreateManyWatchlistInputEnvelope = {
    data: WatchlistSymbolCreateManyWatchlistInput | WatchlistSymbolCreateManyWatchlistInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWatchlistsInput = {
    update: XOR<UserUpdateWithoutWatchlistsInput, UserUncheckedUpdateWithoutWatchlistsInput>
    create: XOR<UserCreateWithoutWatchlistsInput, UserUncheckedCreateWithoutWatchlistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWatchlistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWatchlistsInput, UserUncheckedUpdateWithoutWatchlistsInput>
  }

  export type UserUpdateWithoutWatchlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallsToday?: IntFieldUpdateOperationsInput | number
    lastApiReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedScans?: SavedScanUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    backtests?: BacktestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWatchlistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallsToday?: IntFieldUpdateOperationsInput | number
    lastApiReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedScans?: SavedScanUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    backtests?: BacktestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WatchlistSymbolUpsertWithWhereUniqueWithoutWatchlistInput = {
    where: WatchlistSymbolWhereUniqueInput
    update: XOR<WatchlistSymbolUpdateWithoutWatchlistInput, WatchlistSymbolUncheckedUpdateWithoutWatchlistInput>
    create: XOR<WatchlistSymbolCreateWithoutWatchlistInput, WatchlistSymbolUncheckedCreateWithoutWatchlistInput>
  }

  export type WatchlistSymbolUpdateWithWhereUniqueWithoutWatchlistInput = {
    where: WatchlistSymbolWhereUniqueInput
    data: XOR<WatchlistSymbolUpdateWithoutWatchlistInput, WatchlistSymbolUncheckedUpdateWithoutWatchlistInput>
  }

  export type WatchlistSymbolUpdateManyWithWhereWithoutWatchlistInput = {
    where: WatchlistSymbolScalarWhereInput
    data: XOR<WatchlistSymbolUpdateManyMutationInput, WatchlistSymbolUncheckedUpdateManyWithoutWatchlistInput>
  }

  export type WatchlistCreateWithoutSymbolsInput = {
    id?: string
    name: string
    description?: string | null
    isPublic?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWatchlistsInput
  }

  export type WatchlistUncheckedCreateWithoutSymbolsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    isPublic?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WatchlistCreateOrConnectWithoutSymbolsInput = {
    where: WatchlistWhereUniqueInput
    create: XOR<WatchlistCreateWithoutSymbolsInput, WatchlistUncheckedCreateWithoutSymbolsInput>
  }

  export type SymbolCreateWithoutWatchlistSymbolsInput = {
    id?: string
    ticker: string
    name: string
    exchange: $Enums.Exchange
    currency?: string
    sector?: string | null
    industry?: string | null
    marketCap?: bigint | number | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    ipo?: Date | string | null
    delistDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    candles?: CandleCreateNestedManyWithoutSymbolInput
    indicators?: IndicatorCacheCreateNestedManyWithoutSymbolInput
    financialMetrics?: FinancialMetricCreateNestedManyWithoutSymbolInput
  }

  export type SymbolUncheckedCreateWithoutWatchlistSymbolsInput = {
    id?: string
    ticker: string
    name: string
    exchange: $Enums.Exchange
    currency?: string
    sector?: string | null
    industry?: string | null
    marketCap?: bigint | number | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    ipo?: Date | string | null
    delistDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    candles?: CandleUncheckedCreateNestedManyWithoutSymbolInput
    indicators?: IndicatorCacheUncheckedCreateNestedManyWithoutSymbolInput
    financialMetrics?: FinancialMetricUncheckedCreateNestedManyWithoutSymbolInput
  }

  export type SymbolCreateOrConnectWithoutWatchlistSymbolsInput = {
    where: SymbolWhereUniqueInput
    create: XOR<SymbolCreateWithoutWatchlistSymbolsInput, SymbolUncheckedCreateWithoutWatchlistSymbolsInput>
  }

  export type WatchlistUpsertWithoutSymbolsInput = {
    update: XOR<WatchlistUpdateWithoutSymbolsInput, WatchlistUncheckedUpdateWithoutSymbolsInput>
    create: XOR<WatchlistCreateWithoutSymbolsInput, WatchlistUncheckedCreateWithoutSymbolsInput>
    where?: WatchlistWhereInput
  }

  export type WatchlistUpdateToOneWithWhereWithoutSymbolsInput = {
    where?: WatchlistWhereInput
    data: XOR<WatchlistUpdateWithoutSymbolsInput, WatchlistUncheckedUpdateWithoutSymbolsInput>
  }

  export type WatchlistUpdateWithoutSymbolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchlistsNestedInput
  }

  export type WatchlistUncheckedUpdateWithoutSymbolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymbolUpsertWithoutWatchlistSymbolsInput = {
    update: XOR<SymbolUpdateWithoutWatchlistSymbolsInput, SymbolUncheckedUpdateWithoutWatchlistSymbolsInput>
    create: XOR<SymbolCreateWithoutWatchlistSymbolsInput, SymbolUncheckedCreateWithoutWatchlistSymbolsInput>
    where?: SymbolWhereInput
  }

  export type SymbolUpdateToOneWithWhereWithoutWatchlistSymbolsInput = {
    where?: SymbolWhereInput
    data: XOR<SymbolUpdateWithoutWatchlistSymbolsInput, SymbolUncheckedUpdateWithoutWatchlistSymbolsInput>
  }

  export type SymbolUpdateWithoutWatchlistSymbolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange?: EnumExchangeFieldUpdateOperationsInput | $Enums.Exchange
    currency?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delistDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candles?: CandleUpdateManyWithoutSymbolNestedInput
    indicators?: IndicatorCacheUpdateManyWithoutSymbolNestedInput
    financialMetrics?: FinancialMetricUpdateManyWithoutSymbolNestedInput
  }

  export type SymbolUncheckedUpdateWithoutWatchlistSymbolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange?: EnumExchangeFieldUpdateOperationsInput | $Enums.Exchange
    currency?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delistDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candles?: CandleUncheckedUpdateManyWithoutSymbolNestedInput
    indicators?: IndicatorCacheUncheckedUpdateManyWithoutSymbolNestedInput
    financialMetrics?: FinancialMetricUncheckedUpdateManyWithoutSymbolNestedInput
  }

  export type UserCreateWithoutSavedScansInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    googleId?: string | null
    picture?: string | null
    apiCallsToday?: number
    lastApiReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    watchlists?: WatchlistCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    backtests?: BacktestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSavedScansInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    googleId?: string | null
    picture?: string | null
    apiCallsToday?: number
    lastApiReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    watchlists?: WatchlistUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    backtests?: BacktestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSavedScansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedScansInput, UserUncheckedCreateWithoutSavedScansInput>
  }

  export type BacktestCreateWithoutSavedScanInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    timeframe: $Enums.Timeframe
    definition: JsonNullValueInput | InputJsonValue
    status?: $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: number | null
    avgReturn?: Decimal | DecimalJsLike | number | string | null
    winRate?: Decimal | DecimalJsLike | number | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBacktestsInput
  }

  export type BacktestUncheckedCreateWithoutSavedScanInput = {
    id?: string
    userId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    timeframe: $Enums.Timeframe
    definition: JsonNullValueInput | InputJsonValue
    status?: $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: number | null
    avgReturn?: Decimal | DecimalJsLike | number | string | null
    winRate?: Decimal | DecimalJsLike | number | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type BacktestCreateOrConnectWithoutSavedScanInput = {
    where: BacktestWhereUniqueInput
    create: XOR<BacktestCreateWithoutSavedScanInput, BacktestUncheckedCreateWithoutSavedScanInput>
  }

  export type BacktestCreateManySavedScanInputEnvelope = {
    data: BacktestCreateManySavedScanInput | BacktestCreateManySavedScanInput[]
    skipDuplicates?: boolean
  }

  export type SavedScanVersionCreateWithoutSavedScanInput = {
    id?: string
    versionNumber: number
    definition: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdById?: string | null
    comment?: string | null
  }

  export type SavedScanVersionUncheckedCreateWithoutSavedScanInput = {
    id?: string
    versionNumber: number
    definition: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdById?: string | null
    comment?: string | null
  }

  export type SavedScanVersionCreateOrConnectWithoutSavedScanInput = {
    where: SavedScanVersionWhereUniqueInput
    create: XOR<SavedScanVersionCreateWithoutSavedScanInput, SavedScanVersionUncheckedCreateWithoutSavedScanInput>
  }

  export type SavedScanVersionCreateManySavedScanInputEnvelope = {
    data: SavedScanVersionCreateManySavedScanInput | SavedScanVersionCreateManySavedScanInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSavedScansInput = {
    update: XOR<UserUpdateWithoutSavedScansInput, UserUncheckedUpdateWithoutSavedScansInput>
    create: XOR<UserCreateWithoutSavedScansInput, UserUncheckedCreateWithoutSavedScansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavedScansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavedScansInput, UserUncheckedUpdateWithoutSavedScansInput>
  }

  export type UserUpdateWithoutSavedScansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallsToday?: IntFieldUpdateOperationsInput | number
    lastApiReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchlists?: WatchlistUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    backtests?: BacktestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedScansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallsToday?: IntFieldUpdateOperationsInput | number
    lastApiReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchlists?: WatchlistUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    backtests?: BacktestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BacktestUpsertWithWhereUniqueWithoutSavedScanInput = {
    where: BacktestWhereUniqueInput
    update: XOR<BacktestUpdateWithoutSavedScanInput, BacktestUncheckedUpdateWithoutSavedScanInput>
    create: XOR<BacktestCreateWithoutSavedScanInput, BacktestUncheckedCreateWithoutSavedScanInput>
  }

  export type BacktestUpdateWithWhereUniqueWithoutSavedScanInput = {
    where: BacktestWhereUniqueInput
    data: XOR<BacktestUpdateWithoutSavedScanInput, BacktestUncheckedUpdateWithoutSavedScanInput>
  }

  export type BacktestUpdateManyWithWhereWithoutSavedScanInput = {
    where: BacktestScalarWhereInput
    data: XOR<BacktestUpdateManyMutationInput, BacktestUncheckedUpdateManyWithoutSavedScanInput>
  }

  export type SavedScanVersionUpsertWithWhereUniqueWithoutSavedScanInput = {
    where: SavedScanVersionWhereUniqueInput
    update: XOR<SavedScanVersionUpdateWithoutSavedScanInput, SavedScanVersionUncheckedUpdateWithoutSavedScanInput>
    create: XOR<SavedScanVersionCreateWithoutSavedScanInput, SavedScanVersionUncheckedCreateWithoutSavedScanInput>
  }

  export type SavedScanVersionUpdateWithWhereUniqueWithoutSavedScanInput = {
    where: SavedScanVersionWhereUniqueInput
    data: XOR<SavedScanVersionUpdateWithoutSavedScanInput, SavedScanVersionUncheckedUpdateWithoutSavedScanInput>
  }

  export type SavedScanVersionUpdateManyWithWhereWithoutSavedScanInput = {
    where: SavedScanVersionScalarWhereInput
    data: XOR<SavedScanVersionUpdateManyMutationInput, SavedScanVersionUncheckedUpdateManyWithoutSavedScanInput>
  }

  export type SavedScanVersionScalarWhereInput = {
    AND?: SavedScanVersionScalarWhereInput | SavedScanVersionScalarWhereInput[]
    OR?: SavedScanVersionScalarWhereInput[]
    NOT?: SavedScanVersionScalarWhereInput | SavedScanVersionScalarWhereInput[]
    id?: StringFilter<"SavedScanVersion"> | string
    savedScanId?: StringFilter<"SavedScanVersion"> | string
    versionNumber?: IntFilter<"SavedScanVersion"> | number
    definition?: JsonFilter<"SavedScanVersion">
    createdAt?: DateTimeFilter<"SavedScanVersion"> | Date | string
    createdById?: StringNullableFilter<"SavedScanVersion"> | string | null
    comment?: StringNullableFilter<"SavedScanVersion"> | string | null
  }

  export type SavedScanCreateWithoutVersionsInput = {
    id?: string
    name: string
    description?: string | null
    definition: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanCreatesymbolUniverseInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
    user: UserCreateNestedOneWithoutSavedScansInput
    backtests?: BacktestCreateNestedManyWithoutSavedScanInput
  }

  export type SavedScanUncheckedCreateWithoutVersionsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    definition: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanCreatesymbolUniverseInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
    backtests?: BacktestUncheckedCreateNestedManyWithoutSavedScanInput
  }

  export type SavedScanCreateOrConnectWithoutVersionsInput = {
    where: SavedScanWhereUniqueInput
    create: XOR<SavedScanCreateWithoutVersionsInput, SavedScanUncheckedCreateWithoutVersionsInput>
  }

  export type SavedScanUpsertWithoutVersionsInput = {
    update: XOR<SavedScanUpdateWithoutVersionsInput, SavedScanUncheckedUpdateWithoutVersionsInput>
    create: XOR<SavedScanCreateWithoutVersionsInput, SavedScanUncheckedCreateWithoutVersionsInput>
    where?: SavedScanWhereInput
  }

  export type SavedScanUpdateToOneWithWhereWithoutVersionsInput = {
    where?: SavedScanWhereInput
    data: XOR<SavedScanUpdateWithoutVersionsInput, SavedScanUncheckedUpdateWithoutVersionsInput>
  }

  export type SavedScanUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanUpdatesymbolUniverseInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSavedScansNestedInput
    backtests?: BacktestUpdateManyWithoutSavedScanNestedInput
  }

  export type SavedScanUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanUpdatesymbolUniverseInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    backtests?: BacktestUncheckedUpdateManyWithoutSavedScanNestedInput
  }

  export type UserCreateWithoutAlertsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    googleId?: string | null
    picture?: string | null
    apiCallsToday?: number
    lastApiReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    watchlists?: WatchlistCreateNestedManyWithoutUserInput
    savedScans?: SavedScanCreateNestedManyWithoutUserInput
    backtests?: BacktestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAlertsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    googleId?: string | null
    picture?: string | null
    apiCallsToday?: number
    lastApiReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    watchlists?: WatchlistUncheckedCreateNestedManyWithoutUserInput
    savedScans?: SavedScanUncheckedCreateNestedManyWithoutUserInput
    backtests?: BacktestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
  }

  export type UserUpsertWithoutAlertsInput = {
    update: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type UserUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallsToday?: IntFieldUpdateOperationsInput | number
    lastApiReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchlists?: WatchlistUpdateManyWithoutUserNestedInput
    savedScans?: SavedScanUpdateManyWithoutUserNestedInput
    backtests?: BacktestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallsToday?: IntFieldUpdateOperationsInput | number
    lastApiReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchlists?: WatchlistUncheckedUpdateManyWithoutUserNestedInput
    savedScans?: SavedScanUncheckedUpdateManyWithoutUserNestedInput
    backtests?: BacktestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBacktestsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    googleId?: string | null
    picture?: string | null
    apiCallsToday?: number
    lastApiReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    watchlists?: WatchlistCreateNestedManyWithoutUserInput
    savedScans?: SavedScanCreateNestedManyWithoutUserInput
    alerts?: AlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBacktestsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    googleId?: string | null
    picture?: string | null
    apiCallsToday?: number
    lastApiReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    watchlists?: WatchlistUncheckedCreateNestedManyWithoutUserInput
    savedScans?: SavedScanUncheckedCreateNestedManyWithoutUserInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBacktestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBacktestsInput, UserUncheckedCreateWithoutBacktestsInput>
  }

  export type SavedScanCreateWithoutBacktestsInput = {
    id?: string
    name: string
    description?: string | null
    definition: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanCreatesymbolUniverseInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
    user: UserCreateNestedOneWithoutSavedScansInput
    versions?: SavedScanVersionCreateNestedManyWithoutSavedScanInput
  }

  export type SavedScanUncheckedCreateWithoutBacktestsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    definition: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanCreatesymbolUniverseInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
    versions?: SavedScanVersionUncheckedCreateNestedManyWithoutSavedScanInput
  }

  export type SavedScanCreateOrConnectWithoutBacktestsInput = {
    where: SavedScanWhereUniqueInput
    create: XOR<SavedScanCreateWithoutBacktestsInput, SavedScanUncheckedCreateWithoutBacktestsInput>
  }

  export type UserUpsertWithoutBacktestsInput = {
    update: XOR<UserUpdateWithoutBacktestsInput, UserUncheckedUpdateWithoutBacktestsInput>
    create: XOR<UserCreateWithoutBacktestsInput, UserUncheckedCreateWithoutBacktestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBacktestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBacktestsInput, UserUncheckedUpdateWithoutBacktestsInput>
  }

  export type UserUpdateWithoutBacktestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallsToday?: IntFieldUpdateOperationsInput | number
    lastApiReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchlists?: WatchlistUpdateManyWithoutUserNestedInput
    savedScans?: SavedScanUpdateManyWithoutUserNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBacktestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallsToday?: IntFieldUpdateOperationsInput | number
    lastApiReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchlists?: WatchlistUncheckedUpdateManyWithoutUserNestedInput
    savedScans?: SavedScanUncheckedUpdateManyWithoutUserNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SavedScanUpsertWithoutBacktestsInput = {
    update: XOR<SavedScanUpdateWithoutBacktestsInput, SavedScanUncheckedUpdateWithoutBacktestsInput>
    create: XOR<SavedScanCreateWithoutBacktestsInput, SavedScanUncheckedCreateWithoutBacktestsInput>
    where?: SavedScanWhereInput
  }

  export type SavedScanUpdateToOneWithWhereWithoutBacktestsInput = {
    where?: SavedScanWhereInput
    data: XOR<SavedScanUpdateWithoutBacktestsInput, SavedScanUncheckedUpdateWithoutBacktestsInput>
  }

  export type SavedScanUpdateWithoutBacktestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanUpdatesymbolUniverseInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSavedScansNestedInput
    versions?: SavedScanVersionUpdateManyWithoutSavedScanNestedInput
  }

  export type SavedScanUncheckedUpdateWithoutBacktestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanUpdatesymbolUniverseInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versions?: SavedScanVersionUncheckedUpdateManyWithoutSavedScanNestedInput
  }

  export type SymbolCreateWithoutFinancialMetricsInput = {
    id?: string
    ticker: string
    name: string
    exchange: $Enums.Exchange
    currency?: string
    sector?: string | null
    industry?: string | null
    marketCap?: bigint | number | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    ipo?: Date | string | null
    delistDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    candles?: CandleCreateNestedManyWithoutSymbolInput
    indicators?: IndicatorCacheCreateNestedManyWithoutSymbolInput
    watchlistSymbols?: WatchlistSymbolCreateNestedManyWithoutSymbolInput
  }

  export type SymbolUncheckedCreateWithoutFinancialMetricsInput = {
    id?: string
    ticker: string
    name: string
    exchange: $Enums.Exchange
    currency?: string
    sector?: string | null
    industry?: string | null
    marketCap?: bigint | number | null
    description?: string | null
    website?: string | null
    isActive?: boolean
    ipo?: Date | string | null
    delistDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncedAt?: Date | string | null
    candles?: CandleUncheckedCreateNestedManyWithoutSymbolInput
    indicators?: IndicatorCacheUncheckedCreateNestedManyWithoutSymbolInput
    watchlistSymbols?: WatchlistSymbolUncheckedCreateNestedManyWithoutSymbolInput
  }

  export type SymbolCreateOrConnectWithoutFinancialMetricsInput = {
    where: SymbolWhereUniqueInput
    create: XOR<SymbolCreateWithoutFinancialMetricsInput, SymbolUncheckedCreateWithoutFinancialMetricsInput>
  }

  export type SymbolUpsertWithoutFinancialMetricsInput = {
    update: XOR<SymbolUpdateWithoutFinancialMetricsInput, SymbolUncheckedUpdateWithoutFinancialMetricsInput>
    create: XOR<SymbolCreateWithoutFinancialMetricsInput, SymbolUncheckedCreateWithoutFinancialMetricsInput>
    where?: SymbolWhereInput
  }

  export type SymbolUpdateToOneWithWhereWithoutFinancialMetricsInput = {
    where?: SymbolWhereInput
    data: XOR<SymbolUpdateWithoutFinancialMetricsInput, SymbolUncheckedUpdateWithoutFinancialMetricsInput>
  }

  export type SymbolUpdateWithoutFinancialMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange?: EnumExchangeFieldUpdateOperationsInput | $Enums.Exchange
    currency?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delistDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candles?: CandleUpdateManyWithoutSymbolNestedInput
    indicators?: IndicatorCacheUpdateManyWithoutSymbolNestedInput
    watchlistSymbols?: WatchlistSymbolUpdateManyWithoutSymbolNestedInput
  }

  export type SymbolUncheckedUpdateWithoutFinancialMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange?: EnumExchangeFieldUpdateOperationsInput | $Enums.Exchange
    currency?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    marketCap?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ipo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delistDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candles?: CandleUncheckedUpdateManyWithoutSymbolNestedInput
    indicators?: IndicatorCacheUncheckedUpdateManyWithoutSymbolNestedInput
    watchlistSymbols?: WatchlistSymbolUncheckedUpdateManyWithoutSymbolNestedInput
  }

  export type WatchlistCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    isPublic?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedScanCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    definition: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanCreatesymbolUniverseInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
  }

  export type AlertCreateManyUserInput = {
    id?: string
    name: string
    alertType: $Enums.AlertType
    condition: JsonNullValueInput | InputJsonValue
    ticker?: string | null
    status?: $Enums.AlertStatus
    emailNotify?: boolean
    pushNotify?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    triggeredAt?: Date | string | null
  }

  export type BacktestCreateManyUserInput = {
    id?: string
    savedScanId?: string | null
    name: string
    startDate: Date | string
    endDate: Date | string
    timeframe: $Enums.Timeframe
    definition: JsonNullValueInput | InputJsonValue
    status?: $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: number | null
    avgReturn?: Decimal | DecimalJsLike | number | string | null
    winRate?: Decimal | DecimalJsLike | number | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type WatchlistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbols?: WatchlistSymbolUpdateManyWithoutWatchlistNestedInput
  }

  export type WatchlistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbols?: WatchlistSymbolUncheckedUpdateManyWithoutWatchlistNestedInput
  }

  export type WatchlistUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedScanUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanUpdatesymbolUniverseInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    backtests?: BacktestUpdateManyWithoutSavedScanNestedInput
    versions?: SavedScanVersionUpdateManyWithoutSavedScanNestedInput
  }

  export type SavedScanUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanUpdatesymbolUniverseInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    backtests?: BacktestUncheckedUpdateManyWithoutSavedScanNestedInput
    versions?: SavedScanVersionUncheckedUpdateManyWithoutSavedScanNestedInput
  }

  export type SavedScanUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    symbolUniverse?: SavedScanUpdatesymbolUniverseInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    condition?: JsonNullValueInput | InputJsonValue
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    emailNotify?: BoolFieldUpdateOperationsInput | boolean
    pushNotify?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    condition?: JsonNullValueInput | InputJsonValue
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    emailNotify?: BoolFieldUpdateOperationsInput | boolean
    pushNotify?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    condition?: JsonNullValueInput | InputJsonValue
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    emailNotify?: BoolFieldUpdateOperationsInput | boolean
    pushNotify?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BacktestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    definition?: JsonNullValueInput | InputJsonValue
    status?: EnumBacktestStatusFieldUpdateOperationsInput | $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: NullableIntFieldUpdateOperationsInput | number | null
    avgReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedScan?: SavedScanUpdateOneWithoutBacktestsNestedInput
  }

  export type BacktestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    savedScanId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    definition?: JsonNullValueInput | InputJsonValue
    status?: EnumBacktestStatusFieldUpdateOperationsInput | $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: NullableIntFieldUpdateOperationsInput | number | null
    avgReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BacktestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    savedScanId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    definition?: JsonNullValueInput | InputJsonValue
    status?: EnumBacktestStatusFieldUpdateOperationsInput | $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: NullableIntFieldUpdateOperationsInput | number | null
    avgReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CandleCreateManySymbolInput = {
    id?: string
    timeframe: $Enums.Timeframe
    timestamp: Date | string
    open: Decimal | DecimalJsLike | number | string
    high: Decimal | DecimalJsLike | number | string
    low: Decimal | DecimalJsLike | number | string
    close: Decimal | DecimalJsLike | number | string
    volume: bigint | number
    createdAt?: Date | string
  }

  export type IndicatorCacheCreateManySymbolInput = {
    id?: string
    indicator: $Enums.IndicatorType
    timeframe: $Enums.Timeframe
    period: number
    timestamp: Date | string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WatchlistSymbolCreateManySymbolInput = {
    id?: string
    watchlistId: string
    notes?: string | null
    addedAt?: Date | string
  }

  export type FinancialMetricCreateManySymbolInput = {
    id?: string
    metric: JsonNullValueInput | InputJsonValue
    fetchedAt?: Date | string
  }

  export type CandleUpdateWithoutSymbolInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    high?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    low?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    close?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandleUncheckedUpdateWithoutSymbolInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    high?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    low?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    close?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandleUncheckedUpdateManyWithoutSymbolInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    high?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    low?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    close?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCacheUpdateWithoutSymbolInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicator?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    period?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCacheUncheckedUpdateWithoutSymbolInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicator?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    period?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCacheUncheckedUpdateManyWithoutSymbolInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicator?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    period?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistSymbolUpdateWithoutSymbolInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchlist?: WatchlistUpdateOneRequiredWithoutSymbolsNestedInput
  }

  export type WatchlistSymbolUncheckedUpdateWithoutSymbolInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchlistId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistSymbolUncheckedUpdateManyWithoutSymbolInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchlistId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialMetricUpdateWithoutSymbolInput = {
    id?: StringFieldUpdateOperationsInput | string
    metric?: JsonNullValueInput | InputJsonValue
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialMetricUncheckedUpdateWithoutSymbolInput = {
    id?: StringFieldUpdateOperationsInput | string
    metric?: JsonNullValueInput | InputJsonValue
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialMetricUncheckedUpdateManyWithoutSymbolInput = {
    id?: StringFieldUpdateOperationsInput | string
    metric?: JsonNullValueInput | InputJsonValue
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistSymbolCreateManyWatchlistInput = {
    id?: string
    symbolId: string
    notes?: string | null
    addedAt?: Date | string
  }

  export type WatchlistSymbolUpdateWithoutWatchlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbol?: SymbolUpdateOneRequiredWithoutWatchlistSymbolsNestedInput
  }

  export type WatchlistSymbolUncheckedUpdateWithoutWatchlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbolId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchlistSymbolUncheckedUpdateManyWithoutWatchlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbolId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BacktestCreateManySavedScanInput = {
    id?: string
    userId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    timeframe: $Enums.Timeframe
    definition: JsonNullValueInput | InputJsonValue
    status?: $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: number | null
    avgReturn?: Decimal | DecimalJsLike | number | string | null
    winRate?: Decimal | DecimalJsLike | number | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type SavedScanVersionCreateManySavedScanInput = {
    id?: string
    versionNumber: number
    definition: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdById?: string | null
    comment?: string | null
  }

  export type BacktestUpdateWithoutSavedScanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    definition?: JsonNullValueInput | InputJsonValue
    status?: EnumBacktestStatusFieldUpdateOperationsInput | $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: NullableIntFieldUpdateOperationsInput | number | null
    avgReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBacktestsNestedInput
  }

  export type BacktestUncheckedUpdateWithoutSavedScanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    definition?: JsonNullValueInput | InputJsonValue
    status?: EnumBacktestStatusFieldUpdateOperationsInput | $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: NullableIntFieldUpdateOperationsInput | number | null
    avgReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BacktestUncheckedUpdateManyWithoutSavedScanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | $Enums.Timeframe
    definition?: JsonNullValueInput | InputJsonValue
    status?: EnumBacktestStatusFieldUpdateOperationsInput | $Enums.BacktestStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    totalMatches?: NullableIntFieldUpdateOperationsInput | number | null
    avgReturn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedScanVersionUpdateWithoutSavedScanInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    definition?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SavedScanVersionUncheckedUpdateWithoutSavedScanInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    definition?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SavedScanVersionUncheckedUpdateManyWithoutSavedScanInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    definition?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SymbolCountOutputTypeDefaultArgs instead
     */
    export type SymbolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SymbolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WatchlistCountOutputTypeDefaultArgs instead
     */
    export type WatchlistCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WatchlistCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SavedScanCountOutputTypeDefaultArgs instead
     */
    export type SavedScanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SavedScanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SymbolDefaultArgs instead
     */
    export type SymbolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SymbolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CandleDefaultArgs instead
     */
    export type CandleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CandleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicatorCacheDefaultArgs instead
     */
    export type IndicatorCacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicatorCacheDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WatchlistDefaultArgs instead
     */
    export type WatchlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WatchlistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WatchlistSymbolDefaultArgs instead
     */
    export type WatchlistSymbolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WatchlistSymbolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SavedScanDefaultArgs instead
     */
    export type SavedScanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SavedScanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SavedScanVersionDefaultArgs instead
     */
    export type SavedScanVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SavedScanVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertDefaultArgs instead
     */
    export type AlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BacktestDefaultArgs instead
     */
    export type BacktestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BacktestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FinancialMetricDefaultArgs instead
     */
    export type FinancialMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FinancialMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemStatusDefaultArgs instead
     */
    export type SystemStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemStatusDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}